if ( TRACE ) { TRACE( JSON.parse( '["Cinemachine.AxisBase#getDefaultValue","Cinemachine.AxisBase#ctor","Cinemachine.AxisBase#Validate","Cinemachine.AxisBase#getHashCode","Cinemachine.AxisBase#equals","Cinemachine.AxisBase#$clone","Cinemachine.AxisState#init","Cinemachine.AxisState#getDefaultValue","Cinemachine.AxisState#init","Cinemachine.AxisState#$ctor1","Cinemachine.AxisState#ctor","Cinemachine.AxisState#Validate","Cinemachine.AxisState#Reset","Cinemachine.AxisState#Update","Cinemachine.AxisState#ClampValue","Cinemachine.AxisState#MaxSpeedUpdate","Cinemachine.AxisState#GetMaxSpeed","Cinemachine.AxisState#getHashCode","Cinemachine.AxisState#equals","Cinemachine.AxisState#$clone","Cinemachine.AxisState.Recentering#getDefaultValue","Cinemachine.AxisState.Recentering#$ctor1","Cinemachine.AxisState.Recentering#ctor","Cinemachine.AxisState.Recentering#Validate","Cinemachine.AxisState.Recentering#CopyStateFrom","Cinemachine.AxisState.Recentering#CancelRecentering","Cinemachine.AxisState.Recentering#RecenterNow","Cinemachine.AxisState.Recentering#DoRecentering","Cinemachine.AxisState.Recentering#LegacyUpgrade","Cinemachine.AxisState.Recentering#getHashCode","Cinemachine.AxisState.Recentering#equals","Cinemachine.AxisState.Recentering#$clone","Cinemachine.CameraState#Default#get","Cinemachine.CameraState#init","Cinemachine.CameraState#Lerp","Cinemachine.CameraState#InterpolateFOV","Cinemachine.CameraState#ApplyPosBlendHint","Cinemachine.CameraState#ApplyRotBlendHint","Cinemachine.CameraState#getDefaultValue","Cinemachine.CameraState#HasLookAt#get","Cinemachine.CameraState#CorrectedPosition#get","Cinemachine.CameraState#CorrectedOrientation#get","Cinemachine.CameraState#FinalPosition#get","Cinemachine.CameraState#FinalOrientation#get","Cinemachine.CameraState#init","Cinemachine.CameraState#ctor","Cinemachine.CameraState#GetCustomBlendable","Cinemachine.CameraState#FindCustomBlendable","Cinemachine.CameraState#AddCustomBlendable","Cinemachine.CameraState#InterpolatePosition","Cinemachine.CameraState#getHashCode","Cinemachine.CameraState#equals","Cinemachine.CameraState#$clone","Cinemachine.CameraState.CustomBlendable#getDefaultValue","Cinemachine.CameraState.CustomBlendable#$ctor1","Cinemachine.CameraState.CustomBlendable#ctor","Cinemachine.CameraState.CustomBlendable#getHashCode","Cinemachine.CameraState.CustomBlendable#equals","Cinemachine.CameraState.CustomBlendable#$clone","Cinemachine.CinemachineComponentBase#init","Cinemachine.CinemachineComponentBase#VirtualCamera#get","Cinemachine.CinemachineComponentBase#FollowTarget#get","Cinemachine.CinemachineComponentBase#LookAtTarget#get","Cinemachine.CinemachineComponentBase#AbstractFollowTargetGroup#get","Cinemachine.CinemachineComponentBase#FollowTargetGroup#get","Cinemachine.CinemachineComponentBase#FollowTargetPosition#get","Cinemachine.CinemachineComponentBase#FollowTargetRotation#get","Cinemachine.CinemachineComponentBase#AbstractLookAtTargetGroup#get","Cinemachine.CinemachineComponentBase#LookAtTargetGroup#get","Cinemachine.CinemachineComponentBase#LookAtTargetPosition#get","Cinemachine.CinemachineComponentBase#LookAtTargetRotation#get","Cinemachine.CinemachineComponentBase#VcamState#get","Cinemachine.CinemachineComponentBase#UpdateFollowTargetCache","Cinemachine.CinemachineComponentBase#UpdateLookAtTargetCache","Cinemachine.CinemachineComponentBase#PrePipelineMutateCameraState","Cinemachine.CinemachineComponentBase#OnTransitionFromCamera","Cinemachine.CinemachineComponentBase#OnTargetObjectWarped","Cinemachine.CinemachineBlend#BlendWeight#get","Cinemachine.CinemachineBlend#IsValid#get","Cinemachine.CinemachineBlend#IsComplete#get","Cinemachine.CinemachineBlend#Description#get","Cinemachine.CinemachineBlend#State#get","Cinemachine.CinemachineBlend#ctor","Cinemachine.CinemachineBlend#Uses","Cinemachine.CinemachineBlend#UpdateCameraState","Cinemachine.CinemachineBlendDefinition#getDefaultValue","Cinemachine.CinemachineBlendDefinition#BlendCurve#get","Cinemachine.CinemachineBlendDefinition#$ctor1","Cinemachine.CinemachineBlendDefinition#ctor","Cinemachine.CinemachineBlendDefinition#CreateStandardCurves","Cinemachine.CinemachineBlendDefinition#getHashCode","Cinemachine.CinemachineBlendDefinition#equals","Cinemachine.CinemachineBlendDefinition#$clone","Cinemachine.CinemachineBlenderSettings#init","Cinemachine.CinemachineBlenderSettings#GetBlendForVirtualCameras","Cinemachine.CinemachineBlenderSettings.CustomBlend#getDefaultValue","Cinemachine.CinemachineBlenderSettings.CustomBlend#init","Cinemachine.CinemachineBlenderSettings.CustomBlend#ctor","Cinemachine.CinemachineBlenderSettings.CustomBlend#getHashCode","Cinemachine.CinemachineBlenderSettings.CustomBlend#equals","Cinemachine.CinemachineBlenderSettings.CustomBlend#$clone","Cinemachine.CinemachineBlendListCamera.Instruction#getDefaultValue","Cinemachine.CinemachineBlendListCamera.Instruction#init","Cinemachine.CinemachineBlendListCamera.Instruction#ctor","Cinemachine.CinemachineBlendListCamera.Instruction#getHashCode","Cinemachine.CinemachineBlendListCamera.Instruction#equals","Cinemachine.CinemachineBlendListCamera.Instruction#$clone","Cinemachine.CinemachineBrain#SoloCamera#get","Cinemachine.CinemachineBrain#SoloCamera#set","Cinemachine.CinemachineBrain#GetSoloGUIColor","Cinemachine.CinemachineBrain#DeepCamBFromBlend","Cinemachine.CinemachineBrain#OutputCamera#get","Cinemachine.CinemachineBrain#DefaultWorldUp#get","Cinemachine.CinemachineBrain#ActiveVirtualCamera#get","Cinemachine.CinemachineBrain#IsBlending#get","Cinemachine.CinemachineBrain#ActiveBlend#get","Cinemachine.CinemachineBrain#init","Cinemachine.CinemachineBrain#OnEnable","Cinemachine.CinemachineBrain#OnDisable","Cinemachine.CinemachineBrain#Start","Cinemachine.CinemachineBrain#OnGuiHandler","Cinemachine.CinemachineBrain#AfterPhysics","Cinemachine.CinemachineBrain#LateUpdate","Cinemachine.CinemachineBrain#GetEffectiveDeltaTime","Cinemachine.CinemachineBrain#UpdateVirtualCameras","Cinemachine.CinemachineBrain#GetBrainFrame","Cinemachine.CinemachineBrain#SetCameraOverride","Cinemachine.CinemachineBrain#ReleaseCameraOverride","Cinemachine.CinemachineBrain#ProcessActiveCamera","Cinemachine.CinemachineBrain#UpdateFrame0","Cinemachine.CinemachineBrain#UpdateCurrentLiveCameras","Cinemachine.CinemachineBrain#IsLive","Cinemachine.CinemachineBrain#TopCameraFromPriorityQueue","Cinemachine.CinemachineBrain#LookupBlend","Cinemachine.CinemachineBrain#PushStateToUnityCamera","Cinemachine.CinemachineBrain.BrainFrame#Active#get","Cinemachine.CinemachineBrain.BrainFrame#TimeOverrideExpired#get","Cinemachine.CinemachineBrain.BrainFrame#init","Cinemachine.CinemachineClearShot.Pair#getDefaultValue","Cinemachine.CinemachineClearShot.Pair#ctor","Cinemachine.CinemachineClearShot.Pair#getHashCode","Cinemachine.CinemachineClearShot.Pair#equals","Cinemachine.CinemachineClearShot.Pair#$clone","Cinemachine.CinemachineExtension#init","Cinemachine.CinemachineExtension#VirtualCamera#get","Cinemachine.CinemachineExtension#Awake","Cinemachine.CinemachineExtension#OnDestroy","Cinemachine.CinemachineExtension#ConnectToVcam","Cinemachine.CinemachineExtension#InvokePostPipelineStageCallback","Cinemachine.CinemachineExtension#OnTargetObjectWarped","Cinemachine.CinemachineExtension#OnTransitionFromCamera","Cinemachine.CinemachineExtension#GetExtraState","Cinemachine.CinemachineExtension#GetAllExtraStates","Cinemachine.CinemachineCollider.VcamExtraState#init","Cinemachine.CinemachineCollider.VcamExtraState#AddPointToDebugPath","Cinemachine.CinemachineCollider.VcamExtraState#ApplyDistanceSmoothing","Cinemachine.CinemachineCollider.VcamExtraState#UpdateDistanceSmoothing","Cinemachine.CinemachineCollider.VcamExtraState#ResetDistanceSmoothing","Cinemachine.CinemachineImpulseSource#init","Cinemachine.CinemachineImpulseSource#OnValidate","Cinemachine.CinemachineImpulseSource#GenerateImpulseAt","Cinemachine.CinemachineImpulseSource#GenerateImpulse$1","Cinemachine.CinemachineImpulseSource#GenerateImpulse","Cinemachine.CinemachineComposer.FovCache#getDefaultValue","Cinemachine.CinemachineComposer.FovCache#init","Cinemachine.CinemachineComposer.FovCache#ctor","Cinemachine.CinemachineComposer.FovCache#UpdateCache","Cinemachine.CinemachineComposer.FovCache#ScreenToFOV","Cinemachine.CinemachineComposer.FovCache#getHashCode","Cinemachine.CinemachineComposer.FovCache#equals","Cinemachine.CinemachineComposer.FovCache#$clone","Cinemachine.CinemachineConfiner.VcamExtraState#init","Cinemachine.CinemachineCore#Instance#get","Cinemachine.CinemachineCore#init","Cinemachine.CinemachineCore#InitializeModule","Cinemachine.CinemachineCore#GetUpdateTarget","Cinemachine.CinemachineCore#BrainCount#get","Cinemachine.CinemachineCore#VirtualCameraCount#get","Cinemachine.CinemachineCore#init","Cinemachine.CinemachineCore#GetActiveBrain","Cinemachine.CinemachineCore#AddActiveBrain","Cinemachine.CinemachineCore#RemoveActiveBrain","Cinemachine.CinemachineCore#GetVirtualCamera","Cinemachine.CinemachineCore#AddActiveCamera","Cinemachine.CinemachineCore#RemoveActiveCamera","Cinemachine.CinemachineCore#CameraAwakened","Cinemachine.CinemachineCore#CameraDestroyed","Cinemachine.CinemachineCore#UpdateAllActiveVirtualCameras","Cinemachine.CinemachineCore#UpdateVirtualCamera","Cinemachine.CinemachineCore#GetVcamUpdateStatus","Cinemachine.CinemachineCore#IsLive","Cinemachine.CinemachineCore#GenerateCameraActivationEvent","Cinemachine.CinemachineCore#GenerateCameraCutEvent","Cinemachine.CinemachineCore#FindPotentialTargetBrain","Cinemachine.CinemachineCore.UpdateFilter#init","Cinemachine.CinemachineCore.UpdateStatus#ctor","Cinemachine.CinemachineDollyCart#init","Cinemachine.CinemachineDollyCart#FixedUpdate","Cinemachine.CinemachineDollyCart#Update","Cinemachine.CinemachineDollyCart#LateUpdate","Cinemachine.CinemachineDollyCart#SetCartPosition","Cinemachine.CinemachineEmbeddedAssetPropertyAttribute#ctor","Cinemachine.CinemachineFreeLook.Orbit#getDefaultValue","Cinemachine.CinemachineFreeLook.Orbit#$ctor1","Cinemachine.CinemachineFreeLook.Orbit#ctor","Cinemachine.CinemachineFreeLook.Orbit#getHashCode","Cinemachine.CinemachineFreeLook.Orbit#equals","Cinemachine.CinemachineFreeLook.Orbit#$clone","Cinemachine.CinemachineImpulseDefinition#init","Cinemachine.CinemachineImpulseDefinition#OnValidate","Cinemachine.CinemachineImpulseDefinition#CreateEvent","Cinemachine.CinemachineImpulseManager#Instance#get","Cinemachine.CinemachineImpulseManager#init","Cinemachine.CinemachineImpulseManager#CurrentTime#get","Cinemachine.CinemachineImpulseManager#ctor","Cinemachine.CinemachineImpulseManager#GetImpulseAt","Cinemachine.CinemachineImpulseManager#NewImpulseEvent","Cinemachine.CinemachineImpulseManager#AddImpulseEvent","Cinemachine.CinemachineImpulseManager#Clear","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#Default","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#getDefaultValue","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#Duration#get","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#ctor","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#GetValueAt","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#ChangeStopTime","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#Clear","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#Validate","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#getHashCode","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#equals","Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#$clone","Cinemachine.CinemachineImpulseManager.ImpulseEvent#Expired#get","Cinemachine.CinemachineImpulseManager.ImpulseEvent#init","Cinemachine.CinemachineImpulseManager.ImpulseEvent#ctor","Cinemachine.CinemachineImpulseManager.ImpulseEvent#Cancel","Cinemachine.CinemachineImpulseManager.ImpulseEvent#DistanceDecay","Cinemachine.CinemachineImpulseManager.ImpulseEvent#GetDecayedSignal","Cinemachine.CinemachineImpulseManager.ImpulseEvent#Clear","Cinemachine.CinemachineInputAxisDriver#init","Cinemachine.CinemachineInputAxisDriver#getDefaultValue","Cinemachine.CinemachineInputAxisDriver#ctor","Cinemachine.CinemachineInputAxisDriver#Validate","Cinemachine.CinemachineInputAxisDriver#Update","Cinemachine.CinemachineInputAxisDriver#Update$1","Cinemachine.CinemachineInputAxisDriver#ClampValue","Cinemachine.CinemachineInputAxisDriver#getHashCode","Cinemachine.CinemachineInputAxisDriver#equals","Cinemachine.CinemachineInputAxisDriver#$clone","Cinemachine.CinemachineOrbitalTransposer.Heading#getDefaultValue","Cinemachine.CinemachineOrbitalTransposer.Heading#$ctor1","Cinemachine.CinemachineOrbitalTransposer.Heading#ctor","Cinemachine.CinemachineOrbitalTransposer.Heading#getHashCode","Cinemachine.CinemachineOrbitalTransposer.Heading#equals","Cinemachine.CinemachineOrbitalTransposer.Heading#$clone","Cinemachine.CinemachinePathBase#PathLength#get","Cinemachine.CinemachinePathBase#init","Cinemachine.CinemachinePathBase#StandardizePos","Cinemachine.CinemachinePathBase#FindClosestPoint","Cinemachine.CinemachinePathBase#MinUnit","Cinemachine.CinemachinePathBase#MaxUnit","Cinemachine.CinemachinePathBase#StandardizeUnit","Cinemachine.CinemachinePathBase#EvaluatePositionAtUnit","Cinemachine.CinemachinePathBase#EvaluateTangentAtUnit","Cinemachine.CinemachinePathBase#EvaluateOrientationAtUnit","Cinemachine.CinemachinePathBase#InvalidateDistanceCache","Cinemachine.CinemachinePathBase#DistanceCacheIsValid","Cinemachine.CinemachinePathBase#StandardizePathDistance","Cinemachine.CinemachinePathBase#ToNativePathUnits","Cinemachine.CinemachinePathBase#FromPathNativeUnits","Cinemachine.CinemachinePathBase#ResamplePath","Cinemachine.CinemachinePath.Waypoint#getDefaultValue","Cinemachine.CinemachinePath.Waypoint#init","Cinemachine.CinemachinePath.Waypoint#ctor","Cinemachine.CinemachinePath.Waypoint#getHashCode","Cinemachine.CinemachinePath.Waypoint#equals","Cinemachine.CinemachinePath.Waypoint#$clone","Cinemachine.CinemachinePathBase.Appearance#init","Cinemachine.CinemachineSmoothPath.Waypoint#FromVector4","Cinemachine.CinemachineSmoothPath.Waypoint#getDefaultValue","Cinemachine.CinemachineSmoothPath.Waypoint#AsVector4#get","Cinemachine.CinemachineSmoothPath.Waypoint#init","Cinemachine.CinemachineSmoothPath.Waypoint#ctor","Cinemachine.CinemachineSmoothPath.Waypoint#getHashCode","Cinemachine.CinemachineSmoothPath.Waypoint#equals","Cinemachine.CinemachineSmoothPath.Waypoint#$clone","Cinemachine.CinemachineStateDrivenCamera.HashPair#getDefaultValue","Cinemachine.CinemachineStateDrivenCamera.HashPair#ctor","Cinemachine.CinemachineStateDrivenCamera.HashPair#getHashCode","Cinemachine.CinemachineStateDrivenCamera.HashPair#equals","Cinemachine.CinemachineStateDrivenCamera.HashPair#$clone","Cinemachine.CinemachineStateDrivenCamera.Instruction#getDefaultValue","Cinemachine.CinemachineStateDrivenCamera.Instruction#ctor","Cinemachine.CinemachineStateDrivenCamera.Instruction#getHashCode","Cinemachine.CinemachineStateDrivenCamera.Instruction#equals","Cinemachine.CinemachineStateDrivenCamera.Instruction#$clone","Cinemachine.CinemachineStateDrivenCamera.ParentHash#getDefaultValue","Cinemachine.CinemachineStateDrivenCamera.ParentHash#$ctor1","Cinemachine.CinemachineStateDrivenCamera.ParentHash#ctor","Cinemachine.CinemachineStateDrivenCamera.ParentHash#getHashCode","Cinemachine.CinemachineStateDrivenCamera.ParentHash#equals","Cinemachine.CinemachineStateDrivenCamera.ParentHash#$clone","Cinemachine.CinemachineTargetGroup.Target#getDefaultValue","Cinemachine.CinemachineTargetGroup.Target#ctor","Cinemachine.CinemachineTargetGroup.Target#getHashCode","Cinemachine.CinemachineTargetGroup.Target#equals","Cinemachine.CinemachineTargetGroup.Target#$clone","Cinemachine.CinemachineTrackedDolly.AutoDolly#getDefaultValue","Cinemachine.CinemachineTrackedDolly.AutoDolly#$ctor1","Cinemachine.CinemachineTrackedDolly.AutoDolly#ctor","Cinemachine.CinemachineTrackedDolly.AutoDolly#getHashCode","Cinemachine.CinemachineTrackedDolly.AutoDolly#equals","Cinemachine.CinemachineTrackedDolly.AutoDolly#$clone","Cinemachine.CinemachineTriggerAction#init","Cinemachine.CinemachineTriggerAction#Filter","Cinemachine.CinemachineTriggerAction#InternalDoTriggerEnter","Cinemachine.CinemachineTriggerAction#InternalDoTriggerExit","Cinemachine.CinemachineTriggerAction#OnEnable","Cinemachine.CinemachineTriggerAction#OnTriggerEnter","Cinemachine.CinemachineTriggerAction#OnTriggerExit","Cinemachine.CinemachineTriggerAction#OnCollisionEnter","Cinemachine.CinemachineTriggerAction#OnCollisionExit","Cinemachine.CinemachineTriggerAction#OnTriggerEnter2D","Cinemachine.CinemachineTriggerAction#OnTriggerExit2D","Cinemachine.CinemachineTriggerAction#OnCollisionEnter2D","Cinemachine.CinemachineTriggerAction#OnCollisionExit2D","Cinemachine.CinemachineTriggerAction.ActionSettings#getDefaultValue","Cinemachine.CinemachineTriggerAction.ActionSettings#$ctor1","Cinemachine.CinemachineTriggerAction.ActionSettings#ctor","Cinemachine.CinemachineTriggerAction.ActionSettings#Invoke","Cinemachine.CinemachineTriggerAction.ActionSettings#getHashCode","Cinemachine.CinemachineTriggerAction.ActionSettings#equals","Cinemachine.CinemachineTriggerAction.ActionSettings#$clone","Cinemachine.CinemachineVirtualCameraBase.TransitionParams#getDefaultValue","Cinemachine.CinemachineVirtualCameraBase.TransitionParams#ctor","Cinemachine.CinemachineVirtualCameraBase.TransitionParams#getHashCode","Cinemachine.CinemachineVirtualCameraBase.TransitionParams#equals","Cinemachine.CinemachineVirtualCameraBase.TransitionParams#$clone","Cinemachine.DocumentationSortingAttribute#ctor","Cinemachine.LensSettings#init","Cinemachine.LensSettings#FromCamera","Cinemachine.LensSettings#Lerp","Cinemachine.LensSettings#getDefaultValue","Cinemachine.LensSettings#Aspect#get","Cinemachine.LensSettings#init","Cinemachine.LensSettings#$ctor1","Cinemachine.LensSettings#ctor","Cinemachine.LensSettings#SnapshotCameraReadOnlyProperties$1","Cinemachine.LensSettings#SnapshotCameraReadOnlyProperties","Cinemachine.LensSettings#Validate","Cinemachine.LensSettings#getHashCode","Cinemachine.LensSettings#equals","Cinemachine.LensSettings#$clone","Cinemachine.NoiseSettings.NoiseParams#getDefaultValue","Cinemachine.NoiseSettings.NoiseParams#ctor","Cinemachine.NoiseSettings.NoiseParams#GetValueAt","Cinemachine.NoiseSettings.NoiseParams#getHashCode","Cinemachine.NoiseSettings.NoiseParams#equals","Cinemachine.NoiseSettings.NoiseParams#$clone","Cinemachine.NoiseSettings.TransformNoiseParams#getDefaultValue","Cinemachine.NoiseSettings.TransformNoiseParams#init","Cinemachine.NoiseSettings.TransformNoiseParams#ctor","Cinemachine.NoiseSettings.TransformNoiseParams#GetValueAt","Cinemachine.NoiseSettings.TransformNoiseParams#getHashCode","Cinemachine.NoiseSettings.TransformNoiseParams#equals","Cinemachine.NoiseSettings.TransformNoiseParams#$clone","Cinemachine.RuntimeUtility#DestroyObject","Cinemachine.UpdateTracker#init","Cinemachine.UpdateTracker#InitializeModule","Cinemachine.UpdateTracker#UpdateTargets","Cinemachine.UpdateTracker#GetPreferredUpdate","Cinemachine.UpdateTracker#OnUpdate","Cinemachine.UpdateTracker.UpdateStatus#init","Cinemachine.UpdateTracker.UpdateStatus#init","Cinemachine.UpdateTracker.UpdateStatus#ctor","Cinemachine.UpdateTracker.UpdateStatus#OnUpdate","Cinemachine.Utility.CinemachineDebug#ReleaseScreenPos","Cinemachine.Utility.CinemachineDebug#GetScreenPos","Cinemachine.Utility.CinemachineDebug#SBFromPool","Cinemachine.Utility.CinemachineDebug#ReturnToPool","Cinemachine.Utility.Damper#init","Cinemachine.Utility.Damper#DecayConstant","Cinemachine.Utility.Damper#DecayedRemainder","Cinemachine.Utility.Damper#Damp","Cinemachine.Utility.Damper#Damp$2","Cinemachine.Utility.Damper#Damp$1","Cinemachine.Utility.GaussianWindow1d$1#KernelSize#get","Cinemachine.Utility.GaussianWindow1d$1#BufferLength#get","Cinemachine.Utility.GaussianWindow1d$1#init","Cinemachine.Utility.GaussianWindow1d$1#ctor","Cinemachine.Utility.GaussianWindow1d$1#GenerateKernel","Cinemachine.Utility.GaussianWindow1d$1#Reset","Cinemachine.Utility.GaussianWindow1d$1#IsEmpty","Cinemachine.Utility.GaussianWindow1d$1#AddValue","Cinemachine.Utility.GaussianWindow1d$1#Filter","Cinemachine.Utility.GaussianWindow1d$1#Value","Cinemachine.Utility.GaussianWindow1d$1#SetBufferValue","Cinemachine.Utility.GaussianWindow1d$1#GetBufferValue","Cinemachine.Utility.HeadingTracker#Decay","Cinemachine.Utility.HeadingTracker#FilterSize#get","Cinemachine.Utility.HeadingTracker#init","Cinemachine.Utility.HeadingTracker#ctor","Cinemachine.Utility.HeadingTracker#ClearHistory","Cinemachine.Utility.HeadingTracker#Add","Cinemachine.Utility.HeadingTracker#PopBottom","Cinemachine.Utility.HeadingTracker#DecayHistory","Cinemachine.Utility.HeadingTracker#GetReliableHeading","Cinemachine.Utility.HeadingTracker.Item#getDefaultValue","Cinemachine.Utility.HeadingTracker.Item#init","Cinemachine.Utility.HeadingTracker.Item#ctor","Cinemachine.Utility.HeadingTracker.Item#getHashCode","Cinemachine.Utility.HeadingTracker.Item#equals","Cinemachine.Utility.HeadingTracker.Item#$clone","Cinemachine.Utility.PositionPredictor#init","Cinemachine.Utility.PositionPredictor#Smoothing#get","Cinemachine.Utility.PositionPredictor#Smoothing#set","Cinemachine.Utility.PositionPredictor#IsEmpty#get","Cinemachine.Utility.PositionPredictor#init","Cinemachine.Utility.PositionPredictor#ApplyTransformDelta","Cinemachine.Utility.PositionPredictor#Reset","Cinemachine.Utility.PositionPredictor#AddPosition","Cinemachine.Utility.PositionPredictor#PredictPositionDelta","Cinemachine.Utility.PositionPredictor#PredictPosition","Cinemachine.Utility.SplineHelpers#Bezier3","Cinemachine.Utility.SplineHelpers#BezierTangent3","Cinemachine.Utility.SplineHelpers#Bezier1","Cinemachine.Utility.SplineHelpers#BezierTangent1","Cinemachine.Utility.SplineHelpers#ComputeSmoothControlPoints","Cinemachine.Utility.SplineHelpers#ComputeSmoothControlPointsLooped","Cinemachine.Utility.UnityQuaternionExtensions#SlerpWithReferenceUp","Cinemachine.Utility.UnityQuaternionExtensions#Normalized","Cinemachine.Utility.UnityQuaternionExtensions#GetCameraRotationToTarget","Cinemachine.Utility.UnityQuaternionExtensions#ApplyCameraRotation","Cinemachine.Utility.UnityRectExtensions#Inflated","Cinemachine.Utility.UnityVectorExtensions#init","Cinemachine.Utility.UnityVectorExtensions#ClosestPointOnSegment$1","Cinemachine.Utility.UnityVectorExtensions#ClosestPointOnSegment","Cinemachine.Utility.UnityVectorExtensions#ProjectOntoPlane","Cinemachine.Utility.UnityVectorExtensions#Abs","Cinemachine.Utility.UnityVectorExtensions#AlmostZero","Cinemachine.Utility.UnityVectorExtensions#Angle","Cinemachine.Utility.UnityVectorExtensions#SignedAngle","Cinemachine.Utility.UnityVectorExtensions#SlerpWithReferenceUp","CinemachineMixer#init","CinemachineMixer#OnPlayableDestroy","CinemachineMixer#PrepareFrame","CinemachineMixer#ProcessFrame","CinemachineMixer#GetDeltaTime","CinemachineMixer.ClipInfo#getDefaultValue","CinemachineMixer.ClipInfo#ctor","CinemachineMixer.ClipInfo#getHashCode","CinemachineMixer.ClipInfo#equals","CinemachineMixer.ClipInfo#$clone","CinemachineShot#init","CinemachineShot#CreatePlayable","CinemachineShot#GatherProperties","CinemachineShotPlayable#IsValid#get","CinemachineTouchInputMapper#init","CinemachineTouchInputMapper#Start","CinemachineTouchInputMapper#GetInputAxis","CinemachineTrack#CreateTrackMixer","Cinemachine.BlendSourceVirtualCamera#Name#get","Cinemachine.BlendSourceVirtualCamera#Description#get","Cinemachine.BlendSourceVirtualCamera#VirtualCameraGameObject#get","Cinemachine.BlendSourceVirtualCamera#IsValid#get","Cinemachine.BlendSourceVirtualCamera#ParentCamera#get","Cinemachine.BlendSourceVirtualCamera#init","Cinemachine.BlendSourceVirtualCamera#ctor","Cinemachine.BlendSourceVirtualCamera#IsLiveChild","Cinemachine.BlendSourceVirtualCamera#UpdateCameraState","Cinemachine.BlendSourceVirtualCamera#InternalUpdateCameraState","Cinemachine.BlendSourceVirtualCamera#OnTransitionFromCamera","Cinemachine.BlendSourceVirtualCamera#OnTargetObjectWarped","Cinemachine.BlendSourceVirtualCamera#CalculateNewState","Cinemachine.CinemachineBasicMultiChannelPerlin#IsValid#get","Cinemachine.CinemachineBasicMultiChannelPerlin#Stage#get","Cinemachine.CinemachineBasicMultiChannelPerlin#init","Cinemachine.CinemachineBasicMultiChannelPerlin#MutateCameraState","Cinemachine.CinemachineBasicMultiChannelPerlin#ReSeed","Cinemachine.CinemachineBasicMultiChannelPerlin#Initialize","Cinemachine.CinemachineVirtualCameraBase#ValidatingStreamVersion#get","Cinemachine.CinemachineVirtualCameraBase#ValidatingStreamVersion#set","Cinemachine.CinemachineVirtualCameraBase#Name#get","Cinemachine.CinemachineVirtualCameraBase#Description#get","Cinemachine.CinemachineVirtualCameraBase#Priority#get","Cinemachine.CinemachineVirtualCameraBase#Priority#set","Cinemachine.CinemachineVirtualCameraBase#VirtualCameraGameObject#get","Cinemachine.CinemachineVirtualCameraBase#IsValid#get","Cinemachine.CinemachineVirtualCameraBase#ParentCamera#get","Cinemachine.CinemachineVirtualCameraBase#init","Cinemachine.CinemachineVirtualCameraBase#IsLiveChild","Cinemachine.CinemachineVirtualCameraBase#UpdateCameraState","Cinemachine.CinemachineVirtualCameraBase#OnTransitionFromCamera","Cinemachine.CinemachineVirtualCameraBase#OnTargetObjectWarped","Cinemachine.CinemachineVirtualCameraBase#AddExtension","Cinemachine.CinemachineVirtualCameraBase#RemoveExtension","Cinemachine.CinemachineVirtualCameraBase#InvokePostPipelineStageCallback","Cinemachine.CinemachineVirtualCameraBase#InvokeOnTransitionInExtensions","Cinemachine.CinemachineVirtualCameraBase#ApplyPositionBlendMethod","Cinemachine.CinemachineVirtualCameraBase#OnDestroy","Cinemachine.CinemachineVirtualCameraBase#OnTransformParentChanged","Cinemachine.CinemachineVirtualCameraBase#Start","Cinemachine.CinemachineVirtualCameraBase#OnValidate","Cinemachine.CinemachineVirtualCameraBase#OnEnable","Cinemachine.CinemachineVirtualCameraBase#OnDisable","Cinemachine.CinemachineVirtualCameraBase#Update","Cinemachine.CinemachineVirtualCameraBase#UpdateSlaveStatus","Cinemachine.CinemachineVirtualCameraBase#ResolveLookAt","Cinemachine.CinemachineVirtualCameraBase#ResolveFollow","Cinemachine.CinemachineVirtualCameraBase#UpdateVcamPoolStatus","Cinemachine.CinemachineVirtualCameraBase#MoveToTopOfPrioritySubqueue","Cinemachine.CinemachineVirtualCameraBase#CreateBlend","Cinemachine.CinemachineVirtualCameraBase#PullStateFromVirtualCamera","Cinemachine.CinemachineCollider#init","Cinemachine.CinemachineCollider#DestroyCollider","Cinemachine.CinemachineCollider#DebugPaths#get","Cinemachine.CinemachineCollider#init","Cinemachine.CinemachineCollider#IsTargetObscured","Cinemachine.CinemachineCollider#CameraWasDisplaced","Cinemachine.CinemachineCollider#OnValidate","Cinemachine.CinemachineCollider#OnDestroy","Cinemachine.CinemachineCollider#PostPipelineStageCallback","Cinemachine.CinemachineCollider#PreserveLignOfSight","Cinemachine.CinemachineCollider#PullCameraInFrontOfNearestObstacle","Cinemachine.CinemachineCollider#RaycastIgnoreTag","Cinemachine.CinemachineCollider#PushCameraBack","Cinemachine.CinemachineCollider#GetWalkingDirection","Cinemachine.CinemachineCollider#GetPushBackDistance","Cinemachine.CinemachineCollider#ClampRayToBounds","Cinemachine.CinemachineCollider#RespectCameraRadius","Cinemachine.CinemachineCollider#CheckForTargetObstructions","Cinemachine.CinemachineCollider#IsTargetOffscreen","Cinemachine.CinemachineCollisionImpulseSource#init","Cinemachine.CinemachineCollisionImpulseSource#Start","Cinemachine.CinemachineCollisionImpulseSource#OnEnable","Cinemachine.CinemachineCollisionImpulseSource#OnCollisionEnter","Cinemachine.CinemachineCollisionImpulseSource#OnTriggerEnter","Cinemachine.CinemachineCollisionImpulseSource#GetMassAndVelocity","Cinemachine.CinemachineCollisionImpulseSource#GenerateImpactEvent","Cinemachine.CinemachineCollisionImpulseSource#OnCollisionEnter2D","Cinemachine.CinemachineCollisionImpulseSource#OnTriggerEnter2D","Cinemachine.CinemachineCollisionImpulseSource#GetMassAndVelocity2D","Cinemachine.CinemachineCollisionImpulseSource#GenerateImpactEvent2D","Cinemachine.CinemachineComposer#IsValid#get","Cinemachine.CinemachineComposer#Stage#get","Cinemachine.CinemachineComposer#SoftGuideRect#get","Cinemachine.CinemachineComposer#SoftGuideRect#set","Cinemachine.CinemachineComposer#HardGuideRect#get","Cinemachine.CinemachineComposer#HardGuideRect#set","Cinemachine.CinemachineComposer#init","Cinemachine.CinemachineComposer#GetLookAtPointAndSetTrackedPoint","Cinemachine.CinemachineComposer#OnTargetObjectWarped","Cinemachine.CinemachineComposer#PrePipelineMutateCameraState","Cinemachine.CinemachineComposer#MutateCameraState","Cinemachine.CinemachineComposer#RotateToScreenBounds","Cinemachine.CinemachineComposer#ClampVerticalBounds","Cinemachine.CinemachineConfiner#IsValid#get","Cinemachine.CinemachineConfiner#init","Cinemachine.CinemachineConfiner#CameraWasDisplaced","Cinemachine.CinemachineConfiner#OnValidate","Cinemachine.CinemachineConfiner#PostPipelineStageCallback","Cinemachine.CinemachineConfiner#InvalidatePathCache","Cinemachine.CinemachineConfiner#ValidatePathCache","Cinemachine.CinemachineConfiner#ConfinePoint","Cinemachine.CinemachineConfiner#ConfineScreenEdges","Cinemachine.CinemachineFollowZoom#init","Cinemachine.CinemachineFollowZoom#OnValidate","Cinemachine.CinemachineFollowZoom#PostPipelineStageCallback","Cinemachine.CinemachineFramingTransposer#init","Cinemachine.CinemachineFramingTransposer#GetScreenSpaceGroupBoundingBox","Cinemachine.CinemachineFramingTransposer#SoftGuideRect#get","Cinemachine.CinemachineFramingTransposer#SoftGuideRect#set","Cinemachine.CinemachineFramingTransposer#HardGuideRect#get","Cinemachine.CinemachineFramingTransposer#HardGuideRect#set","Cinemachine.CinemachineFramingTransposer#IsValid#get","Cinemachine.CinemachineFramingTransposer#Stage#get","Cinemachine.CinemachineFramingTransposer#init","Cinemachine.CinemachineFramingTransposer#OnValidate","Cinemachine.CinemachineFramingTransposer#OnTargetObjectWarped","Cinemachine.CinemachineFramingTransposer#OnTransitionFromCamera","Cinemachine.CinemachineFramingTransposer#ScreenToOrtho","Cinemachine.CinemachineFramingTransposer#OrthoOffsetToScreenBounds","Cinemachine.CinemachineFramingTransposer#MutateCameraState","Cinemachine.CinemachineFramingTransposer#GetTargetHeight","Cinemachine.CinemachineFramingTransposer#ComputeGroupBounds","Cinemachine.CinemachineHardLockToTarget#IsValid#get","Cinemachine.CinemachineHardLockToTarget#Stage#get","Cinemachine.CinemachineHardLockToTarget#init","Cinemachine.CinemachineHardLockToTarget#MutateCameraState","Cinemachine.CinemachineHardLookAt#IsValid#get","Cinemachine.CinemachineHardLookAt#Stage#get","Cinemachine.CinemachineHardLookAt#MutateCameraState","Cinemachine.CinemachineImpulseDefinition.SignalSource#SignalDuration#get","Cinemachine.CinemachineImpulseDefinition.SignalSource#init","Cinemachine.CinemachineImpulseDefinition.SignalSource#ctor","Cinemachine.CinemachineImpulseDefinition.SignalSource#GetSignal","Cinemachine.CinemachineImpulseListener#init","Cinemachine.CinemachineImpulseListener#PostPipelineStageCallback","Cinemachine.CinemachineTransposer#EffectiveOffset#get","Cinemachine.CinemachineTransposer#IsValid#get","Cinemachine.CinemachineTransposer#Stage#get","Cinemachine.CinemachineTransposer#Damping#get","Cinemachine.CinemachineTransposer#AngularDamping#get","Cinemachine.CinemachineTransposer#init","Cinemachine.CinemachineTransposer#OnValidate","Cinemachine.CinemachineTransposer#MutateCameraState","Cinemachine.CinemachineTransposer#OnTargetObjectWarped","Cinemachine.CinemachineTransposer#InitPrevFrameStateInfo","Cinemachine.CinemachineTransposer#TrackTarget","Cinemachine.CinemachineTransposer#GetTargetCameraPosition","Cinemachine.CinemachineTransposer#GetReferenceOrientation","Cinemachine.CinemachinePath#MinPos#get","Cinemachine.CinemachinePath#MaxPos#get","Cinemachine.CinemachinePath#Looped#get","Cinemachine.CinemachinePath#DistanceCacheSampleStepsPerSegment#get","Cinemachine.CinemachinePath#init","Cinemachine.CinemachinePath#Reset","Cinemachine.CinemachinePath#GetBoundingIndices","Cinemachine.CinemachinePath#EvaluatePosition","Cinemachine.CinemachinePath#EvaluateTangent","Cinemachine.CinemachinePath#EvaluateOrientation","Cinemachine.CinemachinePath#OnValidate","Cinemachine.CinemachinePOV#IsValid#get","Cinemachine.CinemachinePOV#Stage#get","Cinemachine.CinemachinePOV#init","Cinemachine.CinemachinePOV#OnValidate","Cinemachine.CinemachinePOV#PrePipelineMutateCameraState","Cinemachine.CinemachinePOV#MutateCameraState","Cinemachine.CinemachinePOV#ApplyPOV","Cinemachine.CinemachinePOV#GetRecenterTarget","Cinemachine.CinemachinePOV#OnTransitionFromCamera","Cinemachine.CinemachineSameAsFollowTarget#IsValid#get","Cinemachine.CinemachineSameAsFollowTarget#Stage#get","Cinemachine.CinemachineSameAsFollowTarget#init","Cinemachine.CinemachineSameAsFollowTarget#MutateCameraState","Cinemachine.CinemachineSmoothPath#MinPos#get","Cinemachine.CinemachineSmoothPath#MaxPos#get","Cinemachine.CinemachineSmoothPath#Looped#get","Cinemachine.CinemachineSmoothPath#DistanceCacheSampleStepsPerSegment#get","Cinemachine.CinemachineSmoothPath#init","Cinemachine.CinemachineSmoothPath#OnValidate","Cinemachine.CinemachineSmoothPath#Reset","Cinemachine.CinemachineSmoothPath#InvalidateDistanceCache","Cinemachine.CinemachineSmoothPath#UpdateControlPoints","Cinemachine.CinemachineSmoothPath#GetBoundingIndices","Cinemachine.CinemachineSmoothPath#EvaluatePosition","Cinemachine.CinemachineSmoothPath#EvaluateTangent","Cinemachine.CinemachineSmoothPath#EvaluateOrientation","Cinemachine.CinemachineStoryboard#StaticBlendingHandler","Cinemachine.CinemachineStoryboard#InitializeModule","Cinemachine.CinemachineStoryboard#CanvasName#get","Cinemachine.CinemachineStoryboard#init","Cinemachine.CinemachineStoryboard#PostPipelineStageCallback","Cinemachine.CinemachineStoryboard#ConnectToVcam","Cinemachine.CinemachineStoryboard#CameraUpdatedCallback","Cinemachine.CinemachineStoryboard#LocateMyCanvas","Cinemachine.CinemachineStoryboard#CreateCanvas","Cinemachine.CinemachineStoryboard#DestroyCanvas","Cinemachine.CinemachineStoryboard#PlaceImage","Cinemachine.CinemachineTargetGroup#WeightedMemberBounds","Cinemachine.CinemachineTargetGroup#Transform#get","Cinemachine.CinemachineTargetGroup#Sphere#get","Cinemachine.CinemachineTargetGroup#IsEmpty#get","Cinemachine.CinemachineTargetGroup#init","Cinemachine.CinemachineTargetGroup#AddMember","Cinemachine.CinemachineTargetGroup#RemoveMember","Cinemachine.CinemachineTargetGroup#FindMember","Cinemachine.CinemachineTargetGroup#GetWeightedBoundsForMember","Cinemachine.CinemachineTargetGroup#GetViewSpaceBoundingBox","Cinemachine.CinemachineTargetGroup#DoUpdate","Cinemachine.CinemachineTargetGroup#CalculateAveragePosition","Cinemachine.CinemachineTargetGroup#CalculateAverageOrientation","Cinemachine.CinemachineTargetGroup#CalculateBoundingBox","Cinemachine.CinemachineTargetGroup#OnValidate","Cinemachine.CinemachineTargetGroup#FixedUpdate","Cinemachine.CinemachineTargetGroup#Update","Cinemachine.CinemachineTargetGroup#LateUpdate","Cinemachine.CinemachineTargetGroup#GetViewSpaceAngularBounds","Cinemachine.CinemachineTrackedDolly#IsValid#get","Cinemachine.CinemachineTrackedDolly#Stage#get","Cinemachine.CinemachineTrackedDolly#AngularDamping#get","Cinemachine.CinemachineTrackedDolly#init","Cinemachine.CinemachineTrackedDolly#MutateCameraState","Cinemachine.CinemachineTrackedDolly#GetCameraOrientationAtPathPoint","Cinemachine.StaticPointVirtualCamera#Description#get","Cinemachine.StaticPointVirtualCamera#VirtualCameraGameObject#get","Cinemachine.StaticPointVirtualCamera#IsValid#get","Cinemachine.StaticPointVirtualCamera#ParentCamera#get","Cinemachine.StaticPointVirtualCamera#init","Cinemachine.StaticPointVirtualCamera#ctor","Cinemachine.StaticPointVirtualCamera#IsLiveChild","Cinemachine.StaticPointVirtualCamera#UpdateCameraState","Cinemachine.StaticPointVirtualCamera#InternalUpdateCameraState","Cinemachine.StaticPointVirtualCamera#OnTransitionFromCamera","Cinemachine.StaticPointVirtualCamera#OnTargetObjectWarped","Cinemachine.StaticPointVirtualCamera#SetState","Cinemachine.Utility.GaussianWindow1D_CameraRotation#ctor","Cinemachine.Utility.GaussianWindow1D_CameraRotation#Compute","Cinemachine.Utility.GaussianWindow1D_Quaternion#ctor","Cinemachine.Utility.GaussianWindow1D_Quaternion#Compute","Cinemachine.Utility.GaussianWindow1D_Vector3#ctor","Cinemachine.Utility.GaussianWindow1D_Vector3#Compute","CinemachineCameraOffset#init","CinemachineCameraOffset#PostPipelineStageCallback","Cinemachine.CinemachineBlendListCamera#Description#get","Cinemachine.CinemachineBlendListCamera#State#get","Cinemachine.CinemachineBlendListCamera#LookAt#get","Cinemachine.CinemachineBlendListCamera#LookAt#set","Cinemachine.CinemachineBlendListCamera#Follow#get","Cinemachine.CinemachineBlendListCamera#Follow#set","Cinemachine.CinemachineBlendListCamera#ChildCameras#get","Cinemachine.CinemachineBlendListCamera#IsBlending#get","Cinemachine.CinemachineBlendListCamera#init","Cinemachine.CinemachineBlendListCamera#IsLiveChild","Cinemachine.CinemachineBlendListCamera#OnTargetObjectWarped","Cinemachine.CinemachineBlendListCamera#OnTransitionFromCamera","Cinemachine.CinemachineBlendListCamera#InternalUpdateCameraState","Cinemachine.CinemachineBlendListCamera#OnEnable","Cinemachine.CinemachineBlendListCamera#OnDisable","Cinemachine.CinemachineBlendListCamera#OnTransformChildrenChanged","Cinemachine.CinemachineBlendListCamera#OnGuiHandler","Cinemachine.CinemachineBlendListCamera#InvalidateListOfChildren","Cinemachine.CinemachineBlendListCamera#UpdateListOfChildren","Cinemachine.CinemachineBlendListCamera#ValidateInstructions","Cinemachine.CinemachineBlendListCamera#AdvanceCurrentInstruction","Cinemachine.CinemachineClearShot#Description#get","Cinemachine.CinemachineClearShot#State#get","Cinemachine.CinemachineClearShot#LookAt#get","Cinemachine.CinemachineClearShot#LookAt#set","Cinemachine.CinemachineClearShot#Follow#get","Cinemachine.CinemachineClearShot#Follow#set","Cinemachine.CinemachineClearShot#IsBlending#get","Cinemachine.CinemachineClearShot#ChildCameras#get","Cinemachine.CinemachineClearShot#init","Cinemachine.CinemachineClearShot#IsLiveChild","Cinemachine.CinemachineClearShot#OnTargetObjectWarped","Cinemachine.CinemachineClearShot#InternalUpdateCameraState","Cinemachine.CinemachineClearShot#OnEnable","Cinemachine.CinemachineClearShot#OnDisable","Cinemachine.CinemachineClearShot#OnTransformChildrenChanged","Cinemachine.CinemachineClearShot#OnGuiHandler","Cinemachine.CinemachineClearShot#InvalidateListOfChildren","Cinemachine.CinemachineClearShot#ResetRandomization","Cinemachine.CinemachineClearShot#UpdateListOfChildren","Cinemachine.CinemachineClearShot#ChooseCurrentCamera","Cinemachine.CinemachineClearShot#Randomize","Cinemachine.CinemachineClearShot#LookupBlend","Cinemachine.CinemachineClearShot#OnTransitionFromCamera","Cinemachine.CinemachineExternalCamera#State#get","Cinemachine.CinemachineExternalCamera#LookAt#get","Cinemachine.CinemachineExternalCamera#LookAt#set","Cinemachine.CinemachineExternalCamera#init","Cinemachine.CinemachineExternalCamera#InternalUpdateCameraState","Cinemachine.CinemachineFixedSignal#SignalDuration#get","Cinemachine.CinemachineFixedSignal#AxisDuration","Cinemachine.CinemachineFixedSignal#GetSignal","Cinemachine.CinemachineFixedSignal#AxisValue","Cinemachine.CinemachineFreeLook#RigNames#get","Cinemachine.CinemachineFreeLook#PreviousStateIsValid#get","Cinemachine.CinemachineFreeLook#PreviousStateIsValid#set","Cinemachine.CinemachineFreeLook#State#get","Cinemachine.CinemachineFreeLook#LookAt#get","Cinemachine.CinemachineFreeLook#LookAt#set","Cinemachine.CinemachineFreeLook#Follow#get","Cinemachine.CinemachineFreeLook#Follow#set","Cinemachine.CinemachineFreeLook#init","Cinemachine.CinemachineFreeLook#OnValidate","Cinemachine.CinemachineFreeLook#GetRig","Cinemachine.CinemachineFreeLook#OnEnable","Cinemachine.CinemachineFreeLook#OnDestroy","Cinemachine.CinemachineFreeLook#OnTransformChildrenChanged","Cinemachine.CinemachineFreeLook#Reset","Cinemachine.CinemachineFreeLook#IsLiveChild","Cinemachine.CinemachineFreeLook#OnTargetObjectWarped","Cinemachine.CinemachineFreeLook#InternalUpdateCameraState","Cinemachine.CinemachineFreeLook#OnTransitionFromCamera","Cinemachine.CinemachineFreeLook#GetYAxisClosestValue","Cinemachine.CinemachineFreeLook#InvalidateRigCache","Cinemachine.CinemachineFreeLook#DestroyRigs","Cinemachine.CinemachineFreeLook#CreateRigs","Cinemachine.CinemachineFreeLook#UpdateRigCache","Cinemachine.CinemachineFreeLook#LocateExistingRigs","Cinemachine.CinemachineFreeLook#UpdateXAxisHeading","Cinemachine.CinemachineFreeLook#PushSettingsToRigs","Cinemachine.CinemachineFreeLook#GetYAxisValue","Cinemachine.CinemachineFreeLook#CalculateNewState","Cinemachine.CinemachineFreeLook#GetLocalPositionForCameraFromInput","Cinemachine.CinemachineFreeLook#UpdateCachedSpline","Cinemachine.CinemachineGroupComposer#GetScreenSpaceGroupBoundingBox","Cinemachine.CinemachineGroupComposer#init","Cinemachine.CinemachineGroupComposer#OnValidate","Cinemachine.CinemachineGroupComposer#MutateCameraState","Cinemachine.CinemachineGroupComposer#GetTargetHeight","Cinemachine.CinemachineMixingCamera#init","Cinemachine.CinemachineMixingCamera#State#get","Cinemachine.CinemachineMixingCamera#ChildCameras#get","Cinemachine.CinemachineMixingCamera#init","Cinemachine.CinemachineMixingCamera#GetWeight$1","Cinemachine.CinemachineMixingCamera#GetWeight","Cinemachine.CinemachineMixingCamera#SetWeight$1","Cinemachine.CinemachineMixingCamera#SetWeight","Cinemachine.CinemachineMixingCamera#OnTargetObjectWarped","Cinemachine.CinemachineMixingCamera#OnEnable","Cinemachine.CinemachineMixingCamera#OnTransformChildrenChanged","Cinemachine.CinemachineMixingCamera#OnValidate","Cinemachine.CinemachineMixingCamera#IsLiveChild","Cinemachine.CinemachineMixingCamera#InvalidateListOfChildren","Cinemachine.CinemachineMixingCamera#ValidateListOfChildren","Cinemachine.CinemachineMixingCamera#OnTransitionFromCamera","Cinemachine.CinemachineMixingCamera#InternalUpdateCameraState","Cinemachine.CinemachineOrbitalTransposer#GetFullName","Cinemachine.CinemachineOrbitalTransposer#init","Cinemachine.CinemachineOrbitalTransposer#OnValidate","Cinemachine.CinemachineOrbitalTransposer#UpdateHeading","Cinemachine.CinemachineOrbitalTransposer#UpdateHeading$1","Cinemachine.CinemachineOrbitalTransposer#OnEnable","Cinemachine.CinemachineOrbitalTransposer#OnTargetObjectWarped","Cinemachine.CinemachineOrbitalTransposer#OnTransitionFromCamera","Cinemachine.CinemachineOrbitalTransposer#GetAxisClosestValue","Cinemachine.CinemachineOrbitalTransposer#MutateCameraState","Cinemachine.CinemachineOrbitalTransposer#GetTargetCameraPosition","Cinemachine.CinemachineOrbitalTransposer#GetTargetHeading","Cinemachine.CinemachineStateDrivenCamera#CreateFakeHash","Cinemachine.CinemachineStateDrivenCamera#Description#get","Cinemachine.CinemachineStateDrivenCamera#State#get","Cinemachine.CinemachineStateDrivenCamera#LookAt#get","Cinemachine.CinemachineStateDrivenCamera#LookAt#set","Cinemachine.CinemachineStateDrivenCamera#Follow#get","Cinemachine.CinemachineStateDrivenCamera#Follow#set","Cinemachine.CinemachineStateDrivenCamera#ChildCameras#get","Cinemachine.CinemachineStateDrivenCamera#IsBlending#get","Cinemachine.CinemachineStateDrivenCamera#init","Cinemachine.CinemachineStateDrivenCamera#IsLiveChild","Cinemachine.CinemachineStateDrivenCamera#OnTargetObjectWarped","Cinemachine.CinemachineStateDrivenCamera#OnTransitionFromCamera","Cinemachine.CinemachineStateDrivenCamera#InternalUpdateCameraState","Cinemachine.CinemachineStateDrivenCamera#OnEnable","Cinemachine.CinemachineStateDrivenCamera#OnDisable","Cinemachine.CinemachineStateDrivenCamera#OnTransformChildrenChanged","Cinemachine.CinemachineStateDrivenCamera#OnGuiHandler","Cinemachine.CinemachineStateDrivenCamera#LookupFakeHash","Cinemachine.CinemachineStateDrivenCamera#InvalidateListOfChildren","Cinemachine.CinemachineStateDrivenCamera#UpdateListOfChildren","Cinemachine.CinemachineStateDrivenCamera#ValidateInstructions","Cinemachine.CinemachineStateDrivenCamera#ChooseCurrentCamera","Cinemachine.CinemachineStateDrivenCamera#GetClipHash","Cinemachine.CinemachineStateDrivenCamera#LookupBlend","Cinemachine.CinemachineVirtualCamera#init","Cinemachine.CinemachineVirtualCamera#SetFlagsForHiddenChild","Cinemachine.CinemachineVirtualCamera#State#get","Cinemachine.CinemachineVirtualCamera#LookAt#get","Cinemachine.CinemachineVirtualCamera#LookAt#set","Cinemachine.CinemachineVirtualCamera#Follow#get","Cinemachine.CinemachineVirtualCamera#Follow#set","Cinemachine.CinemachineVirtualCamera#init","Cinemachine.CinemachineVirtualCamera#InternalUpdateCameraState","Cinemachine.CinemachineVirtualCamera#OnEnable","Cinemachine.CinemachineVirtualCamera#OnDestroy","Cinemachine.CinemachineVirtualCamera#OnValidate","Cinemachine.CinemachineVirtualCamera#OnTransformChildrenChanged","Cinemachine.CinemachineVirtualCamera#Reset","Cinemachine.CinemachineVirtualCamera#DestroyPipeline","Cinemachine.CinemachineVirtualCamera#CreatePipeline","Cinemachine.CinemachineVirtualCamera#InvalidateComponentPipeline","Cinemachine.CinemachineVirtualCamera#GetComponentOwner","Cinemachine.CinemachineVirtualCamera#GetComponentPipeline","Cinemachine.CinemachineVirtualCamera#GetCinemachineComponent$1","Cinemachine.CinemachineVirtualCamera#GetCinemachineComponent","Cinemachine.CinemachineVirtualCamera#AddCinemachineComponent","Cinemachine.CinemachineVirtualCamera#DestroyCinemachineComponent","Cinemachine.CinemachineVirtualCamera#UpdateComponentPipeline","Cinemachine.CinemachineVirtualCamera#CalculateNewState","Cinemachine.CinemachineVirtualCamera#AdvancePipelineStage","Cinemachine.CinemachineVirtualCamera#SetStateRawPosition","Cinemachine.CinemachineVirtualCamera#OnTargetObjectWarped","Cinemachine.CinemachineVirtualCamera#OnTransitionFromCamera","Cinemachine.NoiseSettings#GetCombinedFilterResults","Cinemachine.NoiseSettings#SignalDuration#get","Cinemachine.NoiseSettings#init","Cinemachine.NoiseSettings#GetSignal"]' ) ); }
/**
 * @compiler Bridge.NET 17.9.21-luna
 */
Bridge.assembly("Cinemachine", function ($asm, globals) {
    "use strict";

    /*Cinemachine.AxisBase start.*/
    Bridge.define("Cinemachine.AxisBase", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisBase#getDefaultValue", this ); }
 return new Cinemachine.AxisBase(); }
            }
        },
        fields: {
            /**
             * The current value of the axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisBase
             * @type number
             */
            m_Value: 0,
            /**
             * The minimum value for the axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisBase
             * @type number
             */
            m_MinValue: 0,
            /**
             * The maximum value for the axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisBase
             * @type number
             */
            m_MaxValue: 0,
            /**
             * If checked, then the axis will wrap around at the min/max values, forming a loop
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisBase
             * @type boolean
             */
            m_Wrap: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisBase#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.AxisBase.Validate start.*/
            Validate: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisBase#Validate", this ); }

                this.m_MaxValue = Math.max(this.m_MinValue, Math.min(this.m_MaxValue, this.m_MaxValue));
            },
            /*Cinemachine.AxisBase.Validate end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisBase#getHashCode", this ); }

                var h = Bridge.addHash([3638352259, this.m_Value, this.m_MinValue, this.m_MaxValue, this.m_Wrap]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.AxisBase#equals", this ); }

                if (!Bridge.is(o, Cinemachine.AxisBase)) {
                    return false;
                }
                return Bridge.equals(this.m_Value, o.m_Value) && Bridge.equals(this.m_MinValue, o.m_MinValue) && Bridge.equals(this.m_MaxValue, o.m_MaxValue) && Bridge.equals(this.m_Wrap, o.m_Wrap);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.AxisBase#$clone", this ); }

                var s = to || new Cinemachine.AxisBase();
                s.m_Value = this.m_Value;
                s.m_MinValue = this.m_MinValue;
                s.m_MaxValue = this.m_MaxValue;
                s.m_Wrap = this.m_Wrap;
                return s;
            }
        }
    });
    /*Cinemachine.AxisBase end.*/

    /*Cinemachine.AxisState start.*/
    /** @namespace Cinemachine */

    /**
     * Axis state for defining how to react to player input.
         The settings here control the responsiveness of the axis to player input.
     *
     * @public
     * @class Cinemachine.AxisState
     */
    Bridge.define("Cinemachine.AxisState", {
        $kind: "struct",
        statics: {
            fields: {
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#init", this ); }

                    this.Epsilon = 0.0001;
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#getDefaultValue", this ); }
 return new Cinemachine.AxisState(); }
            }
        },
        fields: {
            /**
             * The current value of the axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type number
             */
            Value: 0,
            /**
             * How to interpret the Max Speed setting.
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type number
             */
            m_SpeedMode: 0,
            /**
             * How fast the axis value can travel.  Increasing this number
                 makes the behaviour more responsive to joystick input
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type number
             */
            m_MaxSpeed: 0,
            /**
             * The amount of time in seconds it takes to accelerate to
                 MaxSpeed with the supplied Axis at its maximum value
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type number
             */
            m_AccelTime: 0,
            /**
             * The amount of time in seconds it takes to decelerate
                 the axis to zero if the supplied axis is in a neutral position
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type number
             */
            m_DecelTime: 0,
            /**
             * The name of this axis as specified in Unity Input manager.
                 Setting to an empty string will disable the automatic updating of this axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type string
             */
            m_InputAxisName: null,
            /**
             * The value of the input axis.  A value of 0 means no input
                 You can drive this directly from a
                 custom input system, or you can set the Axis Name and have the value
                 driven by the internal Input Manager
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type number
             */
            m_InputAxisValue: 0,
            /**
             * If checked, then the raw value of the input axis will be inverted
                 before it is used.
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type boolean
             */
            m_InvertInput: false,
            /**
             * The minimum value for the axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type number
             */
            m_MinValue: 0,
            /**
             * The maximum value for the axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type number
             */
            m_MaxValue: 0,
            /**
             * If checked, then the axis will wrap around at the min/max values, forming a loop
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type boolean
             */
            m_Wrap: false,
            /**
             * Automatic recentering.  Valid only if HasRecentering is true
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @type Cinemachine.AxisState.Recentering
             */
            m_Recentering: null,
            mCurrentSpeed: 0,
            /**
             * Value range is locked, i.e. not adjustable by the user (used by editor)
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @function ValueRangeLocked
             * @type boolean
             */
            ValueRangeLocked: false,
            /**
             * True if the Recentering member is valid (bcak-compatibility support:
                 old versions had recentering in a separate structure)
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState
             * @function HasRecentering
             * @type boolean
             */
            HasRecentering: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#init", this ); }

                this.m_Recentering = new Cinemachine.AxisState.Recentering();
            },
            /**
             * Constructor with specific values
             *
             * @instance
             * @public
             * @this Cinemachine.AxisState
             * @memberof Cinemachine.AxisState
             * @param   {number}     minValue       
             * @param   {number}     maxValue       
             * @param   {boolean}    wrap           
             * @param   {boolean}    rangeLocked    
             * @param   {number}     maxSpeed       
             * @param   {number}     accelTime      
             * @param   {number}     decelTime      
             * @param   {string}     name           
             * @param   {boolean}    invert
             * @return  {void}
             */
            $ctor1: function (minValue, maxValue, wrap, rangeLocked, maxSpeed, accelTime, decelTime, name, invert) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#$ctor1", this ); }

                this.$initialize();
                this.m_MinValue = minValue;
                this.m_MaxValue = maxValue;
                this.m_Wrap = wrap;
                this.ValueRangeLocked = rangeLocked;

                this.HasRecentering = false;
                this.m_Recentering = new Cinemachine.AxisState.Recentering.$ctor1(false, 1, 2);

                this.m_SpeedMode = Cinemachine.AxisState.SpeedMode.MaxSpeed;
                this.m_MaxSpeed = maxSpeed;
                this.m_AccelTime = accelTime;
                this.m_DecelTime = decelTime;
                this.Value = (minValue + maxValue) / 2;
                this.m_InputAxisName = name;
                this.m_InputAxisValue = 0;
                this.m_InvertInput = invert;

                this.mCurrentSpeed = 0.0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.AxisState.Validate start.*/
            /**
             * Call from OnValidate: Make sure the fields are sensible
             *
             * @instance
             * @public
             * @this Cinemachine.AxisState
             * @memberof Cinemachine.AxisState
             * @return  {void}
             */
            Validate: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#Validate", this ); }

                if (this.m_SpeedMode === Cinemachine.AxisState.SpeedMode.MaxSpeed) {
                    this.m_MaxSpeed = UnityEngine.Mathf.Max(0, this.m_MaxSpeed);
                }

                this.m_AccelTime = UnityEngine.Mathf.Max(0, this.m_AccelTime);
                this.m_DecelTime = UnityEngine.Mathf.Max(0, this.m_DecelTime);
                this.m_MaxValue = Math.max(this.m_MinValue, Math.min(this.m_MaxValue, this.m_MaxValue));
            },
            /*Cinemachine.AxisState.Validate end.*/

            /*Cinemachine.AxisState.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#Reset", this ); }

                this.m_InputAxisValue = 0;
                this.mCurrentSpeed = 0;
            },
            /*Cinemachine.AxisState.Reset end.*/

            /*Cinemachine.AxisState.Update start.*/
            /**
             * Updates the state of this axis based on the axis defined
                 by AxisState.m_AxisName
             *
             * @instance
             * @public
             * @this Cinemachine.AxisState
             * @memberof Cinemachine.AxisState
             * @param   {number}     deltaTime    Delta time in seconds
             * @return  {boolean}                 Returns <b>true</b> if this axis' input was non-zero this Update,
                 <b>false</b> otherwise
             */
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#Update", this ); }

                if (!System.String.isNullOrEmpty(this.m_InputAxisName)) {
                    try {
                        this.m_InputAxisValue = Cinemachine.CinemachineCore.GetInputAxis(this.m_InputAxisName);
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        var e;
                        if (Bridge.is($e1, System.ArgumentException)) {
                            e = $e1;
                            UnityEngine.Debug.LogError$2(Bridge.toString(e));
                        } else {
                            throw $e1;
                        }
                    }
                }

                var input = this.m_InputAxisValue;
                if (this.m_InvertInput) {
                    input *= -1.0;
                }

                if (this.m_SpeedMode === Cinemachine.AxisState.SpeedMode.MaxSpeed) {
                    return this.MaxSpeedUpdate(input, deltaTime); // legacy mode
                }

                // Direct mode update: maxSpeed interpreted as multiplier
                input *= this.m_MaxSpeed;
                if (deltaTime < Cinemachine.AxisState.Epsilon) {
                    this.mCurrentSpeed = 0;
                } else {
                    var speed = input / deltaTime;
                    var dampTime = Math.abs(speed) < Math.abs(this.mCurrentSpeed) ? this.m_DecelTime : this.m_AccelTime;
                    speed = this.mCurrentSpeed + Cinemachine.Utility.Damper.Damp(speed - this.mCurrentSpeed, dampTime, deltaTime);
                    this.mCurrentSpeed = speed;

                    // Decelerate to the end points of the range if not wrapping
                    var range = this.m_MaxValue - this.m_MinValue;
                    if (!this.m_Wrap && this.m_DecelTime > Cinemachine.AxisState.Epsilon && range > Cinemachine.AxisState.Epsilon) {
                        var v0 = this.ClampValue(this.Value);
                        var v = this.ClampValue(v0 + speed * deltaTime);
                        var d = speed > 0 ? this.m_MaxValue - v : v - this.m_MinValue;
                        if (d < 0.1 * range && Math.abs(speed) > Cinemachine.AxisState.Epsilon) {
                            speed = Cinemachine.Utility.Damper.Damp(v - v0, this.m_DecelTime, deltaTime) / deltaTime;
                        }
                    }

                    input = speed * deltaTime;
                }

                this.Value = this.ClampValue(this.Value + input);
                return Math.abs(input) > Cinemachine.AxisState.Epsilon;
            },
            /*Cinemachine.AxisState.Update end.*/

            /*Cinemachine.AxisState.ClampValue start.*/
            ClampValue: function (v) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#ClampValue", this ); }

                var r = this.m_MaxValue - this.m_MinValue;
                if (this.m_Wrap && r > Cinemachine.AxisState.Epsilon) {
                    v = (v - this.m_MinValue) % r;
                    v += this.m_MinValue + (v < 0 ? r : 0);
                }

                return Math.max(this.m_MinValue, Math.min(v, this.m_MaxValue));
            },
            /*Cinemachine.AxisState.ClampValue end.*/

            /*Cinemachine.AxisState.MaxSpeedUpdate start.*/
            MaxSpeedUpdate: function (input, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#MaxSpeedUpdate", this ); }

                if (this.m_MaxSpeed > Cinemachine.AxisState.Epsilon) {
                    var targetSpeed = input * this.m_MaxSpeed;
                    if (Math.abs(targetSpeed) < Cinemachine.AxisState.Epsilon || (this.mCurrentSpeed === 0 ? 1 : Math.sign(this.mCurrentSpeed)) === (targetSpeed === 0 ? 1 : Math.sign(targetSpeed)) && Math.abs(targetSpeed) < Math.abs(this.mCurrentSpeed)) {
                        // Need to decelerate
                        var a = Math.abs(targetSpeed - this.mCurrentSpeed) / UnityEngine.Mathf.Max(Cinemachine.AxisState.Epsilon, this.m_DecelTime);
                        var delta = UnityEngine.Mathf.Min(a * deltaTime, Math.abs(this.mCurrentSpeed));
                        this.mCurrentSpeed -= (this.mCurrentSpeed === 0 ? 1 : Math.sign(this.mCurrentSpeed)) * delta;
                    } else {
                        // Accelerate to the target speed
                        var a1 = Math.abs(targetSpeed - this.mCurrentSpeed) / UnityEngine.Mathf.Max(Cinemachine.AxisState.Epsilon, this.m_AccelTime);
                        this.mCurrentSpeed += (targetSpeed === 0 ? 1 : Math.sign(targetSpeed)) * a1 * deltaTime;
                        if ((this.mCurrentSpeed === 0 ? 1 : Math.sign(this.mCurrentSpeed)) === (targetSpeed === 0 ? 1 : Math.sign(targetSpeed)) && Math.abs(this.mCurrentSpeed) > Math.abs(targetSpeed)) {
                            this.mCurrentSpeed = targetSpeed;
                        }
                    }
                }

                // Clamp our max speeds so we don't go crazy
                var maxSpeed = this.GetMaxSpeed();
                this.mCurrentSpeed = Math.max(-maxSpeed, Math.min(this.mCurrentSpeed, maxSpeed));

                this.Value += this.mCurrentSpeed * deltaTime;
                var isOutOfRange = this.Value > this.m_MaxValue || this.Value < this.m_MinValue;
                if (isOutOfRange) {
                    if (this.m_Wrap) {
                        if (this.Value > this.m_MaxValue) {
                            this.Value = this.m_MinValue + (this.Value - this.m_MaxValue);
                        } else {
                            this.Value = this.m_MaxValue + (this.Value - this.m_MinValue);
                        }
                    } else {
                        this.Value = Math.max(this.m_MinValue, Math.min(this.Value, this.m_MaxValue));
                        this.mCurrentSpeed = 0.0;
                    }
                }

                return Math.abs(input) > Cinemachine.AxisState.Epsilon;
            },
            /*Cinemachine.AxisState.MaxSpeedUpdate end.*/

            /*Cinemachine.AxisState.GetMaxSpeed start.*/
            GetMaxSpeed: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#GetMaxSpeed", this ); }

                var range = this.m_MaxValue - this.m_MinValue;
                if (!this.m_Wrap && range > 0) {
                    var threshold = range / 10.0;
                    if (this.mCurrentSpeed > 0 && this.m_MaxValue - this.Value < threshold) {
                        var t = (this.m_MaxValue - this.Value) / threshold;
                        return pc.math.lerp(0, this.m_MaxSpeed, t);
                    }

                    if (this.mCurrentSpeed < 0 && this.Value - this.m_MinValue < threshold) {
                        var t1 = (this.Value - this.m_MinValue) / threshold;
                        return pc.math.lerp(0, this.m_MaxSpeed, t1);
                    }
                }

                return this.m_MaxSpeed;
            },
            /*Cinemachine.AxisState.GetMaxSpeed end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#getHashCode", this ); }

                var h = Bridge.addHash([3888835833, this.Value, this.m_SpeedMode, this.m_MaxSpeed, this.m_AccelTime, this.m_DecelTime, this.m_InputAxisName, this.m_InputAxisValue, this.m_InvertInput, this.m_MinValue, this.m_MaxValue, this.m_Wrap, this.m_Recentering, this.mCurrentSpeed, this.ValueRangeLocked, this.HasRecentering]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#equals", this ); }

                if (!Bridge.is(o, Cinemachine.AxisState)) {
                    return false;
                }
                return Bridge.equals(this.Value, o.Value) && Bridge.equals(this.m_SpeedMode, o.m_SpeedMode) && Bridge.equals(this.m_MaxSpeed, o.m_MaxSpeed) && Bridge.equals(this.m_AccelTime, o.m_AccelTime) && Bridge.equals(this.m_DecelTime, o.m_DecelTime) && Bridge.equals(this.m_InputAxisName, o.m_InputAxisName) && Bridge.equals(this.m_InputAxisValue, o.m_InputAxisValue) && Bridge.equals(this.m_InvertInput, o.m_InvertInput) && Bridge.equals(this.m_MinValue, o.m_MinValue) && Bridge.equals(this.m_MaxValue, o.m_MaxValue) && Bridge.equals(this.m_Wrap, o.m_Wrap) && Bridge.equals(this.m_Recentering, o.m_Recentering) && Bridge.equals(this.mCurrentSpeed, o.mCurrentSpeed) && Bridge.equals(this.ValueRangeLocked, o.ValueRangeLocked) && Bridge.equals(this.HasRecentering, o.HasRecentering);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState#$clone", this ); }

                var s = to || new Cinemachine.AxisState();
                s.Value = this.Value;
                s.m_SpeedMode = this.m_SpeedMode;
                s.m_MaxSpeed = this.m_MaxSpeed;
                s.m_AccelTime = this.m_AccelTime;
                s.m_DecelTime = this.m_DecelTime;
                s.m_InputAxisName = this.m_InputAxisName;
                s.m_InputAxisValue = this.m_InputAxisValue;
                s.m_InvertInput = this.m_InvertInput;
                s.m_MinValue = this.m_MinValue;
                s.m_MaxValue = this.m_MaxValue;
                s.m_Wrap = this.m_Wrap;
                s.m_Recentering = this.m_Recentering.$clone();
                s.mCurrentSpeed = this.mCurrentSpeed;
                s.ValueRangeLocked = this.ValueRangeLocked;
                s.HasRecentering = this.HasRecentering;
                return s;
            }
        }
    });
    /*Cinemachine.AxisState end.*/

    /*Cinemachine.AxisState+Recentering start.*/
    /**
     * Helper for automatic axis recentering
     *
     * @public
     * @class Cinemachine.AxisState.Recentering
     */
    Bridge.define("Cinemachine.AxisState.Recentering", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#getDefaultValue", this ); }
 return new Cinemachine.AxisState.Recentering(); }
            }
        },
        fields: {
            /**
             * If checked, will enable automatic recentering of the
                 axis. If FALSE, recenting is disabled.
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState.Recentering
             * @type boolean
             */
            m_enabled: false,
            /**
             * If no input has been detected, the camera will wait
                 this long in seconds before moving its heading to the default heading.
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState.Recentering
             * @type number
             */
            m_WaitTime: 0,
            /**
             * How long it takes to reach destination once recentering has started
             *
             * @instance
             * @public
             * @memberof Cinemachine.AxisState.Recentering
             * @type number
             */
            m_RecenteringTime: 0,
            mLastAxisInputTime: 0,
            mRecenteringVelocity: 0,
            m_LegacyHeadingDefinition: 0,
            m_LegacyVelocityFilterStrength: 0
        },
        ctors: {
            /**
             * Constructor with specific field values
             *
             * @instance
             * @public
             * @this Cinemachine.AxisState.Recentering
             * @memberof Cinemachine.AxisState.Recentering
             * @param   {boolean}    enabled            
             * @param   {number}     waitTime           
             * @param   {number}     recenteringTime
             * @return  {void}
             */
            $ctor1: function (enabled, waitTime, recenteringTime) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#$ctor1", this ); }

                this.$initialize();
                this.m_enabled = enabled;
                this.m_WaitTime = waitTime;
                this.m_RecenteringTime = recenteringTime;
                this.mLastAxisInputTime = 0;
                this.mRecenteringVelocity = 0;
                this.m_LegacyHeadingDefinition = (this.m_LegacyVelocityFilterStrength = -1);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.AxisState+Recentering.Validate start.*/
            /**
             * Call this from OnValidate()
             *
             * @instance
             * @public
             * @this Cinemachine.AxisState.Recentering
             * @memberof Cinemachine.AxisState.Recentering
             * @return  {void}
             */
            Validate: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#Validate", this ); }

                this.m_WaitTime = UnityEngine.Mathf.Max(0, this.m_WaitTime);
                this.m_RecenteringTime = UnityEngine.Mathf.Max(0, this.m_RecenteringTime);
            },
            /*Cinemachine.AxisState+Recentering.Validate end.*/

            /*Cinemachine.AxisState+Recentering.CopyStateFrom start.*/
            CopyStateFrom: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#CopyStateFrom", this ); }

                if (this.mLastAxisInputTime !== other.v.mLastAxisInputTime) {
                    other.v.mRecenteringVelocity = 0;
                }

                this.mLastAxisInputTime = other.v.mLastAxisInputTime;
            },
            /*Cinemachine.AxisState+Recentering.CopyStateFrom end.*/

            /*Cinemachine.AxisState+Recentering.CancelRecentering start.*/
            /**
             * Cancel any recenetering in progress.
             *
             * @instance
             * @public
             * @this Cinemachine.AxisState.Recentering
             * @memberof Cinemachine.AxisState.Recentering
             * @return  {void}
             */
            CancelRecentering: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#CancelRecentering", this ); }

                this.mLastAxisInputTime = UnityEngine.Time.time;
                this.mRecenteringVelocity = 0;
            },
            /*Cinemachine.AxisState+Recentering.CancelRecentering end.*/

            /*Cinemachine.AxisState+Recentering.RecenterNow start.*/
            /**
             * Skip the wait time and start recentering now (only if enabled).
             *
             * @instance
             * @public
             * @this Cinemachine.AxisState.Recentering
             * @memberof Cinemachine.AxisState.Recentering
             * @return  {void}
             */
            RecenterNow: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#RecenterNow", this ); }

                this.mLastAxisInputTime = 0;
            },
            /*Cinemachine.AxisState+Recentering.RecenterNow end.*/

            /*Cinemachine.AxisState+Recentering.DoRecentering start.*/
            /**
             * Bring the axis back to the centered state (only if enabled).
             *
             * @instance
             * @public
             * @this Cinemachine.AxisState.Recentering
             * @memberof Cinemachine.AxisState.Recentering
             * @param   {Cinemachine.AxisState}    axis              
             * @param   {number}                   deltaTime         
             * @param   {number}                   recenterTarget
             * @return  {void}
             */
            DoRecentering: function (axis, deltaTime, recenterTarget) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#DoRecentering", this ); }

                var $t;
                if (!this.m_enabled && deltaTime >= 0) {
                    return;
                }

                recenterTarget = axis.v.ClampValue(recenterTarget);
                if (deltaTime < 0) {
                    this.CancelRecentering();
                    axis.v.Value = recenterTarget;
                    return;
                }

                var v = axis.v.ClampValue(axis.v.Value);
                var delta = recenterTarget - v;
                if (delta === 0) {
                    return;
                }

                if (UnityEngine.Time.time < this.mLastAxisInputTime + this.m_WaitTime) {
                    return;
                }

                // Determine the direction
                var r = axis.v.m_MaxValue - axis.v.m_MinValue;
                if (axis.v.m_Wrap && Math.abs(delta) > r * 0.5) {
                    v += ($t = recenterTarget - v, ($t === 0 ? 1 : Math.sign($t))) * r;
                }

                // Damp our way there
                if (this.m_RecenteringTime < 0.001) {
                    v = recenterTarget;
                } else {
                    v = UnityEngine.Mathf.SmoothDamp$1(v, recenterTarget, Bridge.ref(this, "mRecenteringVelocity"), this.m_RecenteringTime, 9999, deltaTime);
                }

                axis.v.Value = axis.v.ClampValue(v);
            },
            /*Cinemachine.AxisState+Recentering.DoRecentering end.*/

            /*Cinemachine.AxisState+Recentering.LegacyUpgrade start.*/
            LegacyUpgrade: function (heading, velocityFilter) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#LegacyUpgrade", this ); }

                if (this.m_LegacyHeadingDefinition !== -1 && this.m_LegacyVelocityFilterStrength !== -1) {
                    heading.v = this.m_LegacyHeadingDefinition;
                    velocityFilter.v = this.m_LegacyVelocityFilterStrength;
                    this.m_LegacyHeadingDefinition = (this.m_LegacyVelocityFilterStrength = -1);
                    return true;
                }

                return false;
            },
            /*Cinemachine.AxisState+Recentering.LegacyUpgrade end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#getHashCode", this ); }

                var h = Bridge.addHash([3627042857, this.m_enabled, this.m_WaitTime, this.m_RecenteringTime, this.mLastAxisInputTime, this.mRecenteringVelocity, this.m_LegacyHeadingDefinition, this.m_LegacyVelocityFilterStrength]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#equals", this ); }

                if (!Bridge.is(o, Cinemachine.AxisState.Recentering)) {
                    return false;
                }
                return Bridge.equals(this.m_enabled, o.m_enabled) && Bridge.equals(this.m_WaitTime, o.m_WaitTime) && Bridge.equals(this.m_RecenteringTime, o.m_RecenteringTime) && Bridge.equals(this.mLastAxisInputTime, o.mLastAxisInputTime) && Bridge.equals(this.mRecenteringVelocity, o.mRecenteringVelocity) && Bridge.equals(this.m_LegacyHeadingDefinition, o.m_LegacyHeadingDefinition) && Bridge.equals(this.m_LegacyVelocityFilterStrength, o.m_LegacyVelocityFilterStrength);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.AxisState.Recentering#$clone", this ); }

                var s = to || new Cinemachine.AxisState.Recentering();
                s.m_enabled = this.m_enabled;
                s.m_WaitTime = this.m_WaitTime;
                s.m_RecenteringTime = this.m_RecenteringTime;
                s.mLastAxisInputTime = this.mLastAxisInputTime;
                s.mRecenteringVelocity = this.mRecenteringVelocity;
                s.m_LegacyHeadingDefinition = this.m_LegacyHeadingDefinition;
                s.m_LegacyVelocityFilterStrength = this.m_LegacyVelocityFilterStrength;
                return s;
            }
        }
    });
    /*Cinemachine.AxisState+Recentering end.*/

    /*Cinemachine.AxisState+SpeedMode start.*/
    /**
     * How to interpret the Max Speed setting.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.AxisState.SpeedMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * The Max Speed setting will be interpreted as a maximum axis speed, in units/second
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                MaxSpeed: 0,
                /**
                 * The Max Speed setting will be interpreted as a direct multiplier on the input value
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                InputValueGain: 1
            }
        }
    });
    /*Cinemachine.AxisState+SpeedMode end.*/

    /*Cinemachine.AxisStatePropertyAttribute start.*/
    /**
     * Property applied to AxisState.  Used for custom drawing in the inspector.
     *
     * @public
     * @class Cinemachine.AxisStatePropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.AxisStatePropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.AxisStatePropertyAttribute end.*/

    /*Cinemachine.ICinemachineCamera start.*/
    /**
     * An abstract representation of a virtual camera which lives within the Unity scene
     *
     * @abstract
     * @public
     * @class Cinemachine.ICinemachineCamera
     */
    Bridge.define("Cinemachine.ICinemachineCamera", {
        $kind: "interface"
    });
    /*Cinemachine.ICinemachineCamera end.*/

    /*Cinemachine.CameraState start.*/
    /**
     * The output of the Cinemachine engine for a specific virtual camera.  The information
         in this struct can be blended, and provides what is needed to calculate an
         appropriate camera position, orientation, and lens setting.
         Raw values are what the Cinemachine behaviours generate.  The correction channel
         holds perturbations to the raw values - e.g. noise or smoothing, or obstacle
         avoidance corrections.  Coirrections are not considered when making time-based
         calculations such as damping.
         The Final position and orientation is the comination of the raw values and
         their corrections.
     *
     * @public
     * @class Cinemachine.CameraState
     */
    Bridge.define("Cinemachine.CameraState", {
        $kind: "struct",
        statics: {
            fields: {
                /**
                 * This constant represents "no point in space" or "no direction".
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CameraState
                 * @type UnityEngine.Vector3
                 */
                kNoPoint: null
            },
            props: {
                /**
                 * State with default values
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Cinemachine.CameraState
                 * @function Default
                 * @type Cinemachine.CameraState
                 */
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#Default#get", this ); }

                        var state = new Cinemachine.CameraState();
                        state.Lens = Cinemachine.LensSettings.Default.$clone();
                        state.ReferenceUp = pc.Vec3.UP.clone();
                        state.ReferenceLookAt = Cinemachine.CameraState.kNoPoint.$clone();
                        state.RawPosition = pc.Vec3.ZERO.clone();
                        state.RawOrientation = pc.Quat.IDENTITY.clone();
                        state.ShotQuality = 1;
                        state.PositionCorrection = pc.Vec3.ZERO.clone();
                        state.OrientationCorrection = pc.Quat.IDENTITY.clone();
                        state.PositionDampingBypass = pc.Vec3.ZERO.clone();
                        state.BlendHint = Cinemachine.CameraState.BlendHintValue.Nothing;
                        return state.$clone();
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#init", this ); }

                    this.kNoPoint = new UnityEngine.Vector3();
                    this.kNoPoint = new pc.Vec3( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );
                }
            },
            methods: {
                /*Cinemachine.CameraState.Lerp:static start.*/
                /**
                 * Intelligently blend the contents of two states.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.CameraState
                 * @memberof Cinemachine.CameraState
                 * @param   {Cinemachine.CameraState}    stateA    The first state, corresponding to t=0
                 * @param   {Cinemachine.CameraState}    stateB    The second state, corresponding to t=1
                 * @param   {number}                     t         How much to interpolate.  Internally clamped to 0..1
                 * @return  {Cinemachine.CameraState}              Linearly interpolated CameraState
                 */
                Lerp: function (stateA, stateB, t) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#Lerp", this ); }

                    t = Math.max(0, Math.min(1, t));
                    var adjustedT = t;

                    var state = new Cinemachine.CameraState();

                    // Combine the blend hints intelligently
                    if ((stateA.BlendHint & stateB.BlendHint & Cinemachine.CameraState.BlendHintValue.NoPosition) !== 0) {
                        state.BlendHint |= Cinemachine.CameraState.BlendHintValue.NoPosition;
                    }

                    if ((stateA.BlendHint & stateB.BlendHint & Cinemachine.CameraState.BlendHintValue.NoOrientation) !== 0) {
                        state.BlendHint |= Cinemachine.CameraState.BlendHintValue.NoOrientation;
                    }

                    if ((stateA.BlendHint & stateB.BlendHint & Cinemachine.CameraState.BlendHintValue.NoLens) !== 0) {
                        state.BlendHint |= Cinemachine.CameraState.BlendHintValue.NoLens;
                    }

                    if (((stateA.BlendHint | stateB.BlendHint) & Cinemachine.CameraState.BlendHintValue.SphericalPositionBlend) !== 0) {
                        state.BlendHint |= Cinemachine.CameraState.BlendHintValue.SphericalPositionBlend;
                    }

                    if (((stateA.BlendHint | stateB.BlendHint) & Cinemachine.CameraState.BlendHintValue.CylindricalPositionBlend) !== 0) {
                        state.BlendHint |= Cinemachine.CameraState.BlendHintValue.CylindricalPositionBlend;
                    }

                    if (((stateA.BlendHint | stateB.BlendHint) & Cinemachine.CameraState.BlendHintValue.NoLens) === 0) {
                        state.Lens = Cinemachine.LensSettings.Lerp(stateA.Lens.$clone(), stateB.Lens.$clone(), t);
                    } else if ((stateA.BlendHint & stateB.BlendHint & Cinemachine.CameraState.BlendHintValue.NoLens) === 0) {
                        if ((stateA.BlendHint & Cinemachine.CameraState.BlendHintValue.NoLens) !== 0) {
                            state.Lens = stateB.Lens.$clone();
                        } else {
                            state.Lens = stateA.Lens.$clone();
                        }
                    }

                    state.ReferenceUp = new pc.Vec3().slerp( stateA.ReferenceUp, stateB.ReferenceUp, t );
                    state.ShotQuality = pc.math.lerp(stateA.ShotQuality, stateB.ShotQuality, t);

                    state.PositionCorrection = Cinemachine.CameraState.ApplyPosBlendHint(stateA.PositionCorrection.$clone(), stateA.BlendHint, stateB.PositionCorrection.$clone(), stateB.BlendHint, state.PositionCorrection.$clone(), new pc.Vec3().lerp( stateA.PositionCorrection, stateB.PositionCorrection, t ));

                    state.OrientationCorrection = Cinemachine.CameraState.ApplyRotBlendHint(stateA.OrientationCorrection.$clone(), stateA.BlendHint, stateB.OrientationCorrection.$clone(), stateB.BlendHint, state.OrientationCorrection.$clone(), new pc.Quat().slerp( stateA.OrientationCorrection, stateB.OrientationCorrection, t ));

                    // LookAt target
                    if (!stateA.HasLookAt || !stateB.HasLookAt) {
                        state.ReferenceLookAt = Cinemachine.CameraState.kNoPoint.$clone();
                    } else {
                        // Re-interpolate FOV to preserve target composition, if possible
                        var fovA = stateA.Lens.FieldOfView;
                        var fovB = stateB.Lens.FieldOfView;
                        if (((stateA.BlendHint | stateB.BlendHint) & Cinemachine.CameraState.BlendHintValue.NoLens) === 0 && !state.Lens.Orthographic && !UnityEngine.Mathf.Approximately(fovA, fovB)) {
                            var lens = state.Lens.$clone();
                            lens.FieldOfView = Cinemachine.CameraState.InterpolateFOV(fovA, fovB, UnityEngine.Mathf.Max((stateA.ReferenceLookAt.$clone().sub( stateA.CorrectedPosition )).length(), stateA.Lens.NearClipPlane), UnityEngine.Mathf.Max((stateB.ReferenceLookAt.$clone().sub( stateB.CorrectedPosition )).length(), stateB.Lens.NearClipPlane), t);
                            state.Lens = lens.$clone();

                            // Make sure we preserve the screen composition through FOV changes
                            adjustedT = Math.abs((lens.FieldOfView - fovA) / (fovB - fovA));
                        }

                        // Linear interpolation of lookAt target point
                        state.ReferenceLookAt = new pc.Vec3().lerp( stateA.ReferenceLookAt, stateB.ReferenceLookAt, adjustedT );
                    }

                    // Raw position
                    state.RawPosition = Cinemachine.CameraState.ApplyPosBlendHint(stateA.RawPosition.$clone(), stateA.BlendHint, stateB.RawPosition.$clone(), stateB.BlendHint, state.RawPosition.$clone(), state.InterpolatePosition(stateA.RawPosition.$clone(), stateA.ReferenceLookAt.$clone(), stateB.RawPosition.$clone(), stateB.ReferenceLookAt.$clone(), t));

                    // Interpolate the LookAt in Screen Space if requested
                    if (state.HasLookAt && ((stateA.BlendHint | stateB.BlendHint) & Cinemachine.CameraState.BlendHintValue.RadialAimBlend) !== 0) {
                        state.ReferenceLookAt = state.RawPosition.$clone().add( new pc.Vec3().slerp( stateA.ReferenceLookAt.$clone().sub( state.RawPosition ), stateB.ReferenceLookAt.$clone().sub( state.RawPosition ), adjustedT ) );
                    }

                    // Clever orientation interpolation
                    var newOrient = state.RawOrientation.$clone();
                    if (((stateA.BlendHint | stateB.BlendHint) & Cinemachine.CameraState.BlendHintValue.NoOrientation) === 0) {
                        var dirTarget = pc.Vec3.ZERO.clone();
                        if (state.HasLookAt) {
                            // If orientations are different, use LookAt to blend them
                            var angle = pc.Quat.angle( stateA.RawOrientation.$clone(), stateB.RawOrientation.$clone() );
                            if (angle > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                                dirTarget = state.ReferenceLookAt.$clone().sub( state.CorrectedPosition );
                            }
                        }

                        if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(dirTarget) || ((stateA.BlendHint | stateB.BlendHint) & Cinemachine.CameraState.BlendHintValue.IgnoreLookAtTarget) !== 0) {
                            // Don't know what we're looking at - can only slerp
                            newOrient = Cinemachine.Utility.UnityQuaternionExtensions.SlerpWithReferenceUp(stateA.RawOrientation.$clone(), stateB.RawOrientation.$clone(), t, state.ReferenceUp.$clone());
                        } else {
                            // Rotate while preserving our lookAt target
                            dirTarget = dirTarget.clone().normalize().$clone();
                            if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero((dirTarget.$clone().sub( state.ReferenceUp ))) || Cinemachine.Utility.UnityVectorExtensions.AlmostZero((dirTarget.$clone().add( state.ReferenceUp )))) {
                                // Looking up or down at the pole
                                newOrient = Cinemachine.Utility.UnityQuaternionExtensions.SlerpWithReferenceUp(stateA.RawOrientation.$clone(), stateB.RawOrientation.$clone(), t, state.ReferenceUp.$clone());
                            } else {
                                // Put the target in the center
                                newOrient = new pc.Quat().setLookAt( dirTarget, state.ReferenceUp );

                                // Blend the desired offsets from center
                                var deltaA = Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget(stateA.RawOrientation, stateA.ReferenceLookAt.$clone().sub( stateA.CorrectedPosition ), stateA.ReferenceUp.$clone()).scale( -1 );
                                var deltaB = Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget(stateB.RawOrientation, stateB.ReferenceLookAt.$clone().sub( stateB.CorrectedPosition ), stateB.ReferenceUp.$clone()).scale( -1 );
                                newOrient = Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation(newOrient, new pc.Vec2().lerp( deltaA, deltaB, adjustedT ), state.ReferenceUp.$clone());
                            }
                        }
                    }

                    state.RawOrientation = Cinemachine.CameraState.ApplyRotBlendHint(stateA.RawOrientation.$clone(), stateA.BlendHint, stateB.RawOrientation.$clone(), stateB.BlendHint, state.RawOrientation.$clone(), newOrient.$clone());

                    // Accumulate the custom blendables and apply the weights
                    for (var i = 0; i < stateA.NumCustomBlendables; ++i) {
                        var b = stateA.GetCustomBlendable(i);
                        b.m_Weight *= 1 - t;
                        if (b.m_Weight > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                            state.AddCustomBlendable(b.$clone());
                        }
                    }

                    for (var i1 = 0; i1 < stateB.NumCustomBlendables; ++i1) {
                        var b1 = stateB.GetCustomBlendable(i1);
                        b1.m_Weight *= t;
                        if (b1.m_Weight > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                            state.AddCustomBlendable(b1.$clone());
                        }
                    }

                    return state.$clone();
                },
                /*Cinemachine.CameraState.Lerp:static end.*/

                /*Cinemachine.CameraState.InterpolateFOV:static start.*/
                InterpolateFOV: function (fovA, fovB, dA, dB, t) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#InterpolateFOV", this ); }

                    // We interpolate shot height
                    var hA = dA * 2.0 * Math.tan(fovA * UnityEngine.Mathf.Deg2Rad / 2.0);
                    var hB = dB * 2.0 * Math.tan(fovB * UnityEngine.Mathf.Deg2Rad / 2.0);
                    var h = pc.math.lerp(hA, hB, t);
                    var fov = 179.0;
                    var d = pc.math.lerp(dA, dB, t);
                    if (d > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        fov = 2.0 * Math.atan(h / (2 * d)) * UnityEngine.Mathf.Rad2Deg;
                    }

                    return Math.max(UnityEngine.Mathf.Min(fovA, fovB), Math.min(fov, UnityEngine.Mathf.Max(fovA, fovB)));
                },
                /*Cinemachine.CameraState.InterpolateFOV:static end.*/

                /*Cinemachine.CameraState.ApplyPosBlendHint:static start.*/
                ApplyPosBlendHint: function (posA, hintA, posB, hintB, original, blended) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#ApplyPosBlendHint", this ); }

                    if (((hintA | hintB) & Cinemachine.CameraState.BlendHintValue.NoPosition) === 0) {
                        return blended.$clone();
                    }

                    if ((hintA & hintB & Cinemachine.CameraState.BlendHintValue.NoPosition) !== 0) {
                        return original.$clone();
                    }

                    if ((hintA & Cinemachine.CameraState.BlendHintValue.NoPosition) !== 0) {
                        return posB.$clone();
                    }

                    return posA.$clone();
                },
                /*Cinemachine.CameraState.ApplyPosBlendHint:static end.*/

                /*Cinemachine.CameraState.ApplyRotBlendHint:static start.*/
                ApplyRotBlendHint: function (rotA, hintA, rotB, hintB, original, blended) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#ApplyRotBlendHint", this ); }

                    if (((hintA | hintB) & Cinemachine.CameraState.BlendHintValue.NoOrientation) === 0) {
                        return blended.$clone();
                    }

                    if ((hintA & hintB & Cinemachine.CameraState.BlendHintValue.NoOrientation) !== 0) {
                        return original.$clone();
                    }

                    if ((hintA & Cinemachine.CameraState.BlendHintValue.NoOrientation) !== 0) {
                        return rotB.$clone();
                    }

                    return rotA.$clone();
                },
                /*Cinemachine.CameraState.ApplyRotBlendHint:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#getDefaultValue", this ); }
 return new Cinemachine.CameraState(); }
            }
        },
        fields: {
            /**
             * Camera Lens Settings.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function Lens
             * @type Cinemachine.LensSettings
             */
            Lens: null,
            /**
             * Which way is up.  World space unit vector.  Must have a length of 1.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function ReferenceUp
             * @type UnityEngine.Vector3
             */
            ReferenceUp: null,
            /**
             * The world space focus point of the camera.  What the camera wants to look at.
                 There is a special constant define to represent "nothing".  Be careful to
                 check for that (or check the HasLookAt property).
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function ReferenceLookAt
             * @type UnityEngine.Vector3
             */
            ReferenceLookAt: null,
            /**
             * Raw (un-corrected) world space position of this camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function RawPosition
             * @type UnityEngine.Vector3
             */
            RawPosition: null,
            /**
             * Raw (un-corrected) world space orientation of this camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function RawOrientation
             * @type UnityEngine.Quaternion
             */
            RawOrientation: null,
            /**
             * This is a way for the Body component to bypass aim damping,
                 useful for when the body need to rotate its point of view, but does not
                 want interference from the aim damping
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function PositionDampingBypass
             * @type UnityEngine.Vector3
             */
            PositionDampingBypass: null,
            /**
             * Subjective estimation of how "good" the shot is.
                 Larger values mean better quality.  Default is 1.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function ShotQuality
             * @type number
             */
            ShotQuality: 0,
            /**
             * Position correction.  This will be added to the raw position.
                 This value doesn't get fed back into the system when calculating the next frame.
                 Can be noise, or smoothing, or both, or something else.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function PositionCorrection
             * @type UnityEngine.Vector3
             */
            PositionCorrection: null,
            /**
             * Orientation correction.  This will be added to the raw orientation.
                 This value doesn't get fed back into the system when calculating the next frame.
                 Can be noise, or smoothing, or both, or something else.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function OrientationCorrection
             * @type UnityEngine.Quaternion
             */
            OrientationCorrection: null,
            /**
             * These hints can be or'ed toether to influence how blending is done, and how state
                 is applied to the camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function BlendHint
             * @type number
             */
            BlendHint: 0,
            mCustom0: null,
            mCustom1: null,
            mCustom2: null,
            mCustom3: null,
            m_CustomOverflow: null,
            /**
             * The number of custom blendables that will be applied to the camera.
                 The base system manages but otherwise ignores this data - it is intended for
                 extension modules
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState
             * @function NumCustomBlendables
             * @type number
             */
            NumCustomBlendables: 0
        },
        props: {
            /**
             * Returns true if this state has a valid ReferenceLookAt value.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CameraState
             * @function HasLookAt
             * @type boolean
             */
            HasLookAt: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#HasLookAt#get", this ); }

                    return pc.Vec3.equals( this.ReferenceLookAt, this.ReferenceLookAt );
                }
            },
            /**
             * Position with correction applied.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CameraState
             * @function CorrectedPosition
             * @type UnityEngine.Vector3
             */
            CorrectedPosition: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#CorrectedPosition#get", this ); }

                    return this.RawPosition.$clone().add( this.PositionCorrection );
                }
            },
            /**
             * Orientation with correction applied.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CameraState
             * @function CorrectedOrientation
             * @type UnityEngine.Quaternion
             */
            CorrectedOrientation: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#CorrectedOrientation#get", this ); }

                    return this.RawOrientation.clone().mul( this.OrientationCorrection );
                }
            },
            /**
             * Position with correction applied.  This is what the final camera gets.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CameraState
             * @function FinalPosition
             * @type UnityEngine.Vector3
             */
            FinalPosition: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#FinalPosition#get", this ); }

                    return this.RawPosition.$clone().add( this.PositionCorrection );
                }
            },
            /**
             * Orientation with correction and dutch applied.  This is what the final camera gets.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CameraState
             * @function FinalOrientation
             * @type UnityEngine.Quaternion
             */
            FinalOrientation: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#FinalOrientation#get", this ); }

                    if (Math.abs(this.Lens.Dutch) > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        return this.CorrectedOrientation.clone().mul( new pc.Quat().setFromAxisAngle( new pc.Vec3( 0, 0, 1 ), this.Lens.Dutch ) );
                    }

                    return this.CorrectedOrientation.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#init", this ); }

                this.Lens = new Cinemachine.LensSettings();
                this.ReferenceUp = new UnityEngine.Vector3();
                this.ReferenceLookAt = new UnityEngine.Vector3();
                this.RawPosition = new UnityEngine.Vector3();
                this.RawOrientation = new UnityEngine.Quaternion();
                this.PositionDampingBypass = new UnityEngine.Vector3();
                this.PositionCorrection = new UnityEngine.Vector3();
                this.OrientationCorrection = new UnityEngine.Quaternion();
                this.mCustom0 = new Cinemachine.CameraState.CustomBlendable();
                this.mCustom1 = new Cinemachine.CameraState.CustomBlendable();
                this.mCustom2 = new Cinemachine.CameraState.CustomBlendable();
                this.mCustom3 = new Cinemachine.CameraState.CustomBlendable();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.CameraState.GetCustomBlendable start.*/
            /**
             * Get a custom blendable that will be applied to the camera.
                 The base system manages but otherwise ignores this data - it is intended for
                 extension modules
             *
             * @instance
             * @public
             * @this Cinemachine.CameraState
             * @memberof Cinemachine.CameraState
             * @param   {number}                                     index    Which one to get.  Must be in range [0...NumCustomBlendables)
             * @return  {Cinemachine.CameraState.CustomBlendable}             The custom blendable at the specified index.
             */
            GetCustomBlendable: function (index) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#GetCustomBlendable", this ); }

                switch (index) {
                    case 0: 
                        return this.mCustom0.$clone();
                    case 1: 
                        return this.mCustom1.$clone();
                    case 2: 
                        return this.mCustom2.$clone();
                    case 3: 
                        return this.mCustom3.$clone();
                    default: 
                        {
                            index -= 4;
                            if (this.m_CustomOverflow != null && index < this.m_CustomOverflow.Count) {
                                return this.m_CustomOverflow.getItem(index).$clone();
                            }

                            return new Cinemachine.CameraState.CustomBlendable.$ctor1(null, 0);
                        }
                }
            },
            /*Cinemachine.CameraState.GetCustomBlendable end.*/

            /*Cinemachine.CameraState.FindCustomBlendable start.*/
            FindCustomBlendable: function (custom) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#FindCustomBlendable", this ); }

                if (Bridge.referenceEquals(this.mCustom0.m_Custom, custom)) {
                    return 0;
                }

                if (Bridge.referenceEquals(this.mCustom1.m_Custom, custom)) {
                    return 1;
                }

                if (Bridge.referenceEquals(this.mCustom2.m_Custom, custom)) {
                    return 2;
                }

                if (Bridge.referenceEquals(this.mCustom3.m_Custom, custom)) {
                    return 3;
                }

                if (this.m_CustomOverflow != null) {
                    for (var i = 0; i < this.m_CustomOverflow.Count; ++i) {
                        if (Bridge.referenceEquals(this.m_CustomOverflow.getItem(i).$clone().m_Custom, custom)) {
                            return i + 4;
                        }
                    }
                }

                return -1;
            },
            /*Cinemachine.CameraState.FindCustomBlendable end.*/

            /*Cinemachine.CameraState.AddCustomBlendable start.*/
            /**
             * Add a custom blendable to the pot for eventual application to the camera.
                 The base system manages but otherwise ignores this data - it is intended for
                 extension modules
             *
             * @instance
             * @public
             * @this Cinemachine.CameraState
             * @memberof Cinemachine.CameraState
             * @param   {Cinemachine.CameraState.CustomBlendable}    b    The custom blendable to add.  If b.m_Custom is the same as an
                 already-added custom blendable, then they will be merged and the weights combined.
             * @return  {void}
             */
            AddCustomBlendable: function (b) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#AddCustomBlendable", this ); }

                // Attempt to merge common blendables to avoid growth
                var index = this.FindCustomBlendable(b.m_Custom);
                if (index >= 0) {
                    b.m_Weight += this.GetCustomBlendable(index).m_Weight;
                } else {
                    index = this.NumCustomBlendables;
                    this.NumCustomBlendables = index + 1;
                }

                switch (index) {
                    case 0: 
                        this.mCustom0 = b.$clone();
                        break;
                    case 1: 
                        this.mCustom1 = b.$clone();
                        break;
                    case 2: 
                        this.mCustom2 = b.$clone();
                        break;
                    case 3: 
                        this.mCustom3 = b.$clone();
                        break;
                    default: 
                        {
                            if (this.m_CustomOverflow == null) {
                                this.m_CustomOverflow = new (System.Collections.Generic.List$1(Cinemachine.CameraState.CustomBlendable)).ctor();
                            }

                            this.m_CustomOverflow.add(b.$clone());
                            break;
                        }
                }
            },
            /*Cinemachine.CameraState.AddCustomBlendable end.*/

            /*Cinemachine.CameraState.InterpolatePosition start.*/
            InterpolatePosition: function (posA, pivotA, posB, pivotB, t) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#InterpolatePosition", this ); }

                if (pc.Vec3.equals( pivotA, pivotA ) && pc.Vec3.equals( pivotB, pivotB )) {
                    if ((this.BlendHint & Cinemachine.CameraState.BlendHintValue.CylindricalPositionBlend) !== 0) {
                        // Cylindrical interpolation about pivot
                        var a = pc.Vec3.projectOnPlane( posA.$clone().sub( pivotA ), this.ReferenceUp );
                        var b = pc.Vec3.projectOnPlane( posB.$clone().sub( pivotB ), this.ReferenceUp );
                        var c = new pc.Vec3().slerp( a, b, t );
                        posA = posA.$clone().sub( a ).add( c );
                        posB = posB.$clone().sub( b ).add( c );
                    } else if ((this.BlendHint & Cinemachine.CameraState.BlendHintValue.SphericalPositionBlend) !== 0) {
                        // Spherical interpolation about pivot
                        var c1 = new pc.Vec3().slerp( posA.$clone().sub( pivotA ), posB.$clone().sub( pivotB ), t );
                        posA = pivotA.$clone().add( c1 );
                        posB = pivotB.$clone().add( c1 );
                    }
                }

                return new pc.Vec3().lerp( posA, posB, t );
            },
            /*Cinemachine.CameraState.InterpolatePosition end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#getHashCode", this ); }

                var h = Bridge.addHash([3659937558, this.Lens, this.ReferenceUp, this.ReferenceLookAt, this.RawPosition, this.RawOrientation, this.PositionDampingBypass, this.ShotQuality, this.PositionCorrection, this.OrientationCorrection, this.BlendHint, this.mCustom0, this.mCustom1, this.mCustom2, this.mCustom3, this.m_CustomOverflow, this.NumCustomBlendables]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CameraState)) {
                    return false;
                }
                return Bridge.equals(this.Lens, o.Lens) && Bridge.equals(this.ReferenceUp, o.ReferenceUp) && Bridge.equals(this.ReferenceLookAt, o.ReferenceLookAt) && Bridge.equals(this.RawPosition, o.RawPosition) && Bridge.equals(this.RawOrientation, o.RawOrientation) && Bridge.equals(this.PositionDampingBypass, o.PositionDampingBypass) && Bridge.equals(this.ShotQuality, o.ShotQuality) && Bridge.equals(this.PositionCorrection, o.PositionCorrection) && Bridge.equals(this.OrientationCorrection, o.OrientationCorrection) && Bridge.equals(this.BlendHint, o.BlendHint) && Bridge.equals(this.mCustom0, o.mCustom0) && Bridge.equals(this.mCustom1, o.mCustom1) && Bridge.equals(this.mCustom2, o.mCustom2) && Bridge.equals(this.mCustom3, o.mCustom3) && Bridge.equals(this.m_CustomOverflow, o.m_CustomOverflow) && Bridge.equals(this.NumCustomBlendables, o.NumCustomBlendables);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState#$clone", this ); }

                var s = to || new Cinemachine.CameraState();
                s.Lens = this.Lens.$clone();
                s.ReferenceUp = this.ReferenceUp.$clone();
                s.ReferenceLookAt = this.ReferenceLookAt.$clone();
                s.RawPosition = this.RawPosition.$clone();
                s.RawOrientation = this.RawOrientation.$clone();
                s.PositionDampingBypass = this.PositionDampingBypass.$clone();
                s.ShotQuality = this.ShotQuality;
                s.PositionCorrection = this.PositionCorrection.$clone();
                s.OrientationCorrection = this.OrientationCorrection.$clone();
                s.BlendHint = this.BlendHint;
                s.mCustom0 = this.mCustom0.$clone();
                s.mCustom1 = this.mCustom1.$clone();
                s.mCustom2 = this.mCustom2.$clone();
                s.mCustom3 = this.mCustom3.$clone();
                s.m_CustomOverflow = this.m_CustomOverflow;
                s.NumCustomBlendables = this.NumCustomBlendables;
                return s;
            }
        }
    });
    /*Cinemachine.CameraState end.*/

    /*Cinemachine.CameraState+BlendHintValue start.*/
    /**
     * These hints can be or'ed toether to influence how blending is done, and how state
         is applied to the camera
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CameraState.BlendHintValue", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Normal state blending
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Nothing: 0,
                /**
                 * This state does not affect the camera position
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                NoPosition: 1,
                /**
                 * This state does not affect the camera rotation
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                NoOrientation: 2,
                /**
                 * Combination of NoPosition and NoOrientation
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                NoTransform: 3,
                /**
                 * Spherical blend about the LookAt target (if any)
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                SphericalPositionBlend: 4,
                /**
                 * Cylindrical blend about the LookAt target (if any)
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 8
                 * @type number
                 */
                CylindricalPositionBlend: 8,
                /**
                 * Radial blend when the LookAt target changes(if any)
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 16
                 * @type number
                 */
                RadialAimBlend: 16,
                /**
                 * Ignore the LookAt target and just slerp the orientation
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 32
                 * @type number
                 */
                IgnoreLookAtTarget: 32,
                /**
                 * This state does not affect the lens
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 64
                 * @type number
                 */
                NoLens: 64
            }
        }
    });
    /*Cinemachine.CameraState+BlendHintValue end.*/

    /*Cinemachine.CameraState+CustomBlendable start.*/
    /**
     * Opaque structure represent extra blendable stuff and its weight.
         The base system ignores this data - it is intended for extension modules
     *
     * @public
     * @class Cinemachine.CameraState.CustomBlendable
     */
    Bridge.define("Cinemachine.CameraState.CustomBlendable", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState.CustomBlendable#getDefaultValue", this ); }
 return new Cinemachine.CameraState.CustomBlendable(); }
            }
        },
        fields: {
            /**
             * The custom stuff that the extension module will consider
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState.CustomBlendable
             * @type UnityEngine.Object
             */
            m_Custom: null,
            /**
             * The weight of the custom stuff.  Must be 0...1
             *
             * @instance
             * @public
             * @memberof Cinemachine.CameraState.CustomBlendable
             * @type number
             */
            m_Weight: 0
        },
        ctors: {
            /**
             * Constructor with specific values
             *
             * @instance
             * @public
             * @this Cinemachine.CameraState.CustomBlendable
             * @memberof Cinemachine.CameraState.CustomBlendable
             * @param   {UnityEngine.Object}    custom    The custom stuff that the extension module will consider
             * @param   {number}                weight    The weight of the custom stuff.  Must be 0...1
             * @return  {void}
             */
            $ctor1: function (custom, weight) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState.CustomBlendable#$ctor1", this ); }

                this.$initialize();
                this.m_Custom = custom;
                this.m_Weight = weight;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState.CustomBlendable#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CameraState.CustomBlendable#getHashCode", this ); }

                var h = Bridge.addHash([5410635129, this.m_Custom, this.m_Weight]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState.CustomBlendable#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CameraState.CustomBlendable)) {
                    return false;
                }
                return Bridge.equals(this.m_Custom, o.m_Custom) && Bridge.equals(this.m_Weight, o.m_Weight);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CameraState.CustomBlendable#$clone", this ); }

                var s = to || new Cinemachine.CameraState.CustomBlendable();
                s.m_Custom = this.m_Custom;
                s.m_Weight = this.m_Weight;
                return s;
            }
        }
    });
    /*Cinemachine.CameraState+CustomBlendable end.*/

    /*Cinemachine.CinemachineComponentBase start.*/
    /**
     * An abstract representation of a mutator acting on a Cinemachine Virtual Camera
     *
     * @abstract
     * @public
     * @class Cinemachine.CinemachineComponentBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachineComponentBase", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                /**
                 * Useful constant for very small floats
                 *
                 * @static
                 * @protected
                 * @memberof Cinemachine.CinemachineComponentBase
                 * @constant
                 * @default 0.0001
                 * @type number
                 */
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#init", this ); }

                    this.Epsilon = 0.0001;
                }
            }
        },
        fields: {
            m_vcamOwner: null,
            mCachedFollowTarget: null,
            mCachedFollowTargetGroup: null,
            mCachedFollowTargetVcam: null,
            mCachedLookAtTarget: null,
            mCachedLookAtTargetGroup: null,
            mCachedLookAtTargetVcam: null
        },
        props: {
            /**
             * Get the associated CinemachineVirtualCameraBase
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function VirtualCamera
             * @type Cinemachine.CinemachineVirtualCameraBase
             */
            VirtualCamera: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#VirtualCamera#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_vcamOwner, null)) {
                        this.m_vcamOwner = this.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                    }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_vcamOwner, null) && UnityEngine.Component.op_Inequality(this.transform.parent, null)) {
                        this.m_vcamOwner = this.transform.parent.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                    }

                    return this.m_vcamOwner;
                }
            },
            /**
             * Returns the owner vcam's Follow target.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function FollowTarget
             * @type UnityEngine.Transform
             */
            FollowTarget: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#FollowTarget#get", this ); }

                    var vcam = this.VirtualCamera;
                    return UnityEngine.MonoBehaviour.op_Equality(vcam, null) ? null : vcam.Follow;
                }
            },
            /**
             * Returns the owner vcam's LookAt target.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function LookAtTarget
             * @type UnityEngine.Transform
             */
            LookAtTarget: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#LookAtTarget#get", this ); }

                    var vcam = this.VirtualCamera;
                    return UnityEngine.MonoBehaviour.op_Equality(vcam, null) ? null : vcam.LookAt;
                }
            },
            /**
             * Get Follow target as ICinemachineTargetGroup, or null if target is not a group
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function AbstractFollowTargetGroup
             * @type Cinemachine.ICinemachineTargetGroup
             */
            AbstractFollowTargetGroup: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#AbstractFollowTargetGroup#get", this ); }

                    if (UnityEngine.Component.op_Inequality(this.FollowTarget, this.mCachedFollowTarget)) {
                        this.UpdateFollowTargetCache();
                    }

                    return this.mCachedFollowTargetGroup;
                }
            },
            /**
             * Get Follow target as CinemachineTargetGroup, or null if target is not a CinemachineTargetGroup
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function FollowTargetGroup
             * @type Cinemachine.CinemachineTargetGroup
             */
            FollowTargetGroup: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#FollowTargetGroup#get", this ); }

                    return Bridge.as(this.AbstractFollowTargetGroup, Cinemachine.CinemachineTargetGroup);
                }
            },
            /**
             * Get the position of the Follow target.  Special handling: If the Follow target is
                 a VirtualCamera, returns the vcam State's position, not the transform's position
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function FollowTargetPosition
             * @type UnityEngine.Vector3
             */
            FollowTargetPosition: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#FollowTargetPosition#get", this ); }

                    var target = this.FollowTarget;
                    if (UnityEngine.Component.op_Inequality(target, this.mCachedFollowTarget)) {
                        this.UpdateFollowTargetCache();
                    }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.mCachedFollowTargetVcam, null)) {
                        return this.mCachedFollowTargetVcam.State.FinalPosition.$clone();
                    }

                    if (UnityEngine.Component.op_Inequality(target, null)) {
                        return target.position.$clone();
                    }

                    return pc.Vec3.ZERO.clone();
                }
            },
            /**
             * Get the rotation of the Follow target.  Special handling: If the Follow target is
                 a VirtualCamera, returns the vcam State's rotation, not the transform's rotation
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function FollowTargetRotation
             * @type UnityEngine.Quaternion
             */
            FollowTargetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#FollowTargetRotation#get", this ); }

                    var target = this.FollowTarget;
                    if (UnityEngine.Component.op_Inequality(target, this.mCachedFollowTarget)) {
                        this.mCachedFollowTargetVcam = null;
                        this.mCachedFollowTarget = target;
                        if (UnityEngine.Component.op_Inequality(target, null)) {
                            this.mCachedFollowTargetVcam = target.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                        }
                    }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.mCachedFollowTargetVcam, null)) {
                        return this.mCachedFollowTargetVcam.State.FinalOrientation.$clone();
                    }

                    if (UnityEngine.Component.op_Inequality(target, null)) {
                        return target.rotation.$clone();
                    }

                    return pc.Quat.IDENTITY.clone();
                }
            },
            /**
             * Get LookAt target as ICinemachineTargetGroup, or null if target is not a group
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function AbstractLookAtTargetGroup
             * @type Cinemachine.ICinemachineTargetGroup
             */
            AbstractLookAtTargetGroup: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#AbstractLookAtTargetGroup#get", this ); }

                    if (UnityEngine.Component.op_Inequality(this.LookAtTarget, this.mCachedLookAtTarget)) {
                        this.UpdateLookAtTargetCache();
                    }

                    return this.mCachedLookAtTargetGroup;
                }
            },
            /**
             * Get LookAt target as CinemachineTargetGroup, or null if target is not a CinemachineTargetGroup
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function LookAtTargetGroup
             * @type Cinemachine.CinemachineTargetGroup
             */
            LookAtTargetGroup: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#LookAtTargetGroup#get", this ); }

                    return Bridge.as(this.AbstractLookAtTargetGroup, Cinemachine.CinemachineTargetGroup);
                }
            },
            /**
             * Get the position of the LookAt target.  Special handling: If the LookAt target is
                 a VirtualCamera, returns the vcam State's position, not the transform's position
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function LookAtTargetPosition
             * @type UnityEngine.Vector3
             */
            LookAtTargetPosition: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#LookAtTargetPosition#get", this ); }

                    var target = this.LookAtTarget;
                    if (UnityEngine.Component.op_Inequality(target, this.mCachedLookAtTarget)) {
                        this.UpdateLookAtTargetCache();
                    }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.mCachedLookAtTargetVcam, null)) {
                        return this.mCachedLookAtTargetVcam.State.FinalPosition.$clone();
                    }

                    if (UnityEngine.Component.op_Inequality(target, null)) {
                        return target.position.$clone();
                    }

                    return pc.Vec3.ZERO.clone();
                }
            },
            /**
             * Get the rotation of the LookAt target.  Special handling: If the LookAt target is
                 a VirtualCamera, returns the vcam State's rotation, not the transform's rotation
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function LookAtTargetRotation
             * @type UnityEngine.Quaternion
             */
            LookAtTargetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#LookAtTargetRotation#get", this ); }

                    var target = this.LookAtTarget;
                    if (UnityEngine.Component.op_Inequality(target, this.mCachedLookAtTarget)) {
                        this.UpdateLookAtTargetCache();
                    }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.mCachedLookAtTargetVcam, null)) {
                        return this.mCachedLookAtTargetVcam.State.FinalOrientation.$clone();
                    }

                    if (UnityEngine.Component.op_Inequality(target, null)) {
                        return target.rotation.$clone();
                    }

                    return pc.Quat.IDENTITY.clone();
                }
            },
            /**
             * Returns the owner vcam's CameraState.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineComponentBase
             * @function VcamState
             * @type Cinemachine.CameraState
             */
            VcamState: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#VcamState#get", this ); }

                    var vcam = this.VirtualCamera;
                    return UnityEngine.MonoBehaviour.op_Equality(vcam, null) ? Cinemachine.CameraState.Default.$clone() : vcam.State.$clone();
                }
            }
        },
        methods: {
            /*Cinemachine.CinemachineComponentBase.UpdateFollowTargetCache start.*/
            UpdateFollowTargetCache: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#UpdateFollowTargetCache", this ); }

                this.mCachedFollowTargetVcam = null;
                this.mCachedFollowTargetGroup = null;
                this.mCachedFollowTarget = this.FollowTarget;
                if (UnityEngine.Component.op_Inequality(this.mCachedFollowTarget, null)) {
                    this.mCachedFollowTargetVcam = this.mCachedFollowTarget.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                    this.mCachedFollowTargetGroup = this.mCachedFollowTarget.GetComponent(Cinemachine.ICinemachineTargetGroup);
                }
            },
            /*Cinemachine.CinemachineComponentBase.UpdateFollowTargetCache end.*/

            /*Cinemachine.CinemachineComponentBase.UpdateLookAtTargetCache start.*/
            UpdateLookAtTargetCache: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#UpdateLookAtTargetCache", this ); }

                this.mCachedLookAtTargetVcam = null;
                this.mCachedLookAtTargetGroup = null;
                this.mCachedLookAtTarget = this.LookAtTarget;
                if (UnityEngine.Component.op_Inequality(this.mCachedLookAtTarget, null)) {
                    this.mCachedLookAtTargetVcam = this.mCachedLookAtTarget.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                    this.mCachedLookAtTargetGroup = this.mCachedLookAtTarget.GetComponent(Cinemachine.ICinemachineTargetGroup);
                }
            },
            /*Cinemachine.CinemachineComponentBase.UpdateLookAtTargetCache end.*/

            /*Cinemachine.CinemachineComponentBase.PrePipelineMutateCameraState start.*/
            /**
             * Override this to do such things as offset the RefereceLookAt.
                 Base class implementation does nothing.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineComponentBase
             * @memberof Cinemachine.CinemachineComponentBase
             * @param   {Cinemachine.CameraState}    curState     Input state that must be mutated
             * @param   {number}                     deltaTime
             * @return  {void}
             */
            PrePipelineMutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#PrePipelineMutateCameraState", this ); }
 },
            /*Cinemachine.CinemachineComponentBase.PrePipelineMutateCameraState end.*/

            /*Cinemachine.CinemachineComponentBase.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
                 Base class implementation does nothing.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineComponentBase
             * @memberof Cinemachine.CinemachineComponentBase
             * @param   {Cinemachine.ICinemachineCamera}                               fromCam             The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}                                          worldUp             Default world Up, set by the CinemachineBrain
             * @param   {number}                                                       deltaTime           Delta time for time-based effects (ignore if less than or equal to 0)
             * @param   {Cinemachine.CinemachineVirtualCameraBase.TransitionParams}    transitionParams
             * @return  {boolean}                                                                          True if the vcam should do an internal update as a result of this call
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime, transitionParams) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#OnTransitionFromCamera", this ); }

                return false;
            },
            /*Cinemachine.CinemachineComponentBase.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineComponentBase.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the component that a target got warped,
                 so that the component can update its internal state to make the camera
                 also warp seamlessy.  Base class implementation does nothing.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineComponentBase
             * @memberof Cinemachine.CinemachineComponentBase
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComponentBase#OnTargetObjectWarped", this ); }
 },
            /*Cinemachine.CinemachineComponentBase.OnTargetObjectWarped end.*/


        }
    });
    /*Cinemachine.CinemachineComponentBase end.*/

    /*Cinemachine.CinemachineBlend start.*/
    /**
     * Describes a blend between 2 Cinemachine Virtual Cameras, and holds the
         current state of the blend.
     *
     * @public
     * @class Cinemachine.CinemachineBlend
     */
    Bridge.define("Cinemachine.CinemachineBlend", {
        fields: {
            /**
             * First camera in the blend
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlend
             * @function CamA
             * @type Cinemachine.ICinemachineCamera
             */
            CamA: null,
            /**
             * Second camera in the blend
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlend
             * @function CamB
             * @type Cinemachine.ICinemachineCamera
             */
            CamB: null,
            /**
             * The curve that describes the way the blend transitions over time
                 from the first camera to the second.  X-axis is normalized time (0...1) over which
                 the blend takes place and Y axis is blend weight (0..1)
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlend
             * @function BlendCurve
             * @type pc.AnimationCurve
             */
            BlendCurve: null,
            /**
             * The current time relative to the start of the blend
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlend
             * @function TimeInBlend
             * @type number
             */
            TimeInBlend: 0,
            /**
             * Duration in seconds of the blend.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlend
             * @function Duration
             * @type number
             */
            Duration: 0
        },
        props: {
            /**
             * The current weight of the blend.  This is an evaluation of the
                 BlendCurve at the current time relative to the start of the blend.
                 0 means camA, 1 means camB.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBlend
             * @function BlendWeight
             * @type number
             */
            BlendWeight: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlend#BlendWeight#get", this ); }

                    if (this.BlendCurve == null || this.BlendCurve.keys.length < 2 || this.IsComplete) {
                        return 1;
                    }

                    return Math.max(0, Math.min(1, this.BlendCurve.value(this.TimeInBlend / this.Duration)));
                }
            },
            /**
             * Validity test for the blend.  True if either camera is defined.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBlend
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlend#IsValid#get", this ); }

                    return this.CamA != null && this.CamA.Cinemachine$ICinemachineCamera$IsValid || this.CamB != null && this.CamB.Cinemachine$ICinemachineCamera$IsValid;
                }
            },
            /**
             * True if the time relative to the start of the blend is greater
                 than or equal to the blend duration
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBlend
             * @function IsComplete
             * @type boolean
             */
            IsComplete: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlend#IsComplete#get", this ); }

                    return this.TimeInBlend >= this.Duration || !this.IsValid;
                }
            },
            /**
             * Text description of the blend, for debugging
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBlend
             * @function Description
             * @type string
             */
            Description: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlend#Description#get", this ); }

                    var sb = Cinemachine.Utility.CinemachineDebug.SBFromPool();
                    if (this.CamB == null || !this.CamB.Cinemachine$ICinemachineCamera$IsValid) {
                        sb.append("(none)");
                    } else {
                        sb.append("[");
                        sb.append(this.CamB.Cinemachine$ICinemachineCamera$Name);
                        sb.append("]");
                    }

                    sb.append(" ");
                    sb.append(this.BlendWeight * 100.0);
                    sb.append("% from ");
                    if (this.CamA == null || !this.CamA.Cinemachine$ICinemachineCamera$IsValid) {
                        sb.append("(none)");
                    } else {
                        sb.append("[");
                        sb.append(this.CamA.Cinemachine$ICinemachineCamera$Name);
                        sb.append("]");
                    }

                    var text = sb.toString();
                    Cinemachine.Utility.CinemachineDebug.ReturnToPool(sb);
                    return text;
                }
            },
            /**
             * Compute the blended CameraState for the current time in the blend.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBlend
             * @function State
             * @type Cinemachine.CameraState
             */
            State: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlend#State#get", this ); }

                    if (this.CamA == null || !this.CamA.Cinemachine$ICinemachineCamera$IsValid) {
                        if (this.CamB == null || !this.CamB.Cinemachine$ICinemachineCamera$IsValid) {
                            return Cinemachine.CameraState.Default.$clone();
                        }

                        return this.CamB.Cinemachine$ICinemachineCamera$State.$clone();
                    }

                    if (this.CamB == null || !this.CamB.Cinemachine$ICinemachineCamera$IsValid) {
                        return this.CamA.Cinemachine$ICinemachineCamera$State.$clone();
                    }

                    return Cinemachine.CameraState.Lerp(this.CamA.Cinemachine$ICinemachineCamera$State.$clone(), this.CamB.Cinemachine$ICinemachineCamera$State.$clone(), this.BlendWeight);
                }
            }
        },
        ctors: {
            /**
             * Construct a blend
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineBlend
             * @memberof Cinemachine.CinemachineBlend
             * @param   {Cinemachine.ICinemachineCamera}    a           First camera
             * @param   {Cinemachine.ICinemachineCamera}    b           Second camera
             * @param   {pc.AnimationCurve}                 curve       Blend curve
             * @param   {number}                            duration    Duration of the blend, in seconds
             * @param   {number}                            t           Current time in blend, relative to the start of the blend
             * @return  {void}
             */
            ctor: function (a, b, curve, duration, t) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlend#ctor", this ); }

                this.$initialize();
                this.CamA = a;
                this.CamB = b;
                this.BlendCurve = curve;
                this.TimeInBlend = t;
                this.Duration = duration;
            }
        },
        methods: {
            /*Cinemachine.CinemachineBlend.Uses start.*/
            /**
             * Does the blend use a specific Cinemachine Virtual Camera?
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineBlend
             * @memberof Cinemachine.CinemachineBlend
             * @param   {Cinemachine.ICinemachineCamera}    cam    The camera to test
             * @return  {boolean}                                  True if the camera is involved in the blend
             */
            Uses: function (cam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlend#Uses", this ); }

                if (Bridge.referenceEquals(cam, this.CamA) || Bridge.referenceEquals(cam, this.CamB)) {
                    return true;
                }

                var b = Bridge.as(this.CamA, Cinemachine.BlendSourceVirtualCamera);
                if (b != null && b.Blend.Uses(cam)) {
                    return true;
                }

                b = Bridge.as(this.CamB, Cinemachine.BlendSourceVirtualCamera);
                if (b != null && b.Blend.Uses(cam)) {
                    return true;
                }

                return false;
            },
            /*Cinemachine.CinemachineBlend.Uses end.*/

            /*Cinemachine.CinemachineBlend.UpdateCameraState start.*/
            /**
             * Make sure the source cameras get updated.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineBlend
             * @memberof Cinemachine.CinemachineBlend
             * @param   {UnityEngine.Vector3}    worldUp      Default world up.  Individual vcams may modify this
             * @param   {number}                 deltaTime    Time increment used for calculating time-based behaviours (e.g. damping)
             * @return  {void}
             */
            UpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlend#UpdateCameraState", this ); }

                // Make sure both cameras have been updated (they are not necessarily
                // enabled, and only enabled cameras get updated automatically
                // every frame)
                if (this.CamA != null && this.CamA.Cinemachine$ICinemachineCamera$IsValid) {
                    this.CamA.Cinemachine$ICinemachineCamera$UpdateCameraState(worldUp.$clone(), deltaTime);
                }

                if (this.CamB != null && this.CamB.Cinemachine$ICinemachineCamera$IsValid) {
                    this.CamB.Cinemachine$ICinemachineCamera$UpdateCameraState(worldUp.$clone(), deltaTime);
                }
            },
            /*Cinemachine.CinemachineBlend.UpdateCameraState end.*/


        }
    });
    /*Cinemachine.CinemachineBlend end.*/

    /*Cinemachine.CinemachineBlendDefinition start.*/
    /**
     * Definition of a Camera blend.  This struct holds the information
         necessary to generate a suitable AnimationCurve for a Cinemachine Blend.
     *
     * @public
     * @class Cinemachine.CinemachineBlendDefinition
     */
    Bridge.define("Cinemachine.CinemachineBlendDefinition", {
        $kind: "struct",
        statics: {
            fields: {
                sStandardCurves: null
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendDefinition#getDefaultValue", this ); }
 return new Cinemachine.CinemachineBlendDefinition(); }
            }
        },
        fields: {
            /**
             * The shape of the blend curve.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendDefinition
             * @type number
             */
            m_Style: 0,
            /**
             * The duration (in seconds) of the blend
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendDefinition
             * @type number
             */
            m_Time: 0,
            /**
             * A user-defined AnimationCurve, used only if style is Custom.
                 Curve MUST be normalized, i.e. time range [0...1], value range [0...1].
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendDefinition
             * @type pc.AnimationCurve
             */
            m_CustomCurve: null
        },
        props: {
            /**
             * A normalized AnimationCurve specifying the interpolation curve
                 for this camera blend. Y-axis values must be in range [0,1] (internally clamped
                 within Blender) and time must be in range of [0, 1].
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBlendDefinition
             * @function BlendCurve
             * @type pc.AnimationCurve
             */
            BlendCurve: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendDefinition#BlendCurve#get", this ); }

                    if (this.m_Style === Cinemachine.CinemachineBlendDefinition.Style.Custom) {
                        if (this.m_CustomCurve == null) {
                            this.m_CustomCurve = pc.AnimationCurve.createEaseInOut(0.0, 0.0, 1, 1.0);
                        }

                        return this.m_CustomCurve;
                    }

                    if (Cinemachine.CinemachineBlendDefinition.sStandardCurves == null) {
                        this.CreateStandardCurves();
                    }

                    return Cinemachine.CinemachineBlendDefinition.sStandardCurves[this.m_Style];
                }
            }
        },
        ctors: {
            /**
             * Constructor
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineBlendDefinition
             * @memberof Cinemachine.CinemachineBlendDefinition
             * @param   {number}    style    The shape of the blend curve.
             * @param   {number}    time     The duration (in seconds) of the blend
             * @return  {void}
             */
            $ctor1: function (style, time) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendDefinition#$ctor1", this ); }

                this.$initialize();
                this.m_Style = style;
                this.m_Time = time;
                this.m_CustomCurve = null;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendDefinition#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.CinemachineBlendDefinition.CreateStandardCurves start.*/
            CreateStandardCurves: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendDefinition#CreateStandardCurves", this ); }

                Cinemachine.CinemachineBlendDefinition.sStandardCurves = System.Array.init(Cinemachine.CinemachineBlendDefinition.Style.Custom, null, pc.AnimationCurve);

                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.Cut] = null;
                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.EaseInOut] = pc.AnimationCurve.createEaseInOut(0.0, 0.0, 1, 1.0);

                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.EaseIn] = pc.AnimationCurve.createLinear(0.0, 0.0, 1, 1.0);
                var keys = Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.EaseIn].keys;
                keys[0].outTangent = 1.4;
                keys[1].inTangent = 0;
                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.EaseIn].keys = keys;

                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.EaseOut] = pc.AnimationCurve.createLinear(0.0, 0.0, 1, 1.0);
                keys = Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.EaseOut].keys;
                keys[0].outTangent = 0;
                keys[1].inTangent = 1.4;
                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.EaseOut].keys = keys;

                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.HardIn] = pc.AnimationCurve.createLinear(0.0, 0.0, 1, 1.0);
                keys = Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.HardIn].keys;
                keys[0].outTangent = 0;
                keys[1].inTangent = 3.0;
                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.HardIn].keys = keys;

                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.HardOut] = pc.AnimationCurve.createLinear(0.0, 0.0, 1, 1.0);
                keys = Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.HardOut].keys;
                keys[0].outTangent = 3.0;
                keys[1].inTangent = 0;
                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.HardOut].keys = keys;

                Cinemachine.CinemachineBlendDefinition.sStandardCurves[Cinemachine.CinemachineBlendDefinition.Style.Linear] = pc.AnimationCurve.createLinear(0.0, 0.0, 1, 1.0);
            },
            /*Cinemachine.CinemachineBlendDefinition.CreateStandardCurves end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendDefinition#getHashCode", this ); }

                var h = Bridge.addHash([9789561766, this.m_Style, this.m_Time, this.m_CustomCurve]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendDefinition#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineBlendDefinition)) {
                    return false;
                }
                return Bridge.equals(this.m_Style, o.m_Style) && Bridge.equals(this.m_Time, o.m_Time) && Bridge.equals(this.m_CustomCurve, o.m_CustomCurve);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendDefinition#$clone", this ); }

                var s = to || new Cinemachine.CinemachineBlendDefinition();
                s.m_Style = this.m_Style;
                s.m_Time = this.m_Time;
                s.m_CustomCurve = this.m_CustomCurve;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineBlendDefinition end.*/

    /*Cinemachine.CinemachineBlendDefinition+Style start.*/
    /**
     * Supported predefined shapes for the blend curve.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineBlendDefinition.Style", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Zero-length blend
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Cut: 0,
                /**
                 * S-shaped curve, giving a gentle and smooth transition
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                EaseInOut: 1,
                /**
                 * Linear out of the outgoing shot, and easy into the incoming
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                EaseIn: 2,
                /**
                 * Easy out of the outgoing shot, and linear into the incoming
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                EaseOut: 3,
                /**
                 * Easy out of the outgoing, and hard into the incoming
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                HardIn: 4,
                /**
                 * Hard out of the outgoing, and easy into the incoming
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 5
                 * @type number
                 */
                HardOut: 5,
                /**
                 * Linear blend.  Mechanical-looking.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 6
                 * @type number
                 */
                Linear: 6,
                /**
                 * Custom blend curve.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 7
                 * @type number
                 */
                Custom: 7
            }
        }
    });
    /*Cinemachine.CinemachineBlendDefinition+Style end.*/

    /*Cinemachine.CinemachineBlendDefinitionPropertyAttribute start.*/
    /**
     * Property applied to CinemachineBlendDefinition.  Used for custom drawing in the inspector.
     *
     * @public
     * @class Cinemachine.CinemachineBlendDefinitionPropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.CinemachineBlendDefinitionPropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.CinemachineBlendDefinitionPropertyAttribute end.*/

    /*Cinemachine.CinemachineBlenderSettings start.*/
    /**
     * Asset that defines the rules for blending between Virtual Cameras.
     *
     * @public
     * @class Cinemachine.CinemachineBlenderSettings
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Cinemachine.CinemachineBlenderSettings", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                /**
                 * Internal API for the inspector editopr: a label to represent any camera
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineBlenderSettings
                 * @constant
                 * @default "**ANY CAMERA**"
                 * @type string
                 */
                kBlendFromAnyCameraLabel: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlenderSettings#init", this ); }

                    this.kBlendFromAnyCameraLabel = "**ANY CAMERA**";
                }
            }
        },
        fields: {
            /**
             * The array containing explicitly defined blends between two Virtual Cameras
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlenderSettings
             * @type Array.<Cinemachine.CinemachineBlenderSettings.CustomBlend>
             */
            m_CustomBlends: null
        },
        methods: {
            /*Cinemachine.CinemachineBlenderSettings.GetBlendForVirtualCameras start.*/
            /**
             * Attempts to find a blend definition which matches the to and from cameras as specified.
                 If no match is found, the function returns the supplied default blend.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineBlenderSettings
             * @memberof Cinemachine.CinemachineBlenderSettings
             * @param   {string}                                    fromCameraName    The game object name of the from camera
             * @param   {string}                                    toCameraName      The game object name of the to camera
             * @param   {Cinemachine.CinemachineBlendDefinition}    defaultBlend      Blend to return if no custom blend found.
             * @return  {Cinemachine.CinemachineBlendDefinition}
             */
            GetBlendForVirtualCameras: function (fromCameraName, toCameraName, defaultBlend) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlenderSettings#GetBlendForVirtualCameras", this ); }

                var gotAnyToMe = false;
                var gotMeToAny = false;
                var anyToMe = defaultBlend.$clone();
                var meToAny = defaultBlend.$clone();
                if (this.m_CustomBlends != null) {
                    for (var i = 0; i < this.m_CustomBlends.length; ++i) {
                        // Attempt to find direct name first
                        var blendParams = this.m_CustomBlends[i].$clone();
                        if (Bridge.referenceEquals(blendParams.m_From, fromCameraName) && Bridge.referenceEquals(blendParams.m_To, toCameraName)) {
                            return blendParams.m_Blend.$clone();
                        }

                        // If we come across applicable wildcards, remember them
                        if (Bridge.referenceEquals(blendParams.m_From, Cinemachine.CinemachineBlenderSettings.kBlendFromAnyCameraLabel)) {
                            if (!System.String.isNullOrEmpty(toCameraName) && Bridge.referenceEquals(blendParams.m_To, toCameraName)) {
                                anyToMe = blendParams.m_Blend.$clone();
                                gotAnyToMe = true;
                            } else if (Bridge.referenceEquals(blendParams.m_To, Cinemachine.CinemachineBlenderSettings.kBlendFromAnyCameraLabel)) {
                                defaultBlend = blendParams.m_Blend.$clone();
                            }
                        } else if (Bridge.referenceEquals(blendParams.m_To, Cinemachine.CinemachineBlenderSettings.kBlendFromAnyCameraLabel) && !System.String.isNullOrEmpty(fromCameraName) && Bridge.referenceEquals(blendParams.m_From, fromCameraName)) {
                            meToAny = blendParams.m_Blend.$clone();
                            gotMeToAny = true;
                        }
                    }
                }

                // If nothing is found try to find wild card blends from any
                // camera to our new one
                if (gotAnyToMe) {
                    return anyToMe.$clone();
                }

                // Still have nothing? Try from our camera to any camera
                if (gotMeToAny) {
                    return meToAny.$clone();
                }

                return defaultBlend.$clone();
            },
            /*Cinemachine.CinemachineBlenderSettings.GetBlendForVirtualCameras end.*/


        }
    });
    /*Cinemachine.CinemachineBlenderSettings end.*/

    /*Cinemachine.CinemachineBlenderSettings+CustomBlend start.*/
    /**
     * Container specifying how two specific Cinemachine Virtual Cameras
         blend together.
     *
     * @public
     * @class Cinemachine.CinemachineBlenderSettings.CustomBlend
     */
    Bridge.define("Cinemachine.CinemachineBlenderSettings.CustomBlend", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlenderSettings.CustomBlend#getDefaultValue", this ); }
 return new Cinemachine.CinemachineBlenderSettings.CustomBlend(); }
            }
        },
        fields: {
            m_From: null,
            m_To: null,
            m_Blend: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlenderSettings.CustomBlend#init", this ); }

                this.m_Blend = new Cinemachine.CinemachineBlendDefinition();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlenderSettings.CustomBlend#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlenderSettings.CustomBlend#getHashCode", this ); }

                var h = Bridge.addHash([3776598295, this.m_From, this.m_To, this.m_Blend]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlenderSettings.CustomBlend#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineBlenderSettings.CustomBlend)) {
                    return false;
                }
                return Bridge.equals(this.m_From, o.m_From) && Bridge.equals(this.m_To, o.m_To) && Bridge.equals(this.m_Blend, o.m_Blend);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlenderSettings.CustomBlend#$clone", this ); }

                var s = to || new Cinemachine.CinemachineBlenderSettings.CustomBlend();
                s.m_From = this.m_From;
                s.m_To = this.m_To;
                s.m_Blend = this.m_Blend.$clone();
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineBlenderSettings+CustomBlend end.*/

    /*Cinemachine.CinemachineBlendListCamera+Instruction start.*/
    /**
     * This represents a single entry in the instrunction list of the BlendListCamera.
     *
     * @public
     * @class Cinemachine.CinemachineBlendListCamera.Instruction
     */
    Bridge.define("Cinemachine.CinemachineBlendListCamera.Instruction", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera.Instruction#getDefaultValue", this ); }
 return new Cinemachine.CinemachineBlendListCamera.Instruction(); }
            }
        },
        fields: {
            /**
             * The virtual camera to activate when this instruction becomes active
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendListCamera.Instruction
             * @type Cinemachine.CinemachineVirtualCameraBase
             */
            m_VirtualCamera: null,
            /**
             * How long to wait (in seconds) before activating the next virtual camera in the list (if any)
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendListCamera.Instruction
             * @type number
             */
            m_Hold: 0,
            /**
             * How to blend to the next virtual camera in the list (if any)
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendListCamera.Instruction
             * @type Cinemachine.CinemachineBlendDefinition
             */
            m_Blend: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera.Instruction#init", this ); }

                this.m_Blend = new Cinemachine.CinemachineBlendDefinition();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera.Instruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera.Instruction#getHashCode", this ); }

                var h = Bridge.addHash([3913634596, this.m_VirtualCamera, this.m_Hold, this.m_Blend]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera.Instruction#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineBlendListCamera.Instruction)) {
                    return false;
                }
                return Bridge.equals(this.m_VirtualCamera, o.m_VirtualCamera) && Bridge.equals(this.m_Hold, o.m_Hold) && Bridge.equals(this.m_Blend, o.m_Blend);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera.Instruction#$clone", this ); }

                var s = to || new Cinemachine.CinemachineBlendListCamera.Instruction();
                s.m_VirtualCamera = this.m_VirtualCamera;
                s.m_Hold = this.m_Hold;
                s.m_Blend = this.m_Blend.$clone();
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineBlendListCamera+Instruction end.*/

    /*Cinemachine.CinemachineBrain start.*/
    /**
     * CinemachineBrain is the link between the Unity Camera and the Cinemachine Virtual
         Cameras in the scene.  It monitors the priority stack to choose the current
         Virtual Camera, and blend with another if necessary.  Finally and most importantly,
         it applies the Virtual Camera state to the attached Unity Camera.
         The CinemachineBrain is also the place where rules for blending between virtual cameras
         are defined.  Camera blending is an interpolation over time of one virtual camera
         position and state to another. If you think of virtual cameras as cameramen, then
         blending is a little like one cameraman smoothly passing the camera to another cameraman.
         You can specify the time over which to blend, as well as the blend curve shape.
         Note that a camera cut is just a zero-time blend.
     *
     * @public
     * @class Cinemachine.CinemachineBrain
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachineBrain", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                mSoloCamera: null
            },
            props: {
                /**
                 * API for the Unity Editor.
                     Show this camera no matter what.  This is static, and so affects all Cinemachine brains.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineBrain
                 * @function SoloCamera
                 * @type Cinemachine.ICinemachineCamera
                 */
                SoloCamera: {
                    get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#SoloCamera#get", this ); }

                        return Cinemachine.CinemachineBrain.mSoloCamera;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#SoloCamera#set", this ); }

                        if (value != null && !Cinemachine.CinemachineCore.Instance.IsLive(value)) {
                            value.Cinemachine$ICinemachineCamera$OnTransitionFromCamera(null, pc.Vec3.UP.clone(), UnityEngine.Time.deltaTime);
                        }

                        Cinemachine.CinemachineBrain.mSoloCamera = value;
                    }
                }
            },
            methods: {
                /*Cinemachine.CinemachineBrain.GetSoloGUIColor:static start.*/
                /**
                 * API for the Unity Editor.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.CinemachineBrain
                 * @memberof Cinemachine.CinemachineBrain
                 * @return  {UnityEngine.Color}        Color used to indicate that a camera is in Solo mode.
                 */
                GetSoloGUIColor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#GetSoloGUIColor", this ); }

                    return pc.Color.lerp( new pc.Color( 1, 0, 0, 1 ), new pc.Color( 1, 1, 0, 1 ), 0.8 );
                },
                /*Cinemachine.CinemachineBrain.GetSoloGUIColor:static end.*/

                /*Cinemachine.CinemachineBrain.DeepCamBFromBlend:static start.*/
                DeepCamBFromBlend: function (blend) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#DeepCamBFromBlend", this ); }

                    var vcam = blend.CamB;
                    while (vcam != null) {
                        if (!vcam.Cinemachine$ICinemachineCamera$IsValid) {
                            return null; // deleted!
                        }

                        var bs = Bridge.as(vcam, Cinemachine.BlendSourceVirtualCamera);
                        if (bs == null) {
                            break;
                        }

                        vcam = bs.Blend.CamB;
                    }

                    return vcam;
                },
                /*Cinemachine.CinemachineBrain.DeepCamBFromBlend:static end.*/


            }
        },
        fields: {
            /**
             * When enabled, the current camera and blend will be indicated in the game window, for debugging.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @default false
             * @type boolean
             */
            m_ShowDebugText: false,
            /**
             * When enabled, shows the camera's frustum in the scene view.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @default true
             * @type boolean
             */
            m_ShowCameraFrustum: false,
            /**
             * When enabled, the cameras will always respond in real-time to user input and damping,
                 even if the game is running in slow motion
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @default false
             * @type boolean
             */
            m_IgnoreTimeScale: false,
            /**
             * If set, this object's Y axis will define the worldspace Up vector for all the
                 virtual cameras.  This is useful in top-down game environments.  If not set, Up is worldspace Y.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @type UnityEngine.Transform
             */
            m_WorldUpOverride: null,
            /**
             * Depending on how the target objects are animated, adjust the update method to
                 minimize the potential jitter.  Use FixedUpdate if all your targets are animated with for RigidBody animation.
                 SmartUpdate will choose the best method for each virtual camera, depending
                 on how the target is animated.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @type number
             */
            m_UpdateMethod: 0,
            /**
             * The update time for the Brain, i.e. when the blends are evaluated and the
                 brain's transform is updated.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @type number
             */
            m_BlendUpdateMethod: 0,
            /**
             * The blend which is used if you don't explicitly define a blend between two Virtual Cameras.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @type Cinemachine.CinemachineBlendDefinition
             */
            m_DefaultBlend: null,
            /**
             * This is the asset which contains custom settings for specific blends.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @type Cinemachine.CinemachineBlenderSettings
             */
            m_CustomBlends: null,
            m_OutputCamera: null,
            /**
             * This event will fire whenever a virtual camera goes live and there is no blend
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @type Cinemachine.CinemachineBrain.BrainEvent
             */
            m_CameraCutEvent: null,
            /**
             * This event will fire whenever a virtual camera goes live.  If a blend is involved,
                 then the event will fire on the first frame of the blend
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @type Cinemachine.CinemachineBrain.VcamActivatedEvent
             */
            m_CameraActivatedEvent: null,
            mPhysicsCoroutine: null,
            mWaitForFixedUpdate: null,
            mFrameStack: null,
            mNextFrameId: 0,
            mCurrentLiveCameras: null,
            mActiveCameraPreviousFrame: null,
            /**
             * The current state applied to the unity camera (may be the result of a blend)
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBrain
             * @function CurrentCameraState
             * @type Cinemachine.CameraState
             */
            CurrentCameraState: null
        },
        props: {
            /**
             * Get the Unity Camera that is attached to this GameObject.  This is the camera
                 that will be controlled by the brain.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBrain
             * @function OutputCamera
             * @type UnityEngine.Camera
             */
            OutputCamera: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#OutputCamera#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_OutputCamera, null) && !UnityEngine.Application.isPlaying) {
                        this.m_OutputCamera = this.GetComponent(UnityEngine.Camera);
                    }

                    return this.m_OutputCamera;
                }
            },
            /**
             * Get the default world up for the virtual cameras.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBrain
             * @function DefaultWorldUp
             * @type UnityEngine.Vector3
             */
            DefaultWorldUp: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#DefaultWorldUp#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.m_WorldUpOverride, null) ? this.m_WorldUpOverride.transform.up.$clone() : pc.Vec3.UP.clone();
                }
            },
            /**
             * Get the current active virtual camera.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBrain
             * @function ActiveVirtualCamera
             * @type Cinemachine.ICinemachineCamera
             */
            ActiveVirtualCamera: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#ActiveVirtualCamera#get", this ); }

                    if (Cinemachine.CinemachineBrain.SoloCamera != null) {
                        return Cinemachine.CinemachineBrain.SoloCamera;
                    }

                    return Cinemachine.CinemachineBrain.DeepCamBFromBlend(this.mCurrentLiveCameras);
                }
            },
            /**
             * Is there a blend in progress?
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBrain
             * @function IsBlending
             * @type boolean
             */
            IsBlending: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#IsBlending#get", this ); }

                    return this.ActiveBlend != null;
                }
            },
            /**
             * Get the current blend in progress.  Returns null if none.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBrain
             * @function ActiveBlend
             * @type Cinemachine.CinemachineBlend
             */
            ActiveBlend: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#ActiveBlend#get", this ); }

                    if (Cinemachine.CinemachineBrain.SoloCamera != null) {
                        return null;
                    }

                    if (this.mCurrentLiveCameras.CamA == null || this.mCurrentLiveCameras.IsComplete) {
                        return null;
                    }

                    return this.mCurrentLiveCameras;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#init", this ); }

                this.m_DefaultBlend = new Cinemachine.CinemachineBlendDefinition();
                this.CurrentCameraState = new Cinemachine.CameraState();
                this.m_ShowDebugText = false;
                this.m_ShowCameraFrustum = true;
                this.m_IgnoreTimeScale = false;
                this.m_UpdateMethod = Cinemachine.CinemachineBrain.UpdateMethod.SmartUpdate;
                this.m_BlendUpdateMethod = Cinemachine.CinemachineBrain.BrainUpdateMethod.LateUpdate;
                this.m_DefaultBlend = new Cinemachine.CinemachineBlendDefinition.$ctor1(Cinemachine.CinemachineBlendDefinition.Style.EaseInOut, 2.0);
                this.m_CameraCutEvent = new Cinemachine.CinemachineBrain.BrainEvent();
                this.m_CameraActivatedEvent = new Cinemachine.CinemachineBrain.VcamActivatedEvent();
                this.mWaitForFixedUpdate = new UnityEngine.WaitForFixedUpdate();
                this.mFrameStack = new (System.Collections.Generic.List$1(Cinemachine.CinemachineBrain.BrainFrame)).ctor();
                this.mNextFrameId = 1;
                this.mCurrentLiveCameras = new Cinemachine.CinemachineBlend(null, null, null, 0, 0);
            }
        },
        methods: {
            /*Cinemachine.CinemachineBrain.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#OnEnable", this ); }

                // Make sure there is a first stack frame
                if (this.mFrameStack.Count === 0) {
                    this.mFrameStack.add(new Cinemachine.CinemachineBrain.BrainFrame());
                }

                this.m_OutputCamera = this.GetComponent(UnityEngine.Camera);
                Cinemachine.CinemachineCore.Instance.AddActiveBrain(this);
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.remove(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.combine(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));

                // We check in after the physics system has had a chance to move things
                this.mPhysicsCoroutine = this.StartCoroutine$1(this.AfterPhysics());
            },
            /*Cinemachine.CinemachineBrain.OnEnable end.*/

            /*Cinemachine.CinemachineBrain.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#OnDisable", this ); }

                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.remove(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
                Cinemachine.CinemachineCore.Instance.RemoveActiveBrain(this);
                this.mFrameStack.clear();
                this.StopCoroutine$2(this.mPhysicsCoroutine);
            },
            /*Cinemachine.CinemachineBrain.OnDisable end.*/

            /*Cinemachine.CinemachineBrain.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#Start", this ); }

                this.UpdateVirtualCameras(Cinemachine.CinemachineCore.UpdateFilter.Late, -1.0);
            },
            /*Cinemachine.CinemachineBrain.Start end.*/

            /*Cinemachine.CinemachineBrain.OnGuiHandler start.*/
            OnGuiHandler: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#OnGuiHandler", this ); }

                if (!this.m_ShowDebugText) {
                    Cinemachine.Utility.CinemachineDebug.ReleaseScreenPos(this);
                } else {
                    // Show the active camera and blend
                    var sb = Cinemachine.Utility.CinemachineDebug.SBFromPool();
                    var color = UnityEngine.GUI.color.$clone();
                    sb.setLength(0);
                    sb.append("CM ");
                    sb.append(this.gameObject.name);
                    sb.append(": ");
                    if (Cinemachine.CinemachineBrain.SoloCamera != null) {
                        sb.append("SOLO ");
                        UnityEngine.GUI.color = Cinemachine.CinemachineBrain.GetSoloGUIColor();
                    }

                    if (this.IsBlending) {
                        sb.append(this.ActiveBlend.Description);
                    } else {
                        var vcam = this.ActiveVirtualCamera;
                        if (vcam == null) {
                            sb.append("(none)");
                        } else {
                            sb.append("[");
                            sb.append(vcam.Cinemachine$ICinemachineCamera$Name);
                            sb.append("]");
                        }
                    }

                    var text = sb.toString();
                    var r = Cinemachine.Utility.CinemachineDebug.GetScreenPos(this, text, UnityEngine.GUI.skin.box);
                    UnityEngine.GUI.Label$1(r.$clone(), text, UnityEngine.GUI.skin.box);
                    UnityEngine.GUI.color = color.$clone();
                    Cinemachine.Utility.CinemachineDebug.ReturnToPool(sb);
                }
            },
            /*Cinemachine.CinemachineBrain.OnGuiHandler end.*/

            /*Cinemachine.CinemachineBrain.AfterPhysics start.*/
            AfterPhysics: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#AfterPhysics", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    filter,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    // FixedUpdate can be called multiple times per frame
                                        $enumerator.current = this.mWaitForFixedUpdate;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    if (this.m_UpdateMethod !== Cinemachine.CinemachineBrain.UpdateMethod.LateUpdate) {
                                            filter = Cinemachine.CinemachineCore.UpdateFilter.Fixed;
                                            if (this.m_UpdateMethod === Cinemachine.CinemachineBrain.UpdateMethod.SmartUpdate) {
                                                // Track the targets
                                                Cinemachine.UpdateTracker.OnUpdate(Cinemachine.UpdateTracker.UpdateClock.Fixed);
                                                filter = Cinemachine.CinemachineCore.UpdateFilter.SmartFixed;
                                            }

                                            this.UpdateVirtualCameras(filter, this.GetEffectiveDeltaTime(true));
                                        }

                                        // Choose the active vcam and apply it to the Unity camera
                                        if (this.m_BlendUpdateMethod === Cinemachine.CinemachineBrain.BrainUpdateMethod.FixedUpdate) {
                                            this.ProcessActiveCamera(UnityEngine.Time.fixedDeltaTime);
                                        }

                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Cinemachine.CinemachineBrain.AfterPhysics end.*/

            /*Cinemachine.CinemachineBrain.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#LateUpdate", this ); }

                var deltaTime = this.GetEffectiveDeltaTime(false);
                this.UpdateFrame0(deltaTime);
                this.UpdateCurrentLiveCameras();

                if (this.m_UpdateMethod === Cinemachine.CinemachineBrain.UpdateMethod.FixedUpdate) {
                    // Special handling for fixed update: cameras that have been enabled
                    // since the last physics frame must be updated now
                    if (this.m_BlendUpdateMethod !== Cinemachine.CinemachineBrain.BrainUpdateMethod.FixedUpdate) {
                        Cinemachine.CinemachineCore.Instance.CurrentUpdateFilter = Cinemachine.CinemachineCore.UpdateFilter.Fixed;
                        if (Cinemachine.CinemachineBrain.SoloCamera != null) {
                            Cinemachine.CinemachineBrain.SoloCamera.Cinemachine$ICinemachineCamera$UpdateCameraState(this.DefaultWorldUp.$clone(), deltaTime);
                        }

                        this.mCurrentLiveCameras.UpdateCameraState(this.DefaultWorldUp.$clone(), deltaTime);
                    }
                } else {
                    var filter = Cinemachine.CinemachineCore.UpdateFilter.Late;
                    if (this.m_UpdateMethod === Cinemachine.CinemachineBrain.UpdateMethod.SmartUpdate) {
                        // Track the targets
                        Cinemachine.UpdateTracker.OnUpdate(Cinemachine.UpdateTracker.UpdateClock.Late);
                        filter = Cinemachine.CinemachineCore.UpdateFilter.SmartLate;
                    }

                    this.UpdateVirtualCameras(filter, deltaTime);
                }

                // Choose the active vcam and apply it to the Unity camera
                if (this.m_BlendUpdateMethod === Cinemachine.CinemachineBrain.BrainUpdateMethod.LateUpdate) {
                    this.ProcessActiveCamera(deltaTime);
                }
            },
            /*Cinemachine.CinemachineBrain.LateUpdate end.*/

            /*Cinemachine.CinemachineBrain.GetEffectiveDeltaTime start.*/
            GetEffectiveDeltaTime: function (fixedDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#GetEffectiveDeltaTime", this ); }

                if (UnityEngine.Application.isPlaying && Cinemachine.CinemachineCore.UniformDeltaTimeOverride >= 0) {
                    return Cinemachine.CinemachineCore.UniformDeltaTimeOverride;
                }

                if (Cinemachine.CinemachineBrain.SoloCamera != null) {
                    return UnityEngine.Time.unscaledDeltaTime;
                }

                if (!UnityEngine.Application.isPlaying) {
                    for (var i = this.mFrameStack.Count - 1; i > 0; --i) {
                        var frame = this.mFrameStack.getItem(i);
                        if (frame.Active) {
                            return frame.TimeOverrideExpired ? -1 : frame.deltaTimeOverride;
                        }
                    }

                    return -1;
                }

                if (this.m_IgnoreTimeScale) {
                    return fixedDelta ? UnityEngine.Time.fixedDeltaTime : UnityEngine.Time.unscaledDeltaTime;
                }

                return fixedDelta ? UnityEngine.Time.fixedDeltaTime : UnityEngine.Time.deltaTime;
            },
            /*Cinemachine.CinemachineBrain.GetEffectiveDeltaTime end.*/

            /*Cinemachine.CinemachineBrain.UpdateVirtualCameras start.*/
            UpdateVirtualCameras: function (updateFilter, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#UpdateVirtualCameras", this ); }

                // We always update all active virtual cameras
                Cinemachine.CinemachineCore.Instance.CurrentUpdateFilter = updateFilter;
                var camera = this.OutputCamera;
                Cinemachine.CinemachineCore.Instance.UpdateAllActiveVirtualCameras(UnityEngine.Component.op_Equality(camera, null) ? -1 : camera.cullingMask, this.DefaultWorldUp.$clone(), deltaTime);

                // Make sure all live cameras get updated, in case some of them are deactivated
                if (Cinemachine.CinemachineBrain.SoloCamera != null) {
                    Cinemachine.CinemachineBrain.SoloCamera.Cinemachine$ICinemachineCamera$UpdateCameraState(this.DefaultWorldUp.$clone(), deltaTime);
                }

                this.mCurrentLiveCameras.UpdateCameraState(this.DefaultWorldUp.$clone(), deltaTime);

                // Restore the filter for general use
                updateFilter = Cinemachine.CinemachineCore.UpdateFilter.Late;
                if (UnityEngine.Application.isPlaying) {
                    if (this.m_UpdateMethod === Cinemachine.CinemachineBrain.UpdateMethod.SmartUpdate) {
                        updateFilter |= Cinemachine.CinemachineCore.UpdateFilter.Smart;
                    } else if (this.m_UpdateMethod === Cinemachine.CinemachineBrain.UpdateMethod.FixedUpdate) {
                        updateFilter = Cinemachine.CinemachineCore.UpdateFilter.Fixed;
                    }
                }

                Cinemachine.CinemachineCore.Instance.CurrentUpdateFilter = updateFilter;
            },
            /*Cinemachine.CinemachineBrain.UpdateVirtualCameras end.*/

            /*Cinemachine.CinemachineBrain.GetBrainFrame start.*/
            /**
             * @instance
             * @private
             * @this Cinemachine.CinemachineBrain
             * @memberof Cinemachine.CinemachineBrain
             * @param   {number}    withId
             * @return  {number}
             */
            GetBrainFrame: function (withId) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#GetBrainFrame", this ); }

                var $t;
                var count = this.mFrameStack.Count;
                for (var i = this.mFrameStack.Count - 1; i > 0; --i) {
                    if (this.mFrameStack.getItem(i).id === withId) {
                        return i;
                    }
                }

                // Not found - add it
                this.mFrameStack.add(($t = new Cinemachine.CinemachineBrain.BrainFrame(), $t.id = withId, $t));
                return this.mFrameStack.Count - 1;
            },
            /*Cinemachine.CinemachineBrain.GetBrainFrame end.*/

            /*Cinemachine.CinemachineBrain.SetCameraOverride start.*/
            /**
             * This API is specifically for Timeline.  Do not use it.
                 Override the current camera and current blend.  This setting will trump
                 any in-game logic that sets virtual camera priorities and Enabled states.
                 This is the main API for the timeline.
             *
             * @instance
             * @this Cinemachine.CinemachineBrain
             * @memberof Cinemachine.CinemachineBrain
             * @param   {number}                            overrideId    Id to represent a specific client.  An internal
                 stack is maintained, with the most recent non-empty override taking precenence.
                 This id must be &gt; 0.  If you pass -1, a new id will be created, and returned.
                 Use that id for subsequent calls.  Don't forget to
                 call ReleaseCameraOverride after all overriding is finished, to
                 free the OverideStack resources.
             * @param   {Cinemachine.ICinemachineCamera}    camA          The camera to set, corresponding to weight=0
             * @param   {Cinemachine.ICinemachineCamera}    camB          The camera to set, corresponding to weight=1
             * @param   {number}                            weightB       The blend weight.  0=camA, 1=camB
             * @param   {number}                            deltaTime     override for deltaTime.  Should be Time.FixedDelta for
                 time-based calculations to be included, -1 otherwise
             * @return  {number}                                          The oiverride ID.  Don't forget to call ReleaseCameraOverride
                 after all overriding is finished, to free the OverideStack resources.
             */
            SetCameraOverride: function (overrideId, camA, camB, weightB, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#SetCameraOverride", this ); }

                if (overrideId < 0) {
                    overrideId = this.mNextFrameId++;
                }

                var frame = this.mFrameStack.getItem(this.GetBrainFrame(overrideId));
                frame.deltaTimeOverride = deltaTime;
                frame.timeOfOverride = UnityEngine.Time.realtimeSinceStartup;
                frame.blend.CamA = camA;
                frame.blend.CamB = camB;
                frame.blend.BlendCurve = pc.AnimationCurve.createLinear(0, 0, 1, 1);
                frame.blend.Duration = 1;
                frame.blend.TimeInBlend = weightB;

                return overrideId;
            },
            /*Cinemachine.CinemachineBrain.SetCameraOverride end.*/

            /*Cinemachine.CinemachineBrain.ReleaseCameraOverride start.*/
            /**
             * This API is specifically for Timeline.  Do not use it.
                 Release the resources used for a camera override client.
                 See SetCameraOverride.
             *
             * @instance
             * @this Cinemachine.CinemachineBrain
             * @memberof Cinemachine.CinemachineBrain
             * @param   {number}    overrideId    The ID to released.  This is the value that
                 was returned by SetCameraOverride
             * @return  {void}
             */
            ReleaseCameraOverride: function (overrideId) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#ReleaseCameraOverride", this ); }

                for (var i = this.mFrameStack.Count - 1; i > 0; --i) {
                    if (this.mFrameStack.getItem(i).id === overrideId) {
                        this.mFrameStack.removeAt(i);
                        return;
                    }
                }
            },
            /*Cinemachine.CinemachineBrain.ReleaseCameraOverride end.*/

            /*Cinemachine.CinemachineBrain.ProcessActiveCamera start.*/
            ProcessActiveCamera: function (deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#ProcessActiveCamera", this ); }

                var activeCamera = this.ActiveVirtualCamera;
                if (activeCamera != null) {
                    // Has the current camera changed this frame?
                    if (!Bridge.referenceEquals(activeCamera, this.mActiveCameraPreviousFrame)) {
                        // Notify incoming camera of transition
                        activeCamera.Cinemachine$ICinemachineCamera$OnTransitionFromCamera(this.mActiveCameraPreviousFrame, this.DefaultWorldUp.$clone(), deltaTime);
                        if (this.m_CameraActivatedEvent != null) {
                            this.m_CameraActivatedEvent.Invoke(activeCamera, this.mActiveCameraPreviousFrame);
                        }

                        // If we're cutting without a blend, send an event
                        if (!this.IsBlending || this.mActiveCameraPreviousFrame != null && !this.ActiveBlend.Uses(this.mActiveCameraPreviousFrame)) {
                            if (this.m_CameraCutEvent != null) {
                                this.m_CameraCutEvent.Invoke(this);
                            }

                            if (Cinemachine.CinemachineCore.CameraCutEvent != null) {
                                Cinemachine.CinemachineCore.CameraCutEvent.Invoke(this);
                            }
                        }

                        // Re-update in case it's inactive
                        activeCamera.Cinemachine$ICinemachineCamera$UpdateCameraState(this.DefaultWorldUp.$clone(), deltaTime);
                    }

                    // Apply the vcam state to the Unity camera
                    this.PushStateToUnityCamera(Cinemachine.CinemachineBrain.SoloCamera != null ? Cinemachine.CinemachineBrain.SoloCamera.Cinemachine$ICinemachineCamera$State.$clone() : this.mCurrentLiveCameras.State.$clone());
                }

                this.mActiveCameraPreviousFrame = activeCamera;
            },
            /*Cinemachine.CinemachineBrain.ProcessActiveCamera end.*/

            /*Cinemachine.CinemachineBrain.UpdateFrame0 start.*/
            UpdateFrame0: function (deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#UpdateFrame0", this ); }

                // Update the in-game frame (frame 0)
                var frame = this.mFrameStack.getItem(0);

                // Are we transitioning cameras?
                var activeCamera = this.TopCameraFromPriorityQueue();
                var outGoingCamera = frame.blend.CamB;
                if (!Bridge.referenceEquals(activeCamera, outGoingCamera)) {
                    // Do we need to create a game-play blend?
                    if (Bridge.cast(activeCamera, UnityEngine.Object) != null && Bridge.cast(outGoingCamera, UnityEngine.Object) != null && deltaTime >= 0) {
                        // Create a blend (curve will be null if a cut)
                        var blendDef = this.LookupBlend(outGoingCamera, activeCamera);
                        if (blendDef.BlendCurve != null && blendDef.m_Time > 0) {
                            if (frame.blend.IsComplete) {
                                frame.blend.CamA = outGoingCamera; // new blend
                            } else {
                                // Special case: if backing out of a blend-in-progress
                                // with the same blend in reverse, adjust the belnd time
                                if (Bridge.referenceEquals(frame.blend.CamA, activeCamera) && Bridge.referenceEquals(frame.blend.CamB, outGoingCamera) && frame.blend.Duration <= blendDef.m_Time) {
                                    blendDef.m_Time = frame.blend.TimeInBlend;
                                }

                                // Chain to existing blend
                                frame.blend.CamA = new Cinemachine.BlendSourceVirtualCamera(new Cinemachine.CinemachineBlend(frame.blend.CamA, frame.blend.CamB, frame.blend.BlendCurve, frame.blend.Duration, frame.blend.TimeInBlend));
                            }
                        }

                        frame.blend.BlendCurve = blendDef.BlendCurve;
                        frame.blend.Duration = blendDef.m_Time;
                        frame.blend.TimeInBlend = 0;
                    }

                    // Set the current active camera
                    frame.blend.CamB = activeCamera;
                }

                // Advance the current blend (if any)
                if (frame.blend.CamA != null) {
                    frame.blend.TimeInBlend += deltaTime >= 0 ? deltaTime : frame.blend.Duration;
                    if (frame.blend.IsComplete) {
                        // No more blend
                        frame.blend.CamA = null;
                        frame.blend.BlendCurve = null;
                        frame.blend.Duration = 0;
                        frame.blend.TimeInBlend = 0;
                    }
                }
            },
            /*Cinemachine.CinemachineBrain.UpdateFrame0 end.*/

            /*Cinemachine.CinemachineBrain.UpdateCurrentLiveCameras start.*/
            UpdateCurrentLiveCameras: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#UpdateCurrentLiveCameras", this ); }

                // Resolve the current working frame states in the stack
                var lastActive = 0;
                for (var i = 0; i < this.mFrameStack.Count; ++i) {
                    var frame = this.mFrameStack.getItem(i);
                    if (i === 0 || frame.Active) {
                        frame.workingBlend.CamA = frame.blend.CamA;
                        frame.workingBlend.CamB = frame.blend.CamB;
                        frame.workingBlend.BlendCurve = frame.blend.BlendCurve;
                        frame.workingBlend.Duration = frame.blend.Duration;
                        frame.workingBlend.TimeInBlend = frame.blend.TimeInBlend;
                        if (i > 0 && !frame.blend.IsComplete) {
                            if (frame.workingBlend.CamA == null) {
                                if (this.mFrameStack.getItem(lastActive).blend.IsComplete) {
                                    frame.workingBlend.CamA = this.mFrameStack.getItem(lastActive).blend.CamB;
                                } else {
                                    frame.workingBlendSource.Blend = this.mFrameStack.getItem(lastActive).workingBlend;
                                    frame.workingBlend.CamA = frame.workingBlendSource;
                                }
                            } else if (frame.workingBlend.CamB == null) {
                                if (this.mFrameStack.getItem(lastActive).blend.IsComplete) {
                                    frame.workingBlend.CamB = this.mFrameStack.getItem(lastActive).blend.CamB;
                                } else {
                                    frame.workingBlendSource.Blend = this.mFrameStack.getItem(lastActive).workingBlend;
                                    frame.workingBlend.CamB = frame.workingBlendSource;
                                }
                            }
                        }

                        lastActive = i;
                    }
                }

                var workingBlend = this.mFrameStack.getItem(lastActive).workingBlend;
                this.mCurrentLiveCameras.CamA = workingBlend.CamA;
                this.mCurrentLiveCameras.CamB = workingBlend.CamB;
                this.mCurrentLiveCameras.BlendCurve = workingBlend.BlendCurve;
                this.mCurrentLiveCameras.Duration = workingBlend.Duration;
                this.mCurrentLiveCameras.TimeInBlend = workingBlend.TimeInBlend;
            },
            /*Cinemachine.CinemachineBrain.UpdateCurrentLiveCameras end.*/

            /*Cinemachine.CinemachineBrain.IsLive start.*/
            /**
             * True if the ICinemachineCamera the current active camera,
                 or part of a current blend, either directly or indirectly because its parents are live.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineBrain
             * @memberof Cinemachine.CinemachineBrain
             * @param   {Cinemachine.ICinemachineCamera}    vcam                 The camera to test whether it is live
             * @param   {boolean}                           dominantChildOnly    If truw, will only return true if this vcam is the dominat live child
             * @return  {boolean}                                                True if the camera is live (directly or indirectly)
                 or part of a blend in progress.
             */
            IsLive: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#IsLive", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                if (Bridge.referenceEquals(Cinemachine.CinemachineBrain.SoloCamera, vcam)) {
                    return true;
                }

                if (this.mCurrentLiveCameras.Uses(vcam)) {
                    return true;
                }

                var parent = vcam.Cinemachine$ICinemachineCamera$ParentCamera;
                while (parent != null && parent.Cinemachine$ICinemachineCamera$IsLiveChild(vcam, dominantChildOnly)) {
                    if (Bridge.referenceEquals(Cinemachine.CinemachineBrain.SoloCamera, parent) || this.mCurrentLiveCameras.Uses(parent)) {
                        return true;
                    }

                    vcam = parent;
                    parent = vcam.Cinemachine$ICinemachineCamera$ParentCamera;
                }

                return false;
            },
            /*Cinemachine.CinemachineBrain.IsLive end.*/

            /*Cinemachine.CinemachineBrain.TopCameraFromPriorityQueue start.*/
            /**
             * Get the highest-priority Enabled ICinemachineCamera
                 that is visible to my camera.  Culling Mask is used to test visibility.
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineBrain
             * @memberof Cinemachine.CinemachineBrain
             * @return  {Cinemachine.ICinemachineCamera}
             */
            TopCameraFromPriorityQueue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#TopCameraFromPriorityQueue", this ); }

                var core = Cinemachine.CinemachineCore.Instance;
                var outputCamera = this.OutputCamera;
                var mask = UnityEngine.Component.op_Equality(outputCamera, null) ? -1 : outputCamera.cullingMask;
                var numCameras = core.VirtualCameraCount;
                for (var i = 0; i < numCameras; ++i) {
                    var cam = core.GetVirtualCamera(i);
                    var go = UnityEngine.MonoBehaviour.op_Inequality(cam, null) ? cam.gameObject : null;
                    if (UnityEngine.GameObject.op_Inequality(go, null) && (mask & (1 << go.layer)) !== 0) {
                        return cam;
                    }
                }

                return null;
            },
            /*Cinemachine.CinemachineBrain.TopCameraFromPriorityQueue end.*/

            /*Cinemachine.CinemachineBrain.LookupBlend start.*/
            /**
             * Create a blend curve for blending from one ICinemachineCamera to another.
                 If there is a specific blend defined for these cameras it will be used, otherwise
                 a default blend will be created, which could be a cut.
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineBrain
             * @memberof Cinemachine.CinemachineBrain
             * @param   {Cinemachine.ICinemachineCamera}            fromKey    
             * @param   {Cinemachine.ICinemachineCamera}            toKey
             * @return  {Cinemachine.CinemachineBlendDefinition}
             */
            LookupBlend: function (fromKey, toKey) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#LookupBlend", this ); }

                // Get the blend curve that's most appropriate for these cameras
                var blend = this.m_DefaultBlend.$clone();
                if (this.m_CustomBlends != null) {
                    var fromCameraName = fromKey != null ? fromKey.Cinemachine$ICinemachineCamera$Name : "";
                    var toCameraName = toKey != null ? toKey.Cinemachine$ICinemachineCamera$Name : "";
                    blend = this.m_CustomBlends.GetBlendForVirtualCameras(fromCameraName, toCameraName, blend.$clone());
                }

                if (!Bridge.staticEquals(Cinemachine.CinemachineCore.GetBlendOverride, null)) {
                    blend = Cinemachine.CinemachineCore.GetBlendOverride(fromKey, toKey, blend.$clone(), this);
                }

                return blend.$clone();
            },
            /*Cinemachine.CinemachineBrain.LookupBlend end.*/

            /*Cinemachine.CinemachineBrain.PushStateToUnityCamera start.*/
            /**
             * Apply a cref="CameraState"/&gt; to the game object
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineBrain
             * @memberof Cinemachine.CinemachineBrain
             * @param   {Cinemachine.CameraState}    state
             * @return  {void}
             */
            PushStateToUnityCamera: function (state) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain#PushStateToUnityCamera", this ); }

                this.CurrentCameraState = state.$clone();
                if ((state.BlendHint & Cinemachine.CameraState.BlendHintValue.NoPosition) === 0) {
                    this.transform.position = state.FinalPosition.$clone();
                }

                if ((state.BlendHint & Cinemachine.CameraState.BlendHintValue.NoOrientation) === 0) {
                    this.transform.rotation = state.FinalOrientation.$clone();
                }

                if ((state.BlendHint & Cinemachine.CameraState.BlendHintValue.NoLens) === 0) {
                    var cam = this.OutputCamera;
                    if (UnityEngine.Component.op_Inequality(cam, null)) {
                        cam.nearClipPlane = state.Lens.NearClipPlane;
                        cam.farClipPlane = state.Lens.FarClipPlane;
                        cam.fieldOfView = state.Lens.FieldOfView;
                        if (cam.orthographic) {
                            cam.orthographicSize = state.Lens.OrthographicSize;
                        }
                    }
                }

                if (Cinemachine.CinemachineCore.CameraUpdatedEvent != null) {
                    Cinemachine.CinemachineCore.CameraUpdatedEvent.Invoke(this);
                }
            },
            /*Cinemachine.CinemachineBrain.PushStateToUnityCamera end.*/


        }
    });
    /*Cinemachine.CinemachineBrain end.*/

    /*Cinemachine.CinemachineBrain+BrainFrame start.*/
    Bridge.define("Cinemachine.CinemachineBrain.BrainFrame", {
        $kind: "nested class",
        fields: {
            blend: null,
            deltaTimeOverride: 0,
            id: 0,
            timeOfOverride: 0,
            workingBlend: null,
            workingBlendSource: null
        },
        props: {
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain.BrainFrame#Active#get", this ); }

                    return this.blend.IsValid;
                }
            },
            TimeOverrideExpired: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain.BrainFrame#TimeOverrideExpired#get", this ); }

                    return UnityEngine.Time.realtimeSinceStartup - this.timeOfOverride > UnityEngine.Time.maximumDeltaTime;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBrain.BrainFrame#init", this ); }

                this.blend = new Cinemachine.CinemachineBlend(null, null, null, 0, 0);
                this.workingBlend = new Cinemachine.CinemachineBlend(null, null, null, 0, 0);
                this.workingBlendSource = new Cinemachine.BlendSourceVirtualCamera(null);
            }
        }
    });
    /*Cinemachine.CinemachineBrain+BrainFrame end.*/

    /*Cinemachine.CinemachineBrain+BrainUpdateMethod start.*/
    /**
     * This enum defines the options available for the update method.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineBrain.BrainUpdateMethod", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Camera is updated in sync with the Physics module, in FixedUpdate
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                FixedUpdate: 0,
                /**
                 * Camera is updated in MonoBehaviour LateUpdate.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                LateUpdate: 1
            }
        }
    });
    /*Cinemachine.CinemachineBrain+BrainUpdateMethod end.*/

    /*Cinemachine.CinemachineBrain+UpdateMethod start.*/
    /**
     * This enum defines the options available for the update method.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineBrain.UpdateMethod", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Virtual cameras are updated in sync with the Physics module, in FixedUpdate
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                FixedUpdate: 0,
                /**
                 * Virtual cameras are updated in MonoBehaviour LateUpdate.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                LateUpdate: 1,
                /**
                 * Virtual cameras are updated according to how the target is updated.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                SmartUpdate: 2
            }
        }
    });
    /*Cinemachine.CinemachineBrain+UpdateMethod end.*/

    /*Cinemachine.CinemachineClearShot+Pair start.*/
    Bridge.define("Cinemachine.CinemachineClearShot.Pair", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot.Pair#getDefaultValue", this ); }
 return new Cinemachine.CinemachineClearShot.Pair(); }
            }
        },
        fields: {
            a: 0,
            b: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot.Pair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot.Pair#getHashCode", this ); }

                var h = Bridge.addHash([1919508816, this.a, this.b]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot.Pair#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineClearShot.Pair)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot.Pair#$clone", this ); }

                var s = to || new Cinemachine.CinemachineClearShot.Pair();
                s.a = this.a;
                s.b = this.b;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineClearShot+Pair end.*/

    /*Cinemachine.CinemachineExtension start.*/
    /**
     * Base class for a Cinemachine Virtual Camera extension module.
         Hooks into the Cinemachine Pipeline.
     *
     * @abstract
     * @public
     * @class Cinemachine.CinemachineExtension
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachineExtension", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                /**
                 * Useful constant for very small floats
                 *
                 * @static
                 * @protected
                 * @memberof Cinemachine.CinemachineExtension
                 * @constant
                 * @default 0.0001
                 * @type number
                 */
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#init", this ); }

                    this.Epsilon = 0.0001;
                }
            }
        },
        fields: {
            m_vcamOwner: null,
            mExtraState: null
        },
        props: {
            /**
             * Get the associated CinemachineVirtualCameraBase
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineExtension
             * @function VirtualCamera
             * @type Cinemachine.CinemachineVirtualCameraBase
             */
            VirtualCamera: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#VirtualCamera#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_vcamOwner, null)) {
                        this.m_vcamOwner = this.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                    }

                    return this.m_vcamOwner;
                }
            }
        },
        methods: {
            /*Cinemachine.CinemachineExtension.Awake start.*/
            /**
             * Connect to virtual camera pipeline.
                 Override implementations must call this base implementation
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineExtension
             * @memberof Cinemachine.CinemachineExtension
             * @return  {void}
             */
            Awake: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#Awake", this ); }

                this.ConnectToVcam(true);
            },
            /*Cinemachine.CinemachineExtension.Awake end.*/

            /*Cinemachine.CinemachineExtension.OnDestroy start.*/
            /**
             * Disconnect from virtual camera pipeline.
                 Override implementations must call this base implementation
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineExtension
             * @memberof Cinemachine.CinemachineExtension
             * @return  {void}
             */
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#OnDestroy", this ); }

                this.ConnectToVcam(false);
            },
            /*Cinemachine.CinemachineExtension.OnDestroy end.*/

            /*Cinemachine.CinemachineExtension.ConnectToVcam start.*/
            /**
             * Connect to virtual camera.  Implementation must be safe to be called
                 redundantly.  Override implementations must call this base implementation
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineExtension
             * @memberof Cinemachine.CinemachineExtension
             * @param   {boolean}    connect    True if connectinf, false if disconnecting
             * @return  {void}
             */
            ConnectToVcam: function (connect) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#ConnectToVcam", this ); }

                if (connect && UnityEngine.MonoBehaviour.op_Equality(this.VirtualCamera, null)) {
                    UnityEngine.Debug.LogError$2("CinemachineExtension requires a Cinemachine Virtual Camera component");
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.VirtualCamera, null)) {
                    if (connect) {
                        this.VirtualCamera.AddExtension(this);
                    } else {
                        this.VirtualCamera.RemoveExtension(this);
                    }
                }

                this.mExtraState = null;
            },
            /*Cinemachine.CinemachineExtension.ConnectToVcam end.*/

            /*Cinemachine.CinemachineExtension.InvokePostPipelineStageCallback start.*/
            /**
             * Legacy support.  This is only here to avoid changing the API
                 to make PostPipelineStageCallback() public
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineExtension
             * @memberof Cinemachine.CinemachineExtension
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam         
             * @param   {number}                                      stage        
             * @param   {Cinemachine.CameraState}                     state        
             * @param   {number}                                      deltaTime
             * @return  {void}
             */
            InvokePostPipelineStageCallback: function (vcam, stage, state, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#InvokePostPipelineStageCallback", this ); }

                this.PostPipelineStageCallback(vcam, stage, state, deltaTime);
            },
            /*Cinemachine.CinemachineExtension.InvokePostPipelineStageCallback end.*/

            /*Cinemachine.CinemachineExtension.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the extension that a target got warped,
                 so that the extension can update its internal state to make the camera
                 also warp seamlessy.  Base class implementation does nothing.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineExtension
             * @memberof Cinemachine.CinemachineExtension
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#OnTargetObjectWarped", this ); }
 },
            /*Cinemachine.CinemachineExtension.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineExtension.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
                 Base class implementation must be called by any overridden method.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineExtension
             * @memberof Cinemachine.CinemachineExtension
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}               worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                            deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {boolean}                                        True to request a vcam update of internal state
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#OnTransitionFromCamera", this ); }

                return false;
            },
            /*Cinemachine.CinemachineExtension.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineExtension.GetExtraState start.*/
            /**
             * Because extensions can be placed on manager cams and will in that
                 case be called for all the vcam children, vcam-specific state information
                 should be stored here.  Just define a class to hold your state info
                 and use it exclusively when calling this.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineExtension
             * @memberof Cinemachine.CinemachineExtension
             * @param   {Function}                          T       
             * @param   {Cinemachine.ICinemachineCamera}    vcam
             * @return  {T}
             */
            GetExtraState: function (T, vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#GetExtraState", this ); }

                var $t;
                if (this.mExtraState == null) {
                    this.mExtraState = new (System.Collections.Generic.Dictionary$2(Cinemachine.ICinemachineCamera,System.Object)).ctor();
                }

                var extra = { v : null };
                if (!this.mExtraState.tryGetValue(vcam, extra)) {
                    extra.v = ($t = Bridge.createInstance(T), this.mExtraState.setItem(vcam, $t), $t);
                }

                return Bridge.as(extra.v, T);
            },
            /*Cinemachine.CinemachineExtension.GetExtraState end.*/

            /*Cinemachine.CinemachineExtension.GetAllExtraStates start.*/
            /**
             * Ineffeicient method to get all extra state infor for all vcams.
                 Intended for Editor use only, not runtime!
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineExtension
             * @memberof Cinemachine.CinemachineExtension
             * @param   {Function}                             T
             * @return  {System.Collections.Generic.List$1}
             */
            GetAllExtraStates: function (T) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExtension#GetAllExtraStates", this ); }

                var $t;
                var list = new (System.Collections.Generic.List$1(T)).ctor();
                if (this.mExtraState != null) {
                    $t = Bridge.getEnumerator(this.mExtraState);
                    try {
                        while ($t.moveNext()) {
                            var v = $t.Current;
                            list.add(Bridge.as(v.value, T));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                return list;
            },
            /*Cinemachine.CinemachineExtension.GetAllExtraStates end.*/


        }
    });
    /*Cinemachine.CinemachineExtension end.*/

    /*Cinemachine.CinemachineCollider+ResolutionStrategy start.*/
    /**
     * The way in which the Collider will attempt to preserve sight of the target.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineCollider.ResolutionStrategy", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Camera will be pulled forward along its Z axis until it is in front of
                     the nearest obstacle
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                PullCameraForward: 0,
                /**
                 * In addition to pulling the camera forward, an effort will be made to
                     return the camera to its original height
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                PreserveCameraHeight: 1,
                /**
                 * In addition to pulling the camera forward, an effort will be made to
                     return the camera to its original distance from the target
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                PreserveCameraDistance: 2
            }
        }
    });
    /*Cinemachine.CinemachineCollider+ResolutionStrategy end.*/

    /*Cinemachine.CinemachineCollider+VcamExtraState start.*/
    /**
     * Per-vcam extra state info
     *
     * @private
     * @class Cinemachine.CinemachineCollider.VcamExtraState
     */
    Bridge.define("Cinemachine.CinemachineCollider.VcamExtraState", {
        $kind: "nested class",
        fields: {
            colliderDisplacement: 0,
            debugResolutionPath: null,
            m_previousDisplacement: null,
            m_previousDisplacementCorrection: null,
            m_SmoothedDistance: 0,
            m_SmoothedTime: 0,
            occlusionStartTime: 0,
            targetObscured: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider.VcamExtraState#init", this ); }

                this.m_previousDisplacement = new UnityEngine.Vector3();
                this.m_previousDisplacementCorrection = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*Cinemachine.CinemachineCollider+VcamExtraState.AddPointToDebugPath start.*/
            AddPointToDebugPath: function (p) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider.VcamExtraState#AddPointToDebugPath", this ); }
 },
            /*Cinemachine.CinemachineCollider+VcamExtraState.AddPointToDebugPath end.*/

            /*Cinemachine.CinemachineCollider+VcamExtraState.ApplyDistanceSmoothing start.*/
            ApplyDistanceSmoothing: function (distance, smoothingTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider.VcamExtraState#ApplyDistanceSmoothing", this ); }

                if (this.m_SmoothedTime !== 0 && smoothingTime > Cinemachine.CinemachineExtension.Epsilon) {
                    var now = UnityEngine.Time.timeSinceLevelLoad;
                    if (now - this.m_SmoothedTime < smoothingTime) {
                        return UnityEngine.Mathf.Min(distance, this.m_SmoothedDistance);
                    }
                }

                return distance;
            },
            /*Cinemachine.CinemachineCollider+VcamExtraState.ApplyDistanceSmoothing end.*/

            /*Cinemachine.CinemachineCollider+VcamExtraState.UpdateDistanceSmoothing start.*/
            UpdateDistanceSmoothing: function (distance, smoothingTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider.VcamExtraState#UpdateDistanceSmoothing", this ); }

                var now = UnityEngine.Time.timeSinceLevelLoad;
                if (this.m_SmoothedDistance === 0 || distance <= this.m_SmoothedDistance) {
                    this.m_SmoothedDistance = distance;
                    this.m_SmoothedTime = now;
                }
            },
            /*Cinemachine.CinemachineCollider+VcamExtraState.UpdateDistanceSmoothing end.*/

            /*Cinemachine.CinemachineCollider+VcamExtraState.ResetDistanceSmoothing start.*/
            ResetDistanceSmoothing: function (smoothingTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider.VcamExtraState#ResetDistanceSmoothing", this ); }

                var now = UnityEngine.Time.timeSinceLevelLoad;
                if (now - this.m_SmoothedTime >= smoothingTime) {
                    this.m_SmoothedDistance = (this.m_SmoothedTime = 0);
                }
            },
            /*Cinemachine.CinemachineCollider+VcamExtraState.ResetDistanceSmoothing end.*/


        }
    });
    /*Cinemachine.CinemachineCollider+VcamExtraState end.*/

    /*Cinemachine.CinemachineImpulseSource start.*/
    /**
     * An event-driven class that broadcasts an impulse signal to listeners.
         This is the base class for custom impulse sources.  It contains an impulse
         definition, where the characteristics of the impulse signal are defined.
         API methods are fined for actually broadcasting the impulse.  Call these
         methods from your custom code, or hook them up to game events in the Editor.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseSource
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachineImpulseSource", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            /**
             * This defines the complete impulse signal that will be broadcast.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseSource
             * @type Cinemachine.CinemachineImpulseDefinition
             */
            m_ImpulseDefinition: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseSource#init", this ); }

                this.m_ImpulseDefinition = new Cinemachine.CinemachineImpulseDefinition();
            }
        },
        methods: {
            /*Cinemachine.CinemachineImpulseSource.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseSource#OnValidate", this ); }

                this.m_ImpulseDefinition.OnValidate();
            },
            /*Cinemachine.CinemachineImpulseSource.OnValidate end.*/

            /*Cinemachine.CinemachineImpulseSource.GenerateImpulseAt start.*/
            /**
             * Broadcast the Impulse Signal onto the appropriate channels,
                 using a custom position and impact velocity
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseSource
             * @memberof Cinemachine.CinemachineImpulseSource
             * @param   {UnityEngine.Vector3}    position    The world-space position from which the impulse will emanate
             * @param   {UnityEngine.Vector3}    velocity    The impact magnitude and direction
             * @return  {void}
             */
            GenerateImpulseAt: function (position, velocity) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseSource#GenerateImpulseAt", this ); }

                if (this.m_ImpulseDefinition != null) {
                    this.m_ImpulseDefinition.CreateEvent(position.$clone(), velocity.$clone());
                }
            },
            /*Cinemachine.CinemachineImpulseSource.GenerateImpulseAt end.*/

            /*Cinemachine.CinemachineImpulseSource.GenerateImpulse$1 start.*/
            /**
             * Broadcast the Impulse Signal onto the appropriate channels, using
                 a custom impact velocity, and this transfom's position.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseSource
             * @memberof Cinemachine.CinemachineImpulseSource
             * @param   {UnityEngine.Vector3}    velocity    The impact magnitude and direction
             * @return  {void}
             */
            GenerateImpulse$1: function (velocity) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseSource#GenerateImpulse$1", this ); }

                this.GenerateImpulseAt(this.transform.position.$clone(), velocity.$clone());
            },
            /*Cinemachine.CinemachineImpulseSource.GenerateImpulse$1 end.*/

            /*Cinemachine.CinemachineImpulseSource.GenerateImpulse start.*/
            /**
             * Broadcast the Impulse Signal onto the appropriate channels,
                 with default velocity = (0, -1, 0), and a default position which is
                 this transform's location.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseSource
             * @memberof Cinemachine.CinemachineImpulseSource
             * @return  {void}
             */
            GenerateImpulse: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseSource#GenerateImpulse", this ); }

                this.GenerateImpulse$1(pc.Vec3.DOWN.clone());
            },
            /*Cinemachine.CinemachineImpulseSource.GenerateImpulse end.*/


        },
        overloads: {
            "GenerateImpulse(Vector3)": "GenerateImpulse$1"
        }
    });
    /*Cinemachine.CinemachineImpulseSource end.*/

    /*Cinemachine.CinemachineComposer+FovCache start.*/
    Bridge.define("Cinemachine.CinemachineComposer.FovCache", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer.FovCache#getDefaultValue", this ); }
 return new Cinemachine.CinemachineComposer.FovCache(); }
            }
        },
        fields: {
            mFovSoftGuideRect: null,
            mFovHardGuideRect: null,
            mFovH: 0,
            mFov: 0,
            mOrthoSizeOverDistance: 0,
            mAspect: 0,
            mSoftGuideRect: null,
            mHardGuideRect: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer.FovCache#init", this ); }

                this.mFovSoftGuideRect = new UnityEngine.Rect();
                this.mFovHardGuideRect = new UnityEngine.Rect();
                this.mSoftGuideRect = new UnityEngine.Rect();
                this.mHardGuideRect = new UnityEngine.Rect();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer.FovCache#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.CinemachineComposer+FovCache.UpdateCache start.*/
            UpdateCache: function (lens, softGuide, hardGuide, targetDistance) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer.FovCache#UpdateCache", this ); }

                var recalculate = this.mAspect !== lens.Aspect || UnityEngine.Rect.op_Inequality(softGuide.$clone(), this.mSoftGuideRect.$clone()) || UnityEngine.Rect.op_Inequality(hardGuide.$clone(), this.mHardGuideRect.$clone());
                if (lens.Orthographic) {
                    var orthoOverDistance = Math.abs(lens.OrthographicSize / targetDistance);
                    if (this.mOrthoSizeOverDistance === 0 || Math.abs(orthoOverDistance - this.mOrthoSizeOverDistance) / this.mOrthoSizeOverDistance > this.mOrthoSizeOverDistance * 0.01) {
                        recalculate = true;
                    }

                    if (recalculate) {
                        // Calculate effective fov - fake it for ortho based on target distance
                        this.mFov = 114.59156 * Math.atan(orthoOverDistance);
                        this.mFovH = 114.59156 * Math.atan(lens.Aspect * orthoOverDistance);
                        this.mOrthoSizeOverDistance = orthoOverDistance;
                    }
                } else {
                    if (this.mFov !== lens.FieldOfView) {
                        recalculate = true;
                    }

                    if (recalculate) {
                        this.mFov = lens.FieldOfView;
                        var radHFOV = 2 * Math.atan(Math.tan(this.mFov * UnityEngine.Mathf.Deg2Rad / 2) * lens.Aspect);
                        this.mFovH = UnityEngine.Mathf.Rad2Deg * radHFOV;
                        this.mOrthoSizeOverDistance = 0;
                    }
                }

                if (recalculate) {
                    this.mFovSoftGuideRect = this.ScreenToFOV(softGuide.$clone(), this.mFov, this.mFovH, lens.Aspect);
                    this.mSoftGuideRect = softGuide.$clone();
                    this.mFovHardGuideRect = this.ScreenToFOV(hardGuide.$clone(), this.mFov, this.mFovH, lens.Aspect);
                    this.mHardGuideRect = hardGuide.$clone();
                    this.mAspect = lens.Aspect;
                }
            },
            /*Cinemachine.CinemachineComposer+FovCache.UpdateCache end.*/

            /*Cinemachine.CinemachineComposer+FovCache.ScreenToFOV start.*/
            ScreenToFOV: function (rScreen, fov, fovH, aspect) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer.FovCache#ScreenToFOV", this ); }

                var r = new UnityEngine.Rect.$ctor2(rScreen.$clone());
                var persp = new pc.Mat4().setPerspective( fov, aspect, 0.0001, 2.0, false ).clone().invert().$clone();

                var p = persp.multiplyPoint( new pc.Vec3( 0, r.yMin * 2.0 - 1.0, 0.5 ) );
                p.z = -p.z;
                var angle = Cinemachine.Utility.UnityVectorExtensions.SignedAngle(new pc.Vec3( 0, 0, 1 ), p.$clone(), pc.Vec3.LEFT.clone());
                r.yMin = (fov / 2 + angle) / fov;

                p = persp.multiplyPoint( new pc.Vec3( 0, r.yMax * 2.0 - 1.0, 0.5 ) );
                p.z = -p.z;
                angle = Cinemachine.Utility.UnityVectorExtensions.SignedAngle(new pc.Vec3( 0, 0, 1 ), p.$clone(), pc.Vec3.LEFT.clone());
                r.yMax = (fov / 2 + angle) / fov;

                p = persp.multiplyPoint( new pc.Vec3( r.xMin * 2.0 - 1.0, 0, 0.5 ) );
                p.z = -p.z;
                angle = Cinemachine.Utility.UnityVectorExtensions.SignedAngle(new pc.Vec3( 0, 0, 1 ), p.$clone(), pc.Vec3.UP.clone());
                r.xMin = (fovH / 2 + angle) / fovH;

                p = persp.multiplyPoint( new pc.Vec3( r.xMax * 2.0 - 1.0, 0, 0.5 ) );
                p.z = -p.z;
                angle = Cinemachine.Utility.UnityVectorExtensions.SignedAngle(new pc.Vec3( 0, 0, 1 ), p.$clone(), pc.Vec3.UP.clone());
                r.xMax = (fovH / 2 + angle) / fovH;
                return r.$clone();
            },
            /*Cinemachine.CinemachineComposer+FovCache.ScreenToFOV end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer.FovCache#getHashCode", this ); }

                var h = Bridge.addHash([2833175207, this.mFovSoftGuideRect, this.mFovHardGuideRect, this.mFovH, this.mFov, this.mOrthoSizeOverDistance, this.mAspect, this.mSoftGuideRect, this.mHardGuideRect]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer.FovCache#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineComposer.FovCache)) {
                    return false;
                }
                return Bridge.equals(this.mFovSoftGuideRect, o.mFovSoftGuideRect) && Bridge.equals(this.mFovHardGuideRect, o.mFovHardGuideRect) && Bridge.equals(this.mFovH, o.mFovH) && Bridge.equals(this.mFov, o.mFov) && Bridge.equals(this.mOrthoSizeOverDistance, o.mOrthoSizeOverDistance) && Bridge.equals(this.mAspect, o.mAspect) && Bridge.equals(this.mSoftGuideRect, o.mSoftGuideRect) && Bridge.equals(this.mHardGuideRect, o.mHardGuideRect);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer.FovCache#$clone", this ); }

                var s = to || new Cinemachine.CinemachineComposer.FovCache();
                s.mFovSoftGuideRect = this.mFovSoftGuideRect.$clone();
                s.mFovHardGuideRect = this.mFovHardGuideRect.$clone();
                s.mFovH = this.mFovH;
                s.mFov = this.mFov;
                s.mOrthoSizeOverDistance = this.mOrthoSizeOverDistance;
                s.mAspect = this.mAspect;
                s.mSoftGuideRect = this.mSoftGuideRect.$clone();
                s.mHardGuideRect = this.mHardGuideRect.$clone();
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineComposer+FovCache end.*/

    /*Cinemachine.CinemachineConfiner+Mode start.*/
    /**
     * The confiner can operate using a 2D bounding shape or a 3D bounding volume
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineConfiner.Mode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Use a 2D bounding shape, suitable for an orthographic camera
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Confine2D: 0,
                /**
                 * Use a 3D bounding shape, suitable for perspective cameras
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Confine3D: 1
            }
        }
    });
    /*Cinemachine.CinemachineConfiner+Mode end.*/

    /*Cinemachine.CinemachineConfiner+VcamExtraState start.*/
    Bridge.define("Cinemachine.CinemachineConfiner.VcamExtraState", {
        $kind: "nested class",
        fields: {
            confinerDisplacement: 0,
            m_previousDisplacement: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner.VcamExtraState#init", this ); }

                this.m_previousDisplacement = new UnityEngine.Vector3();
            }
        }
    });
    /*Cinemachine.CinemachineConfiner+VcamExtraState end.*/
    /**
     * @memberof Cinemachine
     * @callback Cinemachine.CinemachineCore.GetBlendOverrideDelegate
     * @param   {Cinemachine.ICinemachineCamera}            fromVcam        
     * @param   {Cinemachine.ICinemachineCamera}            toVcam          
     * @param   {Cinemachine.CinemachineBlendDefinition}    defaultBlend    
     * @param   {UnityEngine.MonoBehaviour}                 owner
     * @return  {Cinemachine.CinemachineBlendDefinition}
     */

    /**
     * @memberof Cinemachine
     * @callback Cinemachine.CinemachineCore.AxisInputDelegate
     * @param   {string}    axisName
     * @return  {number}
     */


    /*Cinemachine.CinemachineCore start.*/
    /**
     * A singleton that manages complete lists of CinemachineBrain and,
         Cinemachine Virtual Cameras, and the priority queue.  Provides
         services to keeping track of whether Cinemachine Virtual Cameras have
         been updated each frame.
     *
     * @public
     * @class Cinemachine.CinemachineCore
     */
    Bridge.define("Cinemachine.CinemachineCore", {
        statics: {
            fields: {
                /**
                 * Data version string.  Used to upgrade from legacy projects
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Cinemachine.CinemachineCore
                 * @default 20170927
                 * @type number
                 */
                kStreamingVersion: 0,
                /**
                 * Human-readable Cinemachine Version
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Cinemachine.CinemachineCore
                 * @default "2.4.0"
                 * @type string
                 */
                kVersionString: null,
                sInstance: null,
                /**
                 * If true, show hidden Cinemachine objects, to make manual script mapping possible.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineCore
                 * @default false
                 * @type boolean
                 */
                sShowHiddenObjects: false,
                /**
                 * Delegate for overriding Unity's default input system.
                     If you set this, then your delegate will be called instead of
                     System.Input.GetAxis(axisName) whenever in-game user input is needed.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineCore
                 * @type Cinemachine.CinemachineCore.AxisInputDelegate
                 */
                GetInputAxis: null,
                /**
                 * If non-negative, and in play mode, cinemachine will update with this uniform delta time.
                     Usage is for timelines in manual update mode.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineCore
                 * @type number
                 */
                UniformDeltaTimeOverride: 0,
                /**
                 * Delegate for overriding a blend that is about to be applied to a transition.
                     A handler can either return the default blend, or a new blend specific to
                     current conditions.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineCore
                 * @type Cinemachine.CinemachineCore.GetBlendOverrideDelegate
                 */
                GetBlendOverride: null,
                /**
                 * This event will fire after a brain updates its Camera
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineCore
                 * @type Cinemachine.CinemachineBrain.BrainEvent
                 */
                CameraUpdatedEvent: null,
                /**
                 * This event will fire after a brain updates its Camera
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineCore
                 * @type Cinemachine.CinemachineBrain.BrainEvent
                 */
                CameraCutEvent: null,
                mLastUpdateTime: 0,
                FixedFrameCount: 0
            },
            props: {
                /**
                 * Get the singleton instance
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Cinemachine.CinemachineCore
                 * @function Instance
                 * @type Cinemachine.CinemachineCore
                 */
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#Instance#get", this ); }

                        if (Cinemachine.CinemachineCore.sInstance == null) {
                            Cinemachine.CinemachineCore.sInstance = new Cinemachine.CinemachineCore();
                        }

                        return Cinemachine.CinemachineCore.sInstance;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#init", this ); }

                    this.kStreamingVersion = 20170927;
                    this.kVersionString = "2.4.0";
                    this.sShowHiddenObjects = false;
                    this.GetInputAxis = UnityEngine.Input.GetAxis;
                    this.UniformDeltaTimeOverride = -1;
                    this.CameraUpdatedEvent = new Cinemachine.CinemachineBrain.BrainEvent();
                    this.CameraCutEvent = new Cinemachine.CinemachineBrain.BrainEvent();
                }
            },
            methods: {
                /*Cinemachine.CinemachineCore.InitializeModule:static start.*/
                InitializeModule: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#InitializeModule", this ); }

                    Cinemachine.CinemachineCore.Instance.mUpdateStatus = new (System.Collections.Generic.Dictionary$2(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.UpdateStatus)).ctor();
                },
                /*Cinemachine.CinemachineCore.InitializeModule:static end.*/

                /*Cinemachine.CinemachineCore.GetUpdateTarget:static start.*/
                GetUpdateTarget: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#GetUpdateTarget", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(vcam, null) || UnityEngine.GameObject.op_Equality(vcam.gameObject, null)) {
                        return null;
                    }

                    var target = vcam.LookAt;
                    if (UnityEngine.Component.op_Inequality(target, null)) {
                        return target;
                    }

                    target = vcam.Follow;
                    if (UnityEngine.Component.op_Inequality(target, null)) {
                        return target;
                    }

                    // If no target, use the vcam itself
                    return vcam.transform;
                },
                /*Cinemachine.CinemachineCore.GetUpdateTarget:static end.*/


            }
        },
        fields: {
            /**
             * List of all active CinemachineBrains.
             *
             * @instance
             * @private
             * @readonly
             * @memberof Cinemachine.CinemachineCore
             * @type System.Collections.Generic.List$1
             */
            mActiveBrains: null,
            /**
             * List of all active ICinemachineCameras.
             *
             * @instance
             * @private
             * @readonly
             * @memberof Cinemachine.CinemachineCore
             * @type System.Collections.Generic.List$1
             */
            mActiveCameras: null,
            mAllCameras: null,
            mRoundRobinVcamLastFrame: null,
            mUpdateStatus: null,
            CurrentUpdateFilter: 0
        },
        props: {
            /**
             * Access the array of active CinemachineBrains in the scene
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineCore
             * @function BrainCount
             * @type number
             */
            BrainCount: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#BrainCount#get", this ); }

                    return this.mActiveBrains.Count;
                }
            },
            /**
             * List of all active Cinemachine Virtual Cameras for all brains.
                 This list is kept sorted by priority.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineCore
             * @function VirtualCameraCount
             * @type number
             */
            VirtualCameraCount: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#VirtualCameraCount#get", this ); }

                    return this.mActiveCameras.Count;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#init", this ); }

                this.mActiveBrains = new (System.Collections.Generic.List$1(Cinemachine.CinemachineBrain)).ctor();
                this.mActiveCameras = new (System.Collections.Generic.List$1(Cinemachine.CinemachineVirtualCameraBase)).ctor();
                this.mAllCameras = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(Cinemachine.CinemachineVirtualCameraBase))).ctor();
            }
        },
        methods: {
            /*Cinemachine.CinemachineCore.GetActiveBrain start.*/
            /**
             * Access the array of active CinemachineBrains in the scene
                 without gebnerating garbage
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {number}                          index    Index of the brain to access, range 0-BrainCount
             * @return  {Cinemachine.CinemachineBrain}             The brain at the specified index
             */
            GetActiveBrain: function (index) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#GetActiveBrain", this ); }

                return this.mActiveBrains.getItem(index);
            },
            /*Cinemachine.CinemachineCore.GetActiveBrain end.*/

            /*Cinemachine.CinemachineCore.AddActiveBrain start.*/
            /**
             * Called when a CinemachineBrain is enabled.
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineBrain}    brain
             * @return  {void}
             */
            AddActiveBrain: function (brain) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#AddActiveBrain", this ); }

                // First remove it, just in case it's being added twice
                this.RemoveActiveBrain(brain);
                this.mActiveBrains.insert(0, brain);
            },
            /*Cinemachine.CinemachineCore.AddActiveBrain end.*/

            /*Cinemachine.CinemachineCore.RemoveActiveBrain start.*/
            /**
             * Called when a CinemachineBrain is disabled.
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineBrain}    brain
             * @return  {void}
             */
            RemoveActiveBrain: function (brain) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#RemoveActiveBrain", this ); }

                this.mActiveBrains.remove(brain);
            },
            /*Cinemachine.CinemachineCore.RemoveActiveBrain end.*/

            /*Cinemachine.CinemachineCore.GetVirtualCamera start.*/
            /**
             * Access the array of active ICinemachineCamera in the scene
                 without gebnerating garbage
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {number}                                      index    Index of the camera to access, range 0-VirtualCameraCount
             * @return  {Cinemachine.CinemachineVirtualCameraBase}             The virtual camera at the specified index
             */
            GetVirtualCamera: function (index) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#GetVirtualCamera", this ); }

                return this.mActiveCameras.getItem(index);
            },
            /*Cinemachine.CinemachineCore.GetVirtualCamera end.*/

            /*Cinemachine.CinemachineCore.AddActiveCamera start.*/
            /**
             * Called when a Cinemachine Virtual Camera is enabled.
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam
             * @return  {void}
             */
            AddActiveCamera: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#AddActiveCamera", this ); }

                // Bring it to the top of the list
                this.RemoveActiveCamera(vcam);

                // Keep list sorted by priority
                var insertIndex;
                for (insertIndex = 0; insertIndex < this.mActiveCameras.Count; ++insertIndex) {
                    if (vcam.Priority >= this.mActiveCameras.getItem(insertIndex).Priority) {
                        break;
                    }
                }

                this.mActiveCameras.insert(insertIndex, vcam);
            },
            /*Cinemachine.CinemachineCore.AddActiveCamera end.*/

            /*Cinemachine.CinemachineCore.RemoveActiveCamera start.*/
            /**
             * Called when a Cinemachine Virtual Camera is disabled.
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam
             * @return  {void}
             */
            RemoveActiveCamera: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#RemoveActiveCamera", this ); }

                this.mActiveCameras.remove(vcam);
            },
            /*Cinemachine.CinemachineCore.RemoveActiveCamera end.*/

            /*Cinemachine.CinemachineCore.CameraAwakened start.*/
            /**
             * Called when a vcam is awakened.
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam
             * @return  {void}
             */
            CameraAwakened: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#CameraAwakened", this ); }

                var parentLevel = 0;
                for (var p = vcam.ParentCamera; p != null; p = p.Cinemachine$ICinemachineCamera$ParentCamera) {
                    ++parentLevel;
                }

                while (this.mAllCameras.Count <= parentLevel) {
                    this.mAllCameras.add(new (System.Collections.Generic.List$1(Cinemachine.CinemachineVirtualCameraBase)).ctor());
                }

                this.mAllCameras.getItem(parentLevel).add(vcam);
            },
            /*Cinemachine.CinemachineCore.CameraAwakened end.*/

            /*Cinemachine.CinemachineCore.CameraDestroyed start.*/
            /**
             * Called when a vcam is destroyed.
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam
             * @return  {void}
             */
            CameraDestroyed: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#CameraDestroyed", this ); }

                for (var i = 0; i < this.mAllCameras.Count; ++i) {
                    this.mAllCameras.getItem(i).remove(vcam);
                }

                if (this.mUpdateStatus != null) {
                    this.mUpdateStatus.remove(vcam);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.mRoundRobinVcamLastFrame, vcam)) {
                    this.mRoundRobinVcamLastFrame = null;
                }
            },
            /*Cinemachine.CinemachineCore.CameraDestroyed end.*/

            /*Cinemachine.CinemachineCore.UpdateAllActiveVirtualCameras start.*/
            /**
             * Update all the active vcams in the scene, in the correct dependency order.
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {number}                 layerMask    
             * @param   {UnityEngine.Vector3}    worldUp      
             * @param   {number}                 deltaTime
             * @return  {void}
             */
            UpdateAllActiveVirtualCameras: function (layerMask, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#UpdateAllActiveVirtualCameras", this ); }

                // Setup for roundRobin standby updating
                var filter = this.CurrentUpdateFilter;
                var canUpdateStandby = filter !== Cinemachine.CinemachineCore.UpdateFilter.SmartFixed; // never in smart fixed
                var currentRoundRobin = this.mRoundRobinVcamLastFrame;

                // Update the fixed frame count
                var now = UnityEngine.Time.time;
                if (now !== Cinemachine.CinemachineCore.mLastUpdateTime) {
                    Cinemachine.CinemachineCore.mLastUpdateTime = now;
                    if ((filter & -9) === Cinemachine.CinemachineCore.UpdateFilter.Fixed) {
                        ++Cinemachine.CinemachineCore.FixedFrameCount;
                    }
                }

                // Update the leaf-most cameras first
                for (var i = this.mAllCameras.Count - 1; i >= 0; --i) {
                    var sublist = this.mAllCameras.getItem(i);
                    for (var j = sublist.Count - 1; j >= 0; --j) {
                        var vcam = sublist.getItem(j);
                        if (canUpdateStandby && UnityEngine.MonoBehaviour.op_Equality(vcam, this.mRoundRobinVcamLastFrame)) {
                            currentRoundRobin = null; // update the next roundrobin candidate
                        }

                        if (UnityEngine.MonoBehaviour.op_Equality(vcam, null)) {
                            sublist.removeAt(j);
                            continue; // deleted
                        }

                        if (vcam.m_StandbyUpdate === Cinemachine.CinemachineVirtualCameraBase.StandbyUpdateMode.Always || this.IsLive(vcam)) {
                            // Skip this vcam if it's not on the layer mask
                            if (((1 << vcam.gameObject.layer) & layerMask) !== 0) {
                                this.UpdateVirtualCamera(vcam, worldUp.$clone(), deltaTime);
                            }
                        } else if (UnityEngine.MonoBehaviour.op_Equality(currentRoundRobin, null) && UnityEngine.MonoBehaviour.op_Inequality(this.mRoundRobinVcamLastFrame, vcam) && canUpdateStandby && vcam.m_StandbyUpdate !== Cinemachine.CinemachineVirtualCameraBase.StandbyUpdateMode.Never && vcam.isActiveAndEnabled) {
                            // Do the round-robin update
                            this.CurrentUpdateFilter &= -9; // force it
                            this.UpdateVirtualCamera(vcam, worldUp.$clone(), deltaTime);
                            this.CurrentUpdateFilter = filter;
                            currentRoundRobin = vcam;
                        }
                    }
                }

                // Did we manage to update a roundrobin?
                if (canUpdateStandby) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRoundRobin, this.mRoundRobinVcamLastFrame)) {
                        currentRoundRobin = null; // take the first candidate
                    }

                    this.mRoundRobinVcamLastFrame = currentRoundRobin;
                }
            },
            /*Cinemachine.CinemachineCore.UpdateAllActiveVirtualCameras end.*/

            /*Cinemachine.CinemachineCore.UpdateVirtualCamera start.*/
            /**
             * Update a single Cinemachine Virtual Camera if and only if it
                 hasn't already been updated this frame.  Always update vcams via this method.
                 Calling this more than once per frame for the same camera will have no effect.
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam         
             * @param   {UnityEngine.Vector3}                         worldUp      
             * @param   {number}                                      deltaTime
             * @return  {void}
             */
            UpdateVirtualCamera: function (vcam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#UpdateVirtualCamera", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(vcam, null)) {
                    return;
                }

                var isSmartUpdate = (this.CurrentUpdateFilter & Cinemachine.CinemachineCore.UpdateFilter.Smart) === Cinemachine.CinemachineCore.UpdateFilter.Smart;
                var updateClock = this.CurrentUpdateFilter & -9;

                // If we're in smart update mode and the target moved, then we must examine
                // how the target has been moving recently in order to figure out whether to
                // update now
                if (isSmartUpdate) {
                    var updateTarget = Cinemachine.CinemachineCore.GetUpdateTarget(vcam);
                    if (UnityEngine.Component.op_Equality(updateTarget, null)) {
                        return; // vcam deleted
                    }

                    if (Cinemachine.UpdateTracker.GetPreferredUpdate(updateTarget) !== updateClock) {
                        return; // wrong clock
                    }
                }

                // Have we already been updated this frame?
                if (this.mUpdateStatus == null) {
                    this.mUpdateStatus = new (System.Collections.Generic.Dictionary$2(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.UpdateStatus)).ctor();
                }

                var status = { };
                if (!this.mUpdateStatus.tryGetValue(vcam, status)) {
                    status.v = new Cinemachine.CinemachineCore.UpdateStatus();
                    this.mUpdateStatus.add(vcam, status.v);
                }

                var frameDelta = updateClock === Cinemachine.UpdateTracker.UpdateClock.Late ? UnityEngine.Time.frameCount - status.v.lastUpdateFrame : Cinemachine.CinemachineCore.FixedFrameCount - status.v.lastUpdateFixedFrame;
                if (deltaTime >= 0) {
                    if (frameDelta === 0 && status.v.lastUpdateMode === updateClock && status.v.lastUpdateDeltaTime === deltaTime) {
                        return; // already updated
                    }

                    if (frameDelta > 0) {
                        deltaTime *= frameDelta; // try to catch up if multiple frames
                    }
                }

                //Debug.Log((vcam.ParentCamera == null ? "" : vcam.ParentCamera.Name + ".") + vcam.Name + ": frame " + Time.frameCount + "/" + status.lastUpdateFixedFrame + ", " + CurrentUpdateFilter + ", deltaTime = " + deltaTime);
                vcam.InternalUpdateCameraState(worldUp.$clone(), deltaTime);
                status.v.lastUpdateFrame = UnityEngine.Time.frameCount;
                status.v.lastUpdateFixedFrame = Cinemachine.CinemachineCore.FixedFrameCount;
                status.v.lastUpdateMode = updateClock;
                status.v.lastUpdateDeltaTime = deltaTime;
            },
            /*Cinemachine.CinemachineCore.UpdateVirtualCamera end.*/

            /*Cinemachine.CinemachineCore.GetVcamUpdateStatus start.*/
            /**
             * Internal use only - inspector
             *
             * @instance
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam
             * @return  {number}
             */
            GetVcamUpdateStatus: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#GetVcamUpdateStatus", this ); }

                var status = { };
                if (this.mUpdateStatus == null || !this.mUpdateStatus.tryGetValue(vcam, status)) {
                    return Cinemachine.UpdateTracker.UpdateClock.Late;
                }

                return status.v.lastUpdateMode;
            },
            /*Cinemachine.CinemachineCore.GetVcamUpdateStatus end.*/

            /*Cinemachine.CinemachineCore.IsLive start.*/
            /**
             * Is this virtual camera currently actively controlling any Camera?
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.ICinemachineCamera}    vcam
             * @return  {boolean}
             */
            IsLive: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#IsLive", this ); }

                if (vcam != null) {
                    for (var i = 0; i < this.BrainCount; ++i) {
                        var b = this.GetActiveBrain(i);
                        if (UnityEngine.MonoBehaviour.op_Inequality(b, null) && b.IsLive(vcam)) {
                            return true;
                        }
                    }
                }

                return false;
            },
            /*Cinemachine.CinemachineCore.IsLive end.*/

            /*Cinemachine.CinemachineCore.GenerateCameraActivationEvent start.*/
            /**
             * Signal that the virtual has been activated.
                 If the camera is live, then all CinemachineBrains that are showing it will
                 send an activation event.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.ICinemachineCamera}    vcam        
             * @param   {Cinemachine.ICinemachineCamera}    vcamFrom
             * @return  {void}
             */
            GenerateCameraActivationEvent: function (vcam, vcamFrom) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#GenerateCameraActivationEvent", this ); }

                if (vcam != null) {
                    for (var i = 0; i < this.BrainCount; ++i) {
                        var b = this.GetActiveBrain(i);
                        if (UnityEngine.MonoBehaviour.op_Inequality(b, null) && b.IsLive(vcam)) {
                            b.m_CameraActivatedEvent.Invoke(vcam, vcamFrom);
                        }
                    }
                }
            },
            /*Cinemachine.CinemachineCore.GenerateCameraActivationEvent end.*/

            /*Cinemachine.CinemachineCore.GenerateCameraCutEvent start.*/
            /**
             * Signal that the virtual camera's content is discontinuous WRT the previous frame.
                 If the camera is live, then all CinemachineBrains that are showing it will send a cut event.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.ICinemachineCamera}    vcam
             * @return  {void}
             */
            GenerateCameraCutEvent: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#GenerateCameraCutEvent", this ); }

                if (vcam != null) {
                    for (var i = 0; i < this.BrainCount; ++i) {
                        var b = this.GetActiveBrain(i);
                        if (UnityEngine.MonoBehaviour.op_Inequality(b, null) && b.IsLive(vcam)) {
                            if (b.m_CameraCutEvent != null) {
                                b.m_CameraCutEvent.Invoke(b);
                            }

                            if (Cinemachine.CinemachineCore.CameraCutEvent != null) {
                                Cinemachine.CinemachineCore.CameraCutEvent.Invoke(b);
                            }
                        }
                    }
                }
            },
            /*Cinemachine.CinemachineCore.GenerateCameraCutEvent end.*/

            /*Cinemachine.CinemachineCore.FindPotentialTargetBrain start.*/
            /**
             * Try to find a CinemachineBrain to associate with a
                 Cinemachine Virtual Camera.  The first CinemachineBrain
                 in which this Cinemachine Virtual Camera is live will be used.
                 If none, then the first active CinemachineBrain with the correct
                 layer filter will be used.
                 Brains with OutputCamera == null will not be returned.
                 Final result may be null.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineCore
             * @memberof Cinemachine.CinemachineCore
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam    Virtual camera whose potential brain we need.
             * @return  {Cinemachine.CinemachineBrain}                        First CinemachineBrain found that might be
                 appropriate for this vcam, or null
             */
            FindPotentialTargetBrain: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore#FindPotentialTargetBrain", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(vcam, null)) {
                    var numBrains = this.BrainCount;
                    for (var i = 0; i < numBrains; ++i) {
                        var b = this.GetActiveBrain(i);
                        if (UnityEngine.MonoBehaviour.op_Inequality(b, null) && UnityEngine.Component.op_Inequality(b.OutputCamera, null) && b.IsLive(vcam)) {
                            return b;
                        }
                    }

                    var layer = 1 << vcam.gameObject.layer;
                    for (var i1 = 0; i1 < numBrains; ++i1) {
                        var b1 = this.GetActiveBrain(i1);
                        if (UnityEngine.MonoBehaviour.op_Inequality(b1, null) && UnityEngine.Component.op_Inequality(b1.OutputCamera, null) && (b1.OutputCamera.cullingMask & layer) !== 0) {
                            return b1;
                        }
                    }
                }

                return null;
            },
            /*Cinemachine.CinemachineCore.FindPotentialTargetBrain end.*/


        }
    });
    /*Cinemachine.CinemachineCore end.*/

    /*Cinemachine.CinemachineCore+Stage start.*/
    /**
     * Stages in the Cinemachine Component pipeline, used for
         UI organization&gt;.  This enum defines the pipeline order.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineCore.Stage", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Second stage: position the camera in space
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Body: 0,
                /**
                 * Third stage: orient the camera to point at the target
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Aim: 1,
                /**
                 * Final pipeline stage: apply noise (this is done separately, in the
                     Correction channel of the CameraState)
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Noise: 2,
                /**
                 * Not a pipeline stage.  This is invoked on all virtual camera
                     types, after the pipeline is complete
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                Finalize: 3
            }
        }
    });
    /*Cinemachine.CinemachineCore+Stage end.*/

    /*Cinemachine.CinemachineCore+UpdateFilter start.*/
    /**
     * Internal use only
     *
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineCore.UpdateFilter", {
        $kind: "nested enum",
        statics: {
            fields: {
                Fixed: 0,
                Late: 0,
                Smart: 8,
                SmartFixed: 8,
                SmartLate: 9
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore.UpdateFilter#init", this ); }

                    this.Fixed = Cinemachine.UpdateTracker.UpdateClock.Fixed;
                    this.Late = Cinemachine.UpdateTracker.UpdateClock.Late;
                }
            }
        }
    });
    /*Cinemachine.CinemachineCore+UpdateFilter end.*/

    /*Cinemachine.CinemachineCore+UpdateStatus start.*/
    Bridge.define("Cinemachine.CinemachineCore.UpdateStatus", {
        $kind: "nested class",
        fields: {
            lastUpdateDeltaTime: 0,
            lastUpdateFixedFrame: 0,
            lastUpdateFrame: 0,
            lastUpdateMode: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCore.UpdateStatus#ctor", this ); }

                this.$initialize();
                this.lastUpdateFrame = -2;
                this.lastUpdateFixedFrame = 0;
                this.lastUpdateMode = Cinemachine.UpdateTracker.UpdateClock.Late;
                this.lastUpdateDeltaTime = -2;
            }
        }
    });
    /*Cinemachine.CinemachineCore+UpdateStatus end.*/

    /*Cinemachine.CinemachineDollyCart start.*/
    /**
     * This is a very simple behaviour that constrains its transform to a CinemachinePath.
         It can be used to animate any objects along a path, or as a Follow target for
         Cinemachine Virtual Cameras.
     *
     * @public
     * @class Cinemachine.CinemachineDollyCart
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachineDollyCart", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            /**
             * The path to follow
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineDollyCart
             * @type Cinemachine.CinemachinePathBase
             */
            m_Path: null,
            /**
             * When to move the cart, if Velocity is non-zero
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineDollyCart
             * @type number
             */
            m_UpdateMethod: 0,
            /**
             * How to interpret the Path Position
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineDollyCart
             * @type number
             */
            m_PositionUnits: 0,
            /**
             * Move the cart with this speed
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineDollyCart
             * @type number
             */
            m_Speed: 0,
            /**
             * The cart's current position on the path, in distance units
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineDollyCart
             * @type number
             */
            m_Position: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineDollyCart#init", this ); }

                this.m_UpdateMethod = Cinemachine.CinemachineDollyCart.UpdateMethod.Update;
                this.m_PositionUnits = Cinemachine.CinemachinePathBase.PositionUnits.Distance;
            }
        },
        methods: {
            /*Cinemachine.CinemachineDollyCart.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineDollyCart#FixedUpdate", this ); }

                if (this.m_UpdateMethod === Cinemachine.CinemachineDollyCart.UpdateMethod.FixedUpdate) {
                    this.SetCartPosition(this.m_Position + this.m_Speed * UnityEngine.Time.deltaTime);
                }
            },
            /*Cinemachine.CinemachineDollyCart.FixedUpdate end.*/

            /*Cinemachine.CinemachineDollyCart.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineDollyCart#Update", this ); }

                var speed = UnityEngine.Application.isPlaying ? this.m_Speed : 0;
                if (this.m_UpdateMethod === Cinemachine.CinemachineDollyCart.UpdateMethod.Update) {
                    this.SetCartPosition(this.m_Position + speed * UnityEngine.Time.deltaTime);
                }
            },
            /*Cinemachine.CinemachineDollyCart.Update end.*/

            /*Cinemachine.CinemachineDollyCart.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineDollyCart#LateUpdate", this ); }

                if (!UnityEngine.Application.isPlaying) {
                    this.SetCartPosition(this.m_Position);
                } else if (this.m_UpdateMethod === Cinemachine.CinemachineDollyCart.UpdateMethod.LateUpdate) {
                    this.SetCartPosition(this.m_Position + this.m_Speed * UnityEngine.Time.deltaTime);
                }
            },
            /*Cinemachine.CinemachineDollyCart.LateUpdate end.*/

            /*Cinemachine.CinemachineDollyCart.SetCartPosition start.*/
            SetCartPosition: function (distanceAlongPath) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineDollyCart#SetCartPosition", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Path, null)) {
                    this.m_Position = this.m_Path.StandardizeUnit(distanceAlongPath, this.m_PositionUnits);
                    this.transform.position = this.m_Path.EvaluatePositionAtUnit(this.m_Position, this.m_PositionUnits);
                    this.transform.rotation = this.m_Path.EvaluateOrientationAtUnit(this.m_Position, this.m_PositionUnits);
                }
            },
            /*Cinemachine.CinemachineDollyCart.SetCartPosition end.*/


        }
    });
    /*Cinemachine.CinemachineDollyCart end.*/

    /*Cinemachine.CinemachineDollyCart+UpdateMethod start.*/
    /**
     * This enum defines the options available for the update method.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineDollyCart.UpdateMethod", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Updated in normal MonoBehaviour Update.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Update: 0,
                /**
                 * Updated in sync with the Physics module, in FixedUpdate
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                FixedUpdate: 1,
                /**
                 * Updated in normal MonoBehaviour LateUpdate
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                LateUpdate: 2
            }
        }
    });
    /*Cinemachine.CinemachineDollyCart+UpdateMethod end.*/

    /*Cinemachine.CinemachineEmbeddedAssetPropertyAttribute start.*/
    /**
     * Used for custom drawing in the inspector.
     *
     * @public
     * @class Cinemachine.CinemachineEmbeddedAssetPropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.CinemachineEmbeddedAssetPropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            warnIfNull: false
        },
        ctors: {
            ctor: function (warnIfNull) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineEmbeddedAssetPropertyAttribute#ctor", this ); }

                if (warnIfNull === void 0) { warnIfNull = false; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.warnIfNull = warnIfNull;
            }
        }
    });
    /*Cinemachine.CinemachineEmbeddedAssetPropertyAttribute end.*/

    /*Cinemachine.ISignalSource6D start.*/
    /**
     * Interface for raw signal provider
     *
     * @abstract
     * @public
     * @class Cinemachine.ISignalSource6D
     */
    Bridge.define("Cinemachine.ISignalSource6D", {
        $kind: "interface"
    });
    /*Cinemachine.ISignalSource6D end.*/

    /*Cinemachine.CinemachineFollowZoom+VcamExtraState start.*/
    Bridge.define("Cinemachine.CinemachineFollowZoom.VcamExtraState", {
        $kind: "nested class",
        fields: {
            m_previousFrameZoom: 0
        }
    });
    /*Cinemachine.CinemachineFollowZoom+VcamExtraState end.*/

    /*Cinemachine.CinemachineFramingTransposer+AdjustmentMode start.*/
    /**
     * How to adjust the camera to get the desired framing
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineFramingTransposer.AdjustmentMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Do not move the camera, only adjust the FOV.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                ZoomOnly: 0,
                /**
                 * Just move the camera, don't change the FOV.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                DollyOnly: 1,
                /**
                 * Move the camera as much as permitted by the ranges, then
                     adjust the FOV if necessary to make the shot.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                DollyThenZoom: 2
            }
        }
    });
    /*Cinemachine.CinemachineFramingTransposer+AdjustmentMode end.*/

    /*Cinemachine.CinemachineFramingTransposer+FramingMode start.*/
    /**
     * What screen dimensions to consider when framing
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineFramingTransposer.FramingMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Consider only the horizontal dimension.  Vertical framing is ignored.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Horizontal: 0,
                /**
                 * Consider only the vertical dimension.  Horizontal framing is ignored.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Vertical: 1,
                /**
                 * The larger of the horizontal and vertical dimensions will dominate, to get the best fit.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                HorizontalAndVertical: 2,
                /**
                 * Don't do any framing adjustment
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                None: 3
            }
        }
    });
    /*Cinemachine.CinemachineFramingTransposer+FramingMode end.*/

    /*Cinemachine.CinemachineFreeLook+Orbit start.*/
    /**
     * Defines the height and radius of the Rig orbit
     *
     * @public
     * @class Cinemachine.CinemachineFreeLook.Orbit
     */
    Bridge.define("Cinemachine.CinemachineFreeLook.Orbit", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook.Orbit#getDefaultValue", this ); }
 return new Cinemachine.CinemachineFreeLook.Orbit(); }
            }
        },
        fields: {
            /**
             * Height relative to target
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook.Orbit
             * @type number
             */
            m_Height: 0,
            /**
             * Radius of orbit
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook.Orbit
             * @type number
             */
            m_Radius: 0
        },
        ctors: {
            /**
             * Constructor with specific values
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineFreeLook.Orbit
             * @memberof Cinemachine.CinemachineFreeLook.Orbit
             * @param   {number}    h    
             * @param   {number}    r
             * @return  {void}
             */
            $ctor1: function (h, r) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook.Orbit#$ctor1", this ); }

                this.$initialize();
                this.m_Height = h;
                this.m_Radius = r;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook.Orbit#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook.Orbit#getHashCode", this ); }

                var h = Bridge.addHash([1768059587, this.m_Height, this.m_Radius]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook.Orbit#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineFreeLook.Orbit)) {
                    return false;
                }
                return Bridge.equals(this.m_Height, o.m_Height) && Bridge.equals(this.m_Radius, o.m_Radius);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook.Orbit#$clone", this ); }

                var s = to || new Cinemachine.CinemachineFreeLook.Orbit();
                s.m_Height = this.m_Height;
                s.m_Radius = this.m_Radius;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineFreeLook+Orbit end.*/

    /*Cinemachine.CinemachineGroupComposer+AdjustmentMode start.*/
    /**
     * How to adjust the camera to get the desired framing
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineGroupComposer.AdjustmentMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Do not move the camera, only adjust the FOV.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                ZoomOnly: 0,
                /**
                 * Just move the camera, don't change the FOV.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                DollyOnly: 1,
                /**
                 * Move the camera as much as permitted by the ranges, then
                     adjust the FOV if necessary to make the shot.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                DollyThenZoom: 2
            }
        }
    });
    /*Cinemachine.CinemachineGroupComposer+AdjustmentMode end.*/

    /*Cinemachine.CinemachineGroupComposer+FramingMode start.*/
    /**
     * What screen dimensions to consider when framing
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineGroupComposer.FramingMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Consider only the horizontal dimension.  Vertical framing is ignored.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Horizontal: 0,
                /**
                 * Consider only the vertical dimension.  Horizontal framing is ignored.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Vertical: 1,
                /**
                 * The larger of the horizontal and vertical dimensions will dominate, to get the best fit.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                HorizontalAndVertical: 2
            }
        }
    });
    /*Cinemachine.CinemachineGroupComposer+FramingMode end.*/

    /*Cinemachine.CinemachineImpulseChannelPropertyAttribute start.*/
    /**
     * Property applied to CinemachineImpulseManager Channels.
         Used for custom drawing in the inspector.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseChannelPropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.CinemachineImpulseChannelPropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.CinemachineImpulseChannelPropertyAttribute end.*/

    /*Cinemachine.CinemachineImpulseDefinition start.*/
    /**
     * Definition of an impulse signal that gets propagated to listeners.
         Here you provide a Raw Signal source, and define an envelope for time-scaling
         it to craft the complete Impulse signal shape.  Also, you provide here parameters
         that define how the signal dissipates with spatial distance from the source location.
         Finally, you specify the Impulse Channel on which the signal will be sent.
         An API method is provided here to take these parameters, create an Impulse Event,
         and broadcast it on the channel.
         When creating a custom Impulse Source class, you will have an instance of this class
         as a field in your custom class.  Be sure also to include the
         [CinemachineImpulseDefinition] attribute on the field, to get the right
         property drawer for it.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseDefinition
     */
    Bridge.define("Cinemachine.CinemachineImpulseDefinition", {
        fields: {
            /**
             * Gain to apply to the amplitudes defined in the signal source asset.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @default 1.0
             * @type number
             */
            m_AmplitudeGain: 0,
            /**
             * How the signal direction behaves as the listener moves away from the origin.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @type number
             */
            m_DirectionMode: 0,
            /**
             * At this distance beyond the impact radius, the signal will have dissipated to zero.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @default 1000
             * @type number
             */
            m_DissipationDistance: 0,
            /**
             * This defines how the signal will dissipate with distance beyond the impact radius.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @type number
             */
            m_DissipationMode: 0,
            /**
             * Scale factor to apply to the time axis.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @default 1.0
             * @type number
             */
            m_FrequencyGain: 0,
            /**
             * The signal will have full amplitude in this radius surrounding the impact point.
                 Beyond that it will dissipate with distance.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @default 100
             * @type number
             */
            m_ImpactRadius: 0,
            /**
             * Impulse events generated here will appear on the channels included in the mask.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @default 1
             * @type number
             */
            m_ImpulseChannel: 0,
            /**
             * Randomize the signal start time
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @default true
             * @type boolean
             */
            m_Randomize: false,
            /**
             * Defines the signal that will be generated.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @type Cinemachine.SignalSourceAsset
             */
            m_RawSignal: null,
            /**
             * How to fit the signal into the envelope time
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @type number
             */
            m_RepeatMode: 0,
            /**
             * This defines the time-envelope of the signal.
                 The raw signal will be time-scaled to fit in the envelope.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @type Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             */
            m_TimeEnvelope: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseDefinition#init", this ); }

                this.m_TimeEnvelope = new Cinemachine.CinemachineImpulseManager.EnvelopeDefinition();
                this.m_AmplitudeGain = 1.0;
                this.m_DirectionMode = Cinemachine.CinemachineImpulseManager.ImpulseEvent.DirectionMode.Fixed;
                this.m_DissipationDistance = 1000;
                this.m_DissipationMode = Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode.ExponentialDecay;
                this.m_FrequencyGain = 1.0;
                this.m_ImpactRadius = 100;
                this.m_ImpulseChannel = 1;
                this.m_Randomize = true;
                this.m_RepeatMode = Cinemachine.CinemachineImpulseDefinition.RepeatMode.Stretch;
                this.m_TimeEnvelope = Cinemachine.CinemachineImpulseManager.EnvelopeDefinition.Default();
            }
        },
        methods: {
            /*Cinemachine.CinemachineImpulseDefinition.OnValidate start.*/
            /**
             * Call this from your behaviour's OnValidate to validate the fields here
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseDefinition
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @return  {void}
             */
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseDefinition#OnValidate", this ); }

                this.m_ImpactRadius = UnityEngine.Mathf.Max(0, this.m_ImpactRadius);
                this.m_DissipationDistance = UnityEngine.Mathf.Max(0, this.m_DissipationDistance);
                this.m_TimeEnvelope.Validate();
            },
            /*Cinemachine.CinemachineImpulseDefinition.OnValidate end.*/

            /*Cinemachine.CinemachineImpulseDefinition.CreateEvent start.*/
            /**
             * Generate an impulse event at a location in space,
                 and broadcast it on the appropriate impulse channel
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseDefinition
             * @memberof Cinemachine.CinemachineImpulseDefinition
             * @param   {UnityEngine.Vector3}    position    
             * @param   {UnityEngine.Vector3}    velocity
             * @return  {void}
             */
            CreateEvent: function (position, velocity) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseDefinition#CreateEvent", this ); }

                if (this.m_RawSignal == null || Math.abs(this.m_TimeEnvelope.Duration) < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    return;
                }

                var e = Cinemachine.CinemachineImpulseManager.Instance.NewImpulseEvent();
                e.m_Envelope = this.m_TimeEnvelope.$clone();

                // Scale the time-envelope decay as the root of the amplitude scale
                e.m_Envelope = this.m_TimeEnvelope.$clone();
                if (this.m_TimeEnvelope.m_ScaleWithImpact) {
                    e.m_Envelope.m_DecayTime *= Math.sqrt(velocity.length());
                }

                e.m_SignalSource = new Cinemachine.CinemachineImpulseDefinition.SignalSource(this, velocity.$clone());
                e.m_Position = position.$clone();
                e.m_Radius = this.m_ImpactRadius;
                e.m_Channel = this.m_ImpulseChannel;
                e.m_DirectionMode = this.m_DirectionMode;
                e.m_DissipationMode = this.m_DissipationMode;
                e.m_DissipationDistance = this.m_DissipationDistance;
                Cinemachine.CinemachineImpulseManager.Instance.AddImpulseEvent(e);
            },
            /*Cinemachine.CinemachineImpulseDefinition.CreateEvent end.*/


        }
    });
    /*Cinemachine.CinemachineImpulseDefinition end.*/

    /*Cinemachine.CinemachineImpulseDefinition+RepeatMode start.*/
    /**
     * How to fit the signal into the envelope time
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineImpulseDefinition.RepeatMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Time-stretch the signal to fit the envelope
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Stretch: 0,
                /**
                 * Loop the signal in time to fill the envelope
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Loop: 1
            }
        }
    });
    /*Cinemachine.CinemachineImpulseDefinition+RepeatMode end.*/

    /*Cinemachine.CinemachineImpulseDefinitionPropertyAttribute start.*/
    /**
     * Property applied to CinemachineImpulseManager Channels.
         Used for custom drawing in the inspector.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseDefinitionPropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.CinemachineImpulseDefinitionPropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.CinemachineImpulseDefinitionPropertyAttribute end.*/

    /*Cinemachine.CinemachineImpulseEnvelopePropertyAttribute start.*/
    /**
     * Property applied to CinemachineImpulseManager.EnvelopeDefinition.
         Used for custom drawing in the inspector.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseEnvelopePropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.CinemachineImpulseEnvelopePropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.CinemachineImpulseEnvelopePropertyAttribute end.*/

    /*Cinemachine.CinemachineImpulseManager start.*/
    /**
     * This is a singleton object that manages all Impulse Events generated by the Cinemachine
         Impulse module.  This singleton owns and manages all ImpulseEvent objectss.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseManager
     */
    Bridge.define("Cinemachine.CinemachineImpulseManager", {
        statics: {
            fields: {
                Epsilon: 0,
                sInstance: null
            },
            props: {
                /**
                 * Get the singleton instance
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Cinemachine.CinemachineImpulseManager
                 * @function Instance
                 * @type Cinemachine.CinemachineImpulseManager
                 */
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager#Instance#get", this ); }

                        if (Cinemachine.CinemachineImpulseManager.sInstance == null) {
                            Cinemachine.CinemachineImpulseManager.sInstance = new Cinemachine.CinemachineImpulseManager();
                        }

                        return Cinemachine.CinemachineImpulseManager.sInstance;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager#init", this ); }

                    this.Epsilon = 0.0001;
                }
            }
        },
        fields: {
            m_ActiveEvents: null,
            m_ExpiredEvents: null,
            /**
             * Set this to ignore time scaling so impulses can progress while the game is paused
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager
             * @function IgnoreTimeScale
             * @type boolean
             */
            IgnoreTimeScale: false
        },
        props: {
            CurrentTime: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager#CurrentTime#get", this ); }

                    return this.IgnoreTimeScale ? UnityEngine.Time.realtimeSinceStartup : UnityEngine.Time.time;
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.CinemachineImpulseManager.GetImpulseAt start.*/
            /**
             * Get the signal perceived by a listener at a geven location
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager
             * @memberof Cinemachine.CinemachineImpulseManager
             * @param   {UnityEngine.Vector3}       listenerLocation    Where the listener is, in world coords
             * @param   {boolean}                   distance2D          True if distance calculation should ignore Z
             * @param   {number}                    channelMask         Only Impulse signals on channels in this mask will be considered
             * @param   {UnityEngine.Vector3}       pos                 The combined position impulse signal resulting from all signals active on the specified channels
             * @param   {UnityEngine.Quaternion}    rot                 The combined rotation impulse signal resulting from all signals active on the specified channels
             * @return  {boolean}                                       true if non-trivial signal is returned
             */
            GetImpulseAt: function (listenerLocation, distance2D, channelMask, pos, rot) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager#GetImpulseAt", this ); }

                var nontrivialResult = false;
                pos.v = pc.Vec3.ZERO.clone();
                rot.v = pc.Quat.IDENTITY.clone();
                if (this.m_ActiveEvents != null) {
                    for (var i = this.m_ActiveEvents.Count - 1; i >= 0; --i) {
                        var e = this.m_ActiveEvents.getItem(i);
                        // Prune invalid or expired events
                        if (e == null || e.Expired) {
                            this.m_ActiveEvents.removeAt(i);
                            if (e != null) {
                                // Recycle it
                                if (this.m_ExpiredEvents == null) {
                                    this.m_ExpiredEvents = new (System.Collections.Generic.List$1(Cinemachine.CinemachineImpulseManager.ImpulseEvent)).ctor();
                                }

                                e.Clear();
                                this.m_ExpiredEvents.add(e);
                            }
                        } else if ((e.m_Channel & channelMask) !== 0) {
                            var pos0 = { v : pc.Vec3.ZERO.clone() };
                            var rot0 = { v : pc.Quat.IDENTITY.clone() };
                            if (e.GetDecayedSignal(listenerLocation.$clone(), distance2D, pos0, rot0)) {
                                nontrivialResult = true;
                                pos.v = pos.v.$clone().add( pos0.v.$clone() );
                                rot.v = rot.v.$clone().clone().mul( rot0.v.$clone() );
                            }
                        }
                    }
                }

                return nontrivialResult;
            },
            /*Cinemachine.CinemachineImpulseManager.GetImpulseAt end.*/

            /*Cinemachine.CinemachineImpulseManager.NewImpulseEvent start.*/
            /**
             * Get a new ImpulseEvent
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager
             * @memberof Cinemachine.CinemachineImpulseManager
             * @return  {Cinemachine.CinemachineImpulseManager.ImpulseEvent}
             */
            NewImpulseEvent: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager#NewImpulseEvent", this ); }

                var e;
                if (this.m_ExpiredEvents == null || this.m_ExpiredEvents.Count === 0) {
                    return new Cinemachine.CinemachineImpulseManager.ImpulseEvent();
                }

                e = this.m_ExpiredEvents.getItem(this.m_ExpiredEvents.Count - 1);
                this.m_ExpiredEvents.removeAt(this.m_ExpiredEvents.Count - 1);
                return e;
            },
            /*Cinemachine.CinemachineImpulseManager.NewImpulseEvent end.*/

            /*Cinemachine.CinemachineImpulseManager.AddImpulseEvent start.*/
            /**
             * Activate an impulse event, so that it may begin broadcasting its signal
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager
             * @memberof Cinemachine.CinemachineImpulseManager
             * @param   {Cinemachine.CinemachineImpulseManager.ImpulseEvent}    e
             * @return  {void}
             */
            AddImpulseEvent: function (e) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager#AddImpulseEvent", this ); }

                if (this.m_ActiveEvents == null) {
                    this.m_ActiveEvents = new (System.Collections.Generic.List$1(Cinemachine.CinemachineImpulseManager.ImpulseEvent)).ctor();
                }

                if (e != null) {
                    e.m_StartTime = this.CurrentTime;
                    this.m_ActiveEvents.add(e);
                }
            },
            /*Cinemachine.CinemachineImpulseManager.AddImpulseEvent end.*/

            /*Cinemachine.CinemachineImpulseManager.Clear start.*/
            /**
             * Immediately terminate all active impulse signals
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager
             * @memberof Cinemachine.CinemachineImpulseManager
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager#Clear", this ); }

                if (this.m_ActiveEvents != null) {
                    for (var i = 0; i < this.m_ActiveEvents.Count; ++i) {
                        this.m_ActiveEvents.getItem(i).Clear();
                    }

                    this.m_ActiveEvents.clear();
                }
            },
            /*Cinemachine.CinemachineImpulseManager.Clear end.*/


        }
    });
    /*Cinemachine.CinemachineImpulseManager end.*/

    /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition start.*/
    /**
     * This defines the time-envelope of the signal.
         Thie raw signal will be scaled to fit inside the envelope.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
     */
    Bridge.define("Cinemachine.CinemachineImpulseManager.EnvelopeDefinition", {
        $kind: "nested struct",
        statics: {
            methods: {
                /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.Default:static start.*/
                /**
                 * Get an envelope with default values.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
                 * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
                 * @return  {Cinemachine.CinemachineImpulseManager.EnvelopeDefinition}
                 */
                Default: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#Default", this ); }

                    var $t;
                    return ($t = new Cinemachine.CinemachineImpulseManager.EnvelopeDefinition(), $t.m_DecayTime = 0.7, $t.m_SustainTime = 0.2, $t.m_ScaleWithImpact = true, $t);
                },
                /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.Default:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#getDefaultValue", this ); }
 return new Cinemachine.CinemachineImpulseManager.EnvelopeDefinition(); }
            }
        },
        fields: {
            /**
             * Normalized curve defining the shape of the start of the envelope.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @type pc.AnimationCurve
             */
            m_AttackShape: null,
            /**
             * Normalized curve defining the shape of the end of the envelope.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @type pc.AnimationCurve
             */
            m_DecayShape: null,
            /**
             * Duration in seconds of the attack.  Attack curve will be scaled to fit.  Must be &gt;= 0
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @type number
             */
            m_AttackTime: 0,
            /**
             * Duration in seconds of the central fully-scaled part of the envelope.  Must be &gt;= 0.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @type number
             */
            m_SustainTime: 0,
            /**
             * Duration in seconds of the decay.  Decay curve will be scaled to fit.  Must be &gt;= 0.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @type number
             */
            m_DecayTime: 0,
            /**
             * If checked, signal amplitude scaling will also be applied to the time envelope of the signal.  Bigger signals
                 will last longer
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @type boolean
             */
            m_ScaleWithImpact: false,
            /**
             * If true, then duration is infinite.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @type boolean
             */
            m_HoldForever: false
        },
        props: {
            /**
             * Duration of the envelope, in seconds.  If negative, then duration is infinite.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @function Duration
             * @type number
             */
            Duration: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#Duration#get", this ); }

                    if (this.m_HoldForever) {
                        return -1;
                    }

                    return this.m_AttackTime + this.m_SustainTime + this.m_DecayTime;
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.GetValueAt start.*/
            /**
             * Get the value of the tenvelope at a given time relative to the envelope start.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @param   {number}    offset    Time in seconds fromt he envelope start
             * @return  {number}              Envelope amplitude.  This will range from 0...1
             */
            GetValueAt: function (offset) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#GetValueAt", this ); }

                if (offset >= 0) {
                    if (offset < this.m_AttackTime && this.m_AttackTime > Cinemachine.CinemachineImpulseManager.Epsilon) {
                        if (this.m_AttackShape == null || this.m_AttackShape.keys.length < 2) {
                            return Cinemachine.Utility.Damper.Damp(1, this.m_AttackTime, offset);
                        }

                        return this.m_AttackShape.value(offset / this.m_AttackTime);
                    }

                    offset -= this.m_AttackTime;
                    if (this.m_HoldForever || offset < this.m_SustainTime) {
                        return 1;
                    }

                    offset -= this.m_SustainTime;
                    if (offset < this.m_DecayTime && this.m_DecayTime > Cinemachine.CinemachineImpulseManager.Epsilon) {
                        if (this.m_DecayShape == null || this.m_DecayShape.keys.length < 2) {
                            return 1 - Cinemachine.Utility.Damper.Damp(1, this.m_DecayTime, offset);
                        }

                        return this.m_DecayShape.value(offset / this.m_DecayTime);
                    }
                }

                return 0;
            },
            /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.GetValueAt end.*/

            /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.ChangeStopTime start.*/
            /**
             * Change the envelope so that it stops at a specific offset from its start time.
                 Use this to extend or cut short an existing envelope, while respecting the
                 attack and decay as much as possible.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @param   {number}     offset          When to stop the envelope
             * @param   {boolean}    forceNoDecay    If true, enevlope will not decay, but cut off instantly
             * @return  {void}
             */
            ChangeStopTime: function (offset, forceNoDecay) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#ChangeStopTime", this ); }

                if (offset < 0) {
                    offset = 0;
                }

                if (offset < this.m_AttackTime) {
                    this.m_AttackTime = 0; // How to prevent pop? GML
                }

                this.m_SustainTime = offset - this.m_AttackTime;
                if (forceNoDecay) {
                    this.m_DecayTime = 0;
                }
            },
            /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.ChangeStopTime end.*/

            /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.Clear start.*/
            /**
             * Set the envelop times to 0 and the shapes to default.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#Clear", this ); }

                this.m_AttackShape = (this.m_DecayShape = null);
                this.m_AttackTime = (this.m_SustainTime = (this.m_DecayTime = 0));
            },
            /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.Clear end.*/

            /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.Validate start.*/
            /**
             * Call from OnValidate to ensure that envelope values are sane
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @memberof Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             * @return  {void}
             */
            Validate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#Validate", this ); }

                this.m_AttackTime = UnityEngine.Mathf.Max(0, this.m_AttackTime);
                this.m_DecayTime = UnityEngine.Mathf.Max(0, this.m_DecayTime);
                this.m_SustainTime = UnityEngine.Mathf.Max(0, this.m_SustainTime);
            },
            /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition.Validate end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#getHashCode", this ); }

                var h = Bridge.addHash([6941711058, this.m_AttackShape, this.m_DecayShape, this.m_AttackTime, this.m_SustainTime, this.m_DecayTime, this.m_ScaleWithImpact, this.m_HoldForever]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineImpulseManager.EnvelopeDefinition)) {
                    return false;
                }
                return Bridge.equals(this.m_AttackShape, o.m_AttackShape) && Bridge.equals(this.m_DecayShape, o.m_DecayShape) && Bridge.equals(this.m_AttackTime, o.m_AttackTime) && Bridge.equals(this.m_SustainTime, o.m_SustainTime) && Bridge.equals(this.m_DecayTime, o.m_DecayTime) && Bridge.equals(this.m_ScaleWithImpact, o.m_ScaleWithImpact) && Bridge.equals(this.m_HoldForever, o.m_HoldForever);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.EnvelopeDefinition#$clone", this ); }

                var s = to || new Cinemachine.CinemachineImpulseManager.EnvelopeDefinition();
                s.m_AttackShape = this.m_AttackShape;
                s.m_DecayShape = this.m_DecayShape;
                s.m_AttackTime = this.m_AttackTime;
                s.m_SustainTime = this.m_SustainTime;
                s.m_DecayTime = this.m_DecayTime;
                s.m_ScaleWithImpact = this.m_ScaleWithImpact;
                s.m_HoldForever = this.m_HoldForever;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition end.*/

    /*Cinemachine.CinemachineImpulseManager+ImpulseEvent start.*/
    /**
     * Describes an event that generates an impulse signal on one or more channels.
         The event has a location in space, a start time, a duration, and a signal.  The signal
         will dissipate as the distance from the event location increases.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseManager.ImpulseEvent
     */
    Bridge.define("Cinemachine.CinemachineImpulseManager.ImpulseEvent", {
        $kind: "nested class",
        fields: {
            /**
             * Channels on which this event will broadcast its signal.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type number
             */
            m_Channel: 0,
            /**
             * How the signal direction behaves as the listener moves away from the source.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type number
             */
            m_DirectionMode: 0,
            /**
             * Distance over which the dissipation occurs.  Must be &gt;= 0.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type number
             */
            m_DissipationDistance: 0,
            /**
             * How the signal dissipates with distance.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type number
             */
            m_DissipationMode: 0,
            /**
             * Time-envelope of the signal.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type Cinemachine.CinemachineImpulseManager.EnvelopeDefinition
             */
            m_Envelope: null,
            /**
             * Worldspace origin of the signal.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type UnityEngine.Vector3
             */
            m_Position: null,
            /**
             * Radius around the signal origin that has full signal value.  Distance dissipation begins after this distance.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type number
             */
            m_Radius: 0,
            /**
             * Raw signal source.  The ouput of this will be scaled to fit in the envelope.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type Cinemachine.ISignalSource6D
             */
            m_SignalSource: null,
            /**
             * Start time of the event.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @type number
             */
            m_StartTime: 0
        },
        props: {
            /**
             * Returns true if the event is no longer generating a signal because its time has expired
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @function Expired
             * @type boolean
             */
            Expired: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.ImpulseEvent#Expired#get", this ); }

                    var d = this.m_Envelope.Duration;
                    return d > 0 && this.m_StartTime + d <= Cinemachine.CinemachineImpulseManager.Instance.CurrentTime;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.ImpulseEvent#init", this ); }

                this.m_Envelope = new Cinemachine.CinemachineImpulseManager.EnvelopeDefinition();
                this.m_Position = new UnityEngine.Vector3();
                this.m_DirectionMode = Cinemachine.CinemachineImpulseManager.ImpulseEvent.DirectionMode.Fixed;
            },
            /**
             * Don't create them yourself.  Use CinemachineImpulseManager.NewImpulseEvent().
             *
             * @instance
             * @this Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.ImpulseEvent#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.CinemachineImpulseManager+ImpulseEvent.Cancel start.*/
            /**
             * Cancel the event at the supplied time
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @param   {number}     time            The time at which to cancel the event
             * @param   {boolean}    forceNoDecay    If true, event will be cut immediately at the time,
                 otherwise its envelope's decay curve will begin at the cancel time
             * @return  {void}
             */
            Cancel: function (time, forceNoDecay) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.ImpulseEvent#Cancel", this ); }

                this.m_Envelope.ChangeStopTime(time - this.m_StartTime, forceNoDecay);
            },
            /*Cinemachine.CinemachineImpulseManager+ImpulseEvent.Cancel end.*/

            /*Cinemachine.CinemachineImpulseManager+ImpulseEvent.DistanceDecay start.*/
            /**
             * Calculate the the decay applicable at a given distance from the impact point
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @param   {number}    distance
             * @return  {number}                Scale factor 0...1
             */
            DistanceDecay: function (distance) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.ImpulseEvent#DistanceDecay", this ); }

                var radius = UnityEngine.Mathf.Max(this.m_Radius, 0);
                if (distance < radius) {
                    return 1;
                }

                distance -= radius;
                if (distance >= this.m_DissipationDistance) {
                    return 0;
                }

                switch (this.m_DissipationMode) {
                    default: 
                    case Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode.LinearDecay: 
                        return pc.math.lerp(1, 0, distance / this.m_DissipationDistance);
                    case Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode.SoftDecay: 
                        return 0.5 * (1 + Math.cos(UnityEngine.Mathf.PI * (distance / this.m_DissipationDistance)));
                    case Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode.ExponentialDecay: 
                        return 1 - Cinemachine.Utility.Damper.Damp(1, this.m_DissipationDistance, distance);
                }
            },
            /*Cinemachine.CinemachineImpulseManager+ImpulseEvent.DistanceDecay end.*/

            /*Cinemachine.CinemachineImpulseManager+ImpulseEvent.GetDecayedSignal start.*/
            /**
             * Get the signal that a listener at a given position would perceive
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @param   {UnityEngine.Vector3}       listenerPosition    The listener's position in world space
             * @param   {boolean}                   use2D               True if distance calculation should ignore Z
             * @param   {UnityEngine.Vector3}       pos                 The position impulse signal
             * @param   {UnityEngine.Quaternion}    rot                 The rotation impulse signal
             * @return  {boolean}                                       true if non-trivial signal is returned
             */
            GetDecayedSignal: function (listenerPosition, use2D, pos, rot) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.ImpulseEvent#GetDecayedSignal", this ); }

                if (this.m_SignalSource != null) {
                    var time = Cinemachine.CinemachineImpulseManager.Instance.CurrentTime - this.m_StartTime;
                    var distance = use2D ? UnityEngine.Vector2.FromVector3(listenerPosition.$clone()).sub( UnityEngine.Vector2.FromVector3(this.m_Position) ).length() : pc.Vec3.distance( listenerPosition, this.m_Position );
                    var scale = this.m_Envelope.GetValueAt(time) * this.DistanceDecay(distance);
                    this.m_SignalSource.Cinemachine$ISignalSource6D$GetSignal(time, pos, rot);
                    pos.v = pos.v.$clone().clone().scale( scale );
                    rot.v = new pc.Quat().slerpUnclamped( pc.Quat.IDENTITY.clone(), rot.v, scale );
                    if (this.m_DirectionMode === Cinemachine.CinemachineImpulseManager.ImpulseEvent.DirectionMode.RotateTowardSource && distance > Cinemachine.CinemachineImpulseManager.Epsilon) {
                        var q = new pc.Quat().fromTo( pc.Vec3.UP.clone(), listenerPosition.$clone().sub( this.m_Position ) );
                        if (this.m_Radius > Cinemachine.CinemachineImpulseManager.Epsilon) {
                            var t = Math.max(0, Math.min(1, distance / this.m_Radius));
                            q = new pc.Quat().slerp( q, pc.Quat.IDENTITY.clone(), Math.cos(UnityEngine.Mathf.PI * t / 2) );
                        }

                        pos.v = q.transformVector( pos.v );
                        rot.v = q.clone().invert().clone().mul( rot.v ).clone().mul( q );
                    }

                    return true;
                }

                pos.v = pc.Vec3.ZERO.clone();
                rot.v = pc.Quat.IDENTITY.clone();
                return false;
            },
            /*Cinemachine.CinemachineImpulseManager+ImpulseEvent.GetDecayedSignal end.*/

            /*Cinemachine.CinemachineImpulseManager+ImpulseEvent.Clear start.*/
            /**
             * Reset the event to a default state
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @memberof Cinemachine.CinemachineImpulseManager.ImpulseEvent
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseManager.ImpulseEvent#Clear", this ); }

                this.m_Envelope.Clear();
                this.m_StartTime = 0;
                this.m_SignalSource = null;
                this.m_Position = pc.Vec3.ZERO.clone();
                this.m_Channel = 0;
                this.m_Radius = 0;
                this.m_DissipationDistance = 100;
                this.m_DissipationMode = Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode.ExponentialDecay;
            },
            /*Cinemachine.CinemachineImpulseManager+ImpulseEvent.Clear end.*/


        }
    });
    /*Cinemachine.CinemachineImpulseManager+ImpulseEvent end.*/

    /*Cinemachine.CinemachineImpulseManager+ImpulseEvent+DirectionMode start.*/
    /**
     * How the signal behaves as the listener moves away from the origin.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineImpulseManager.ImpulseEvent.DirectionMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Signal direction remains constant everywhere.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Fixed: 0,
                /**
                 * Signal is rotated in the direction of the source.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                RotateTowardSource: 1
            }
        }
    });
    /*Cinemachine.CinemachineImpulseManager+ImpulseEvent+DirectionMode end.*/

    /*Cinemachine.CinemachineImpulseManager+ImpulseEvent+DissipationMode start.*/
    /**
     * How the signal dissipates with distance.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Simple linear interpolation to zero over the dissipation distance.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                LinearDecay: 0,
                /**
                 * Ease-in-ease-out dissipation over the dissipation distance.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                SoftDecay: 1,
                /**
                 * Half-life decay, hard out from full and ease into 0 over the dissipation distance.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                ExponentialDecay: 2
            }
        }
    });
    /*Cinemachine.CinemachineImpulseManager+ImpulseEvent+DissipationMode end.*/

    /*Cinemachine.CinemachineInputAxisDriver start.*/
    Bridge.define("Cinemachine.CinemachineInputAxisDriver", {
        $kind: "struct",
        statics: {
            fields: {
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#init", this ); }

                    this.Epsilon = 0.0001;
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#getDefaultValue", this ); }
 return new Cinemachine.CinemachineInputAxisDriver(); }
            }
        },
        fields: {
            multiplier: 0,
            accelTime: 0,
            decelTime: 0,
            name: null,
            inputValue: 0,
            /**
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineInputAxisDriver
             * @type number
             */
            mCurrentSpeed: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.CinemachineInputAxisDriver.Validate start.*/
            /**
             * @instance
             * @public
             * @this Cinemachine.CinemachineInputAxisDriver
             * @memberof Cinemachine.CinemachineInputAxisDriver
             * @return  {void}
             */
            Validate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#Validate", this ); }

                this.accelTime = UnityEngine.Mathf.Max(0, this.accelTime);
                this.decelTime = UnityEngine.Mathf.Max(0, this.decelTime);
            },
            /*Cinemachine.CinemachineInputAxisDriver.Validate end.*/

            /*Cinemachine.CinemachineInputAxisDriver.Update start.*/
            Update: function (deltaTime, axis) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#Update", this ); }

                if (!System.String.isNullOrEmpty(this.name)) {
                    try {
                        this.inputValue = Cinemachine.CinemachineCore.GetInputAxis(this.name);
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.ArgumentException)) {
                        } else {
                            throw $e1;
                        }
                    }

                    //catch (ArgumentException e) { Debug.LogError(e.ToString()); }
                }

                var input = this.inputValue * this.multiplier;
                if (deltaTime < Cinemachine.CinemachineInputAxisDriver.Epsilon) {
                    this.mCurrentSpeed = 0;
                } else {
                    var speed = input / deltaTime;
                    var dampTime = Math.abs(speed) < Math.abs(this.mCurrentSpeed) ? this.decelTime : this.accelTime;
                    speed = this.mCurrentSpeed + Cinemachine.Utility.Damper.Damp(speed - this.mCurrentSpeed, dampTime, deltaTime);
                    this.mCurrentSpeed = speed;

                    // Decelerate to the end points of the range if not wrapping
                    var range = axis.v.m_MaxValue - axis.v.m_MinValue;
                    if (!axis.v.m_Wrap && this.decelTime > Cinemachine.CinemachineInputAxisDriver.Epsilon && range > Cinemachine.CinemachineInputAxisDriver.Epsilon) {
                        var v0 = this.ClampValue(axis, axis.v.m_Value);
                        var v = this.ClampValue(axis, v0 + speed * deltaTime);
                        var d = speed > 0 ? axis.v.m_MaxValue - v : v - axis.v.m_MinValue;
                        if (d < 0.1 * range && Math.abs(speed) > Cinemachine.CinemachineInputAxisDriver.Epsilon) {
                            speed = Cinemachine.Utility.Damper.Damp(v - v0, this.decelTime, deltaTime) / deltaTime;
                        }
                    }

                    input = speed * deltaTime;
                }

                axis.v.m_Value = this.ClampValue(axis, axis.v.m_Value + input);
                return Math.abs(this.inputValue) > Cinemachine.CinemachineInputAxisDriver.Epsilon;
            },
            /*Cinemachine.CinemachineInputAxisDriver.Update end.*/

            /*Cinemachine.CinemachineInputAxisDriver.Update$1 start.*/
            /**
             * Support for legacy AxisState struct
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineInputAxisDriver
             * @memberof Cinemachine.CinemachineInputAxisDriver
             * @param   {number}                   deltaTime    
             * @param   {Cinemachine.AxisState}    axis
             * @return  {boolean}
             */
            Update$1: function (deltaTime, axis) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#Update$1", this ); }

                var $t;
                var a = { v : ($t = new Cinemachine.AxisBase(), $t.m_Value = axis.v.Value, $t.m_MinValue = axis.v.m_MinValue, $t.m_MaxValue = axis.v.m_MaxValue, $t.m_Wrap = axis.v.m_Wrap, $t) };
                var changed = this.Update(deltaTime, a);
                axis.v.Value = a.v.m_Value;
                return changed;
            },
            /*Cinemachine.CinemachineInputAxisDriver.Update$1 end.*/

            /*Cinemachine.CinemachineInputAxisDriver.ClampValue start.*/
            ClampValue: function (axis, v) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#ClampValue", this ); }

                var r = axis.v.m_MaxValue - axis.v.m_MinValue;
                if (axis.v.m_Wrap && r > Cinemachine.CinemachineInputAxisDriver.Epsilon) {
                    v = (v - axis.v.m_MinValue) % r;
                    v += axis.v.m_MinValue + (v < 0 ? r : 0);
                }

                return Math.max(axis.v.m_MinValue, Math.min(v, axis.v.m_MaxValue));
            },
            /*Cinemachine.CinemachineInputAxisDriver.ClampValue end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#getHashCode", this ); }

                var h = Bridge.addHash([10561259121, this.multiplier, this.accelTime, this.decelTime, this.name, this.inputValue, this.mCurrentSpeed]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineInputAxisDriver)) {
                    return false;
                }
                return Bridge.equals(this.multiplier, o.multiplier) && Bridge.equals(this.accelTime, o.accelTime) && Bridge.equals(this.decelTime, o.decelTime) && Bridge.equals(this.name, o.name) && Bridge.equals(this.inputValue, o.inputValue) && Bridge.equals(this.mCurrentSpeed, o.mCurrentSpeed);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineInputAxisDriver#$clone", this ); }

                var s = to || new Cinemachine.CinemachineInputAxisDriver();
                s.multiplier = this.multiplier;
                s.accelTime = this.accelTime;
                s.decelTime = this.decelTime;
                s.name = this.name;
                s.inputValue = this.inputValue;
                s.mCurrentSpeed = this.mCurrentSpeed;
                return s;
            }
        },
        overloads: {
            "Update(float, AxisState)": "Update$1"
        }
    });
    /*Cinemachine.CinemachineInputAxisDriver end.*/

    /*Cinemachine.CinemachineOrbitalTransposer+Heading start.*/
    /**
     * How the "forward" direction is defined.  Orbital offset is in relation to the forward
         direction.
     *
     * @public
     * @class Cinemachine.CinemachineOrbitalTransposer.Heading
     */
    Bridge.define("Cinemachine.CinemachineOrbitalTransposer.Heading", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer.Heading#getDefaultValue", this ); }
 return new Cinemachine.CinemachineOrbitalTransposer.Heading(); }
            }
        },
        fields: {
            /**
             * The method by which the 'default heading' is calculated if
                 recentering to target heading is enabled
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineOrbitalTransposer.Heading
             * @type number
             */
            m_Definition: 0,
            /**
             * Size of the velocity sampling window for target heading filter.
                 Used only if deriving heading from target's movement
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineOrbitalTransposer.Heading
             * @type number
             */
            m_VelocityFilterStrength: 0,
            /**
             * Additional Y rotation applied to the target heading.
                 When this value is 0, the camera will be placed behind the target
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineOrbitalTransposer.Heading
             * @type number
             */
            m_Bias: 0
        },
        ctors: {
            /**
             * Constructor
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineOrbitalTransposer.Heading
             * @memberof Cinemachine.CinemachineOrbitalTransposer.Heading
             * @param   {number}    def               
             * @param   {number}    filterStrength    
             * @param   {number}    bias
             * @return  {void}
             */
            $ctor1: function (def, filterStrength, bias) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer.Heading#$ctor1", this ); }

                this.$initialize();
                this.m_Definition = def;
                this.m_VelocityFilterStrength = filterStrength;
                this.m_Bias = bias;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer.Heading#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer.Heading#getHashCode", this ); }

                var h = Bridge.addHash([1690882993, this.m_Definition, this.m_VelocityFilterStrength, this.m_Bias]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer.Heading#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineOrbitalTransposer.Heading)) {
                    return false;
                }
                return Bridge.equals(this.m_Definition, o.m_Definition) && Bridge.equals(this.m_VelocityFilterStrength, o.m_VelocityFilterStrength) && Bridge.equals(this.m_Bias, o.m_Bias);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer.Heading#$clone", this ); }

                var s = to || new Cinemachine.CinemachineOrbitalTransposer.Heading();
                s.m_Definition = this.m_Definition;
                s.m_VelocityFilterStrength = this.m_VelocityFilterStrength;
                s.m_Bias = this.m_Bias;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineOrbitalTransposer+Heading end.*/

    /*Cinemachine.CinemachineOrbitalTransposer+Heading+HeadingDefinition start.*/
    /**
     * Sets the algorithm for determining the target's heading for purposes
         of re-centering the camera
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Target heading calculated from the difference between its position on
                     the last update and current frame.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                PositionDelta: 0,
                /**
                 * Target heading calculated from its <b>Rigidbody</b>'s velocity.
                     If no <b>Rigidbody</b> exists, it will fall back
                     to HeadingDerivationMode.PositionDelta
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Velocity: 1,
                /**
                 * Target heading calculated from the Target <b>Transform</b>'s euler Y angle
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                TargetForward: 2,
                /**
                 * Default heading is a constant world space heading.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                WorldForward: 3
            }
        }
    });
    /*Cinemachine.CinemachineOrbitalTransposer+Heading+HeadingDefinition end.*/

    /*Cinemachine.CinemachinePathBase start.*/
    /**
     * Abstract base class for a world-space path,
         suitable for a camera dolly track.
     *
     * @abstract
     * @public
     * @class Cinemachine.CinemachinePathBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachinePathBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            /**
             * The settings that control how the path
                 will appear in the editor scene view.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePathBase
             * @type Cinemachine.CinemachinePathBase.Appearance
             */
            m_Appearance: null,
            m_cachedDistanceStepSize: 0,
            m_cachedPosStepSize: 0,
            m_CachedSampleSteps: 0,
            m_DistanceToPos: null,
            m_PathLength: 0,
            m_PosToDistance: null,
            /**
             * Path samples per waypoint
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePathBase
             * @default 20
             * @type number
             */
            m_Resolution: 0
        },
        props: {
            /**
             * Get the length of the path in distance units.
                 If the distance cache is not valid, then calling this will
                 trigger a potentially costly regeneration of the path distance cache
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachinePathBase
             * @function PathLength
             * @type number
             * @return  {[type]}        The length of the path in distance units, when sampled at this rate
             */
            PathLength: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#PathLength#get", this ); }

                    if (this.DistanceCacheSampleStepsPerSegment < 1) {
                        return 0;
                    }

                    if (!this.DistanceCacheIsValid()) {
                        this.ResamplePath(this.DistanceCacheSampleStepsPerSegment);
                    }

                    return this.m_PathLength;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#init", this ); }

                this.m_Appearance = new Cinemachine.CinemachinePathBase.Appearance();
                this.m_Resolution = 20;
            }
        },
        methods: {
            /*Cinemachine.CinemachinePathBase.StandardizePos start.*/
            /**
             * Get a standardized path position, taking spins into account if looped
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}    pos    Position along the path
             * @return  {number}           Standardized position, between MinPos and MaxPos
             */
            StandardizePos: function (pos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#StandardizePos", this ); }

                if (this.MaxPos === 0) {
                    return 0;
                }

                if (this.Looped) {
                    pos = pos % this.MaxPos;
                    if (pos < 0) {
                        pos += this.MaxPos;
                    }

                    return pos > this.MaxPos - Cinemachine.Utility.UnityVectorExtensions.Epsilon ? 0 : pos;
                }

                return Math.max(0, Math.min(pos, this.MaxPos));
            },
            /*Cinemachine.CinemachinePathBase.StandardizePos end.*/

            /*Cinemachine.CinemachinePathBase.FindClosestPoint start.*/
            /**
             * Find the closest point on the path to a given worldspace target point.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {UnityEngine.Vector3}    p                  Worldspace target that we want to approach
             * @param   {number}                 startSegment       In what segment of the path to start the search.
                 A Segment is a section of path between 2 waypoints.
             * @param   {number}                 searchRadius       How many segments on either side of the startSegment
                 to search.  -1 means no limit, i.e. search the entire path
             * @param   {number}                 stepsPerSegment    We search a segment by dividing it into this many
                 straight pieces.  The higher the number, the more accurate the result, but performance
                 is proportionally slower for higher numbers
             * @return  {number}                                    The position along the path that is closest to the target point.
                 The value is in Path Units, not Distance units.
             */
            FindClosestPoint: function (p, startSegment, searchRadius, stepsPerSegment) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#FindClosestPoint", this ); }

                var start = this.MinPos;
                var end = this.MaxPos;
                if (searchRadius >= 0) {
                    var r = Math.floor(UnityEngine.Mathf.Min(searchRadius, (end - start) / 2.0));
                    start = startSegment - r;
                    end = startSegment + r + 1;
                    if (!this.Looped) {
                        start = UnityEngine.Mathf.Max(start, this.MinPos);
                        end = UnityEngine.Mathf.Max(end, this.MaxPos);
                    }
                }

                stepsPerSegment = Math.round(Math.max(1.0, Math.min(stepsPerSegment, 100.0)));
                var stepSize = 1.0 / stepsPerSegment;
                var bestPos = startSegment;
                var bestDistance = 3.40282347E+38;
                var iterations = stepsPerSegment === 1 ? 1 : 3;
                for (var i = 0; i < iterations; ++i) {
                    var v0 = this.EvaluatePosition(start);
                    for (var f = start + stepSize; f <= end; f += stepSize) {
                        var v = this.EvaluatePosition(f);
                        var t = Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment$1(p, v0.$clone(), v.$clone());
                        var d = p.$clone().sub( new pc.Vec3().lerp( v0, v, t ) ).lengthSq();
                        if (d < bestDistance) {
                            bestDistance = d;
                            bestPos = f - (1 - t) * stepSize;
                        }

                        v0 = v.$clone();
                    }

                    start = bestPos - stepSize;
                    end = bestPos + stepSize;
                    stepSize /= stepsPerSegment;
                }

                return bestPos;
            },
            /*Cinemachine.CinemachinePathBase.FindClosestPoint end.*/

            /*Cinemachine.CinemachinePathBase.MinUnit start.*/
            /**
             * Get the minimum value, for the given unit type
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}    units    The unit type
             * @return  {number}             The minimum allowable value for this path
             */
            MinUnit: function (units) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#MinUnit", this ); }

                if (units === Cinemachine.CinemachinePathBase.PositionUnits.Normalized) {
                    return 0;
                }

                return units === Cinemachine.CinemachinePathBase.PositionUnits.Distance ? 0 : this.MinPos;
            },
            /*Cinemachine.CinemachinePathBase.MinUnit end.*/

            /*Cinemachine.CinemachinePathBase.MaxUnit start.*/
            /**
             * Get the maximum value, for the given unit type
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}    units    The unit type
             * @return  {number}             The maximum allowable value for this path
             */
            MaxUnit: function (units) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#MaxUnit", this ); }

                if (units === Cinemachine.CinemachinePathBase.PositionUnits.Normalized) {
                    return 1;
                }

                return units === Cinemachine.CinemachinePathBase.PositionUnits.Distance ? this.PathLength : this.MaxPos;
            },
            /*Cinemachine.CinemachinePathBase.MaxUnit end.*/

            /*Cinemachine.CinemachinePathBase.StandardizeUnit start.*/
            /**
             * Standardize the unit, so that it lies between MinUmit and MaxUnit
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}    pos      The value to be standardized
             * @param   {number}    units    The unit type
             * @return  {number}             The standardized value of pos, between MinUnit and MaxUnit
             */
            StandardizeUnit: function (pos, units) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#StandardizeUnit", this ); }

                if (units === Cinemachine.CinemachinePathBase.PositionUnits.PathUnits) {
                    return this.StandardizePos(pos);
                }

                if (units === Cinemachine.CinemachinePathBase.PositionUnits.Distance) {
                    return this.StandardizePathDistance(pos);
                }

                var len = this.PathLength;
                if (len < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    return 0;
                }

                return this.StandardizePathDistance(pos * len) / len;
            },
            /*Cinemachine.CinemachinePathBase.StandardizeUnit end.*/

            /*Cinemachine.CinemachinePathBase.EvaluatePositionAtUnit start.*/
            /**
             * Get a worldspace position of a point along the path
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}                 pos      Postion along the path.  Need not be normalized.
             * @param   {number}                 units    The unit to use when interpreting the value of pos.
             * @return  {UnityEngine.Vector3}             World-space position of the point along at path at pos
             */
            EvaluatePositionAtUnit: function (pos, units) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#EvaluatePositionAtUnit", this ); }

                return this.EvaluatePosition(this.ToNativePathUnits(pos, units));
            },
            /*Cinemachine.CinemachinePathBase.EvaluatePositionAtUnit end.*/

            /*Cinemachine.CinemachinePathBase.EvaluateTangentAtUnit start.*/
            /**
             * Get the tangent of the curve at a point along the path.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}                 pos      Postion along the path.  Need not be normalized.
             * @param   {number}                 units    The unit to use when interpreting the value of pos.
             * @return  {UnityEngine.Vector3}             World-space direction of the path tangent.
                 Length of the vector represents the tangent strength
             */
            EvaluateTangentAtUnit: function (pos, units) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#EvaluateTangentAtUnit", this ); }

                return this.EvaluateTangent(this.ToNativePathUnits(pos, units));
            },
            /*Cinemachine.CinemachinePathBase.EvaluateTangentAtUnit end.*/

            /*Cinemachine.CinemachinePathBase.EvaluateOrientationAtUnit start.*/
            /**
             * Get the orientation the curve at a point along the path.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}                    pos      Postion along the path.  Need not be normalized.
             * @param   {number}                    units    The unit to use when interpreting the value of pos.
             * @return  {UnityEngine.Quaternion}             World-space orientation of the path
             */
            EvaluateOrientationAtUnit: function (pos, units) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#EvaluateOrientationAtUnit", this ); }

                return this.EvaluateOrientation(this.ToNativePathUnits(pos, units));
            },
            /*Cinemachine.CinemachinePathBase.EvaluateOrientationAtUnit end.*/

            /*Cinemachine.CinemachinePathBase.InvalidateDistanceCache start.*/
            /**
             * Call this if the path changes in such a way as to affect distances
                 or other cached path elements
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @return  {void}
             */
            InvalidateDistanceCache: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#InvalidateDistanceCache", this ); }

                this.m_DistanceToPos = null;
                this.m_PosToDistance = null;
                this.m_CachedSampleSteps = 0;
                this.m_PathLength = 0;
            },
            /*Cinemachine.CinemachinePathBase.InvalidateDistanceCache end.*/

            /*Cinemachine.CinemachinePathBase.DistanceCacheIsValid start.*/
            /**
             * See whether the distance cache is valid.  If it's not valid,
                 then any call to GetPathLength() or ToNativePathUnits() will
                 trigger a potentially costly regeneration of the path distance cache
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @return  {boolean}        Whether the cache is valid
             */
            DistanceCacheIsValid: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#DistanceCacheIsValid", this ); }

                return this.MaxPos === this.MinPos || this.m_DistanceToPos != null && this.m_PosToDistance != null && this.m_CachedSampleSteps === this.DistanceCacheSampleStepsPerSegment && this.m_CachedSampleSteps > 0;
            },
            /*Cinemachine.CinemachinePathBase.DistanceCacheIsValid end.*/

            /*Cinemachine.CinemachinePathBase.StandardizePathDistance start.*/
            /**
             * Standardize a distance along the path based on the path length.
                 If the distance cache is not valid, then calling this will
                 trigger a potentially costly regeneration of the path distance cache
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}    distance    The distance to standardize
             * @return  {number}                The standardized distance, ranging from 0 to path length
             */
            StandardizePathDistance: function (distance) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#StandardizePathDistance", this ); }

                var length = this.PathLength;
                if (length < pc.Vec3.kEpsilon) {
                    return 0;
                }

                if (this.Looped) {
                    distance = distance % length;
                    if (distance < 0) {
                        distance += length;
                    }
                }

                return Math.max(0, Math.min(distance, length));
            },
            /*Cinemachine.CinemachinePathBase.StandardizePathDistance end.*/

            /*Cinemachine.CinemachinePathBase.ToNativePathUnits start.*/
            /**
             * Get the path position (in native path units) corresponding to the psovided
                 value, in the units indicated.
                 If the distance cache is not valid, then calling this will
                 trigger a potentially costly regeneration of the path distance cache
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}    pos      The value to convert from
             * @param   {number}    units    The units in which pos is expressed
             * @return  {number}             The length of the path in native units, when sampled at this rate
             */
            ToNativePathUnits: function (pos, units) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#ToNativePathUnits", this ); }

                if (units === Cinemachine.CinemachinePathBase.PositionUnits.PathUnits) {
                    return pos;
                }

                if (this.DistanceCacheSampleStepsPerSegment < 1 || this.PathLength < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    return this.MinPos;
                }

                if (units === Cinemachine.CinemachinePathBase.PositionUnits.Normalized) {
                    pos *= this.PathLength;
                }

                pos = this.StandardizePathDistance(pos);
                var d = pos / this.m_cachedDistanceStepSize;
                var i = Math.floor(d);
                if (i >= this.m_DistanceToPos.length - 1) {
                    return this.MaxPos;
                }

                var t = d - i;
                return this.MinPos + pc.math.lerp(this.m_DistanceToPos[i], this.m_DistanceToPos[i + 1], t);
            },
            /*Cinemachine.CinemachinePathBase.ToNativePathUnits end.*/

            /*Cinemachine.CinemachinePathBase.FromPathNativeUnits start.*/
            /**
             * Get the path position (in path units) corresponding to this distance along the path.
                 If the distance cache is not valid, then calling this will
                 trigger a potentially costly regeneration of the path distance cache
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePathBase
             * @memberof Cinemachine.CinemachinePathBase
             * @param   {number}    pos      The value to convert from, in native units
             * @param   {number}    units    The units to convert toexpressed
             * @return  {number}             The length of the path in distance units, when sampled at this rate
             */
            FromPathNativeUnits: function (pos, units) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#FromPathNativeUnits", this ); }

                if (units === Cinemachine.CinemachinePathBase.PositionUnits.PathUnits) {
                    return pos;
                }

                var length = this.PathLength;
                if (this.DistanceCacheSampleStepsPerSegment < 1 || length < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    return 0;
                }

                pos = this.StandardizePos(pos);
                var d = pos / this.m_cachedPosStepSize;
                var i = Math.floor(d);
                if (i >= this.m_PosToDistance.length - 1) {
                    pos = this.m_PathLength;
                } else {
                    var t = d - i;
                    pos = pc.math.lerp(this.m_PosToDistance[i], this.m_PosToDistance[i + 1], t);
                }

                if (units === Cinemachine.CinemachinePathBase.PositionUnits.Normalized) {
                    pos /= length;
                }

                return pos;
            },
            /*Cinemachine.CinemachinePathBase.FromPathNativeUnits end.*/

            /*Cinemachine.CinemachinePathBase.ResamplePath start.*/
            ResamplePath: function (stepsPerSegment) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase#ResamplePath", this ); }

                this.InvalidateDistanceCache();

                var minPos = this.MinPos;
                var maxPos = this.MaxPos;
                var stepSize = 1.0 / UnityEngine.Mathf.Max(1, stepsPerSegment);

                // Sample the positions
                var numKeys = Math.round((maxPos - minPos) / stepSize) + 1;
                this.m_PosToDistance = System.Array.init(numKeys, 0, System.Single);
                this.m_CachedSampleSteps = stepsPerSegment;
                this.m_cachedPosStepSize = stepSize;

                var p0 = this.EvaluatePosition(0);
                this.m_PosToDistance[0] = 0;
                var pos = minPos;
                for (var i = 1; i < numKeys; ++i) {
                    pos += stepSize;
                    var p = this.EvaluatePosition(pos);
                    var d = pc.Vec3.distance( p0, p );
                    this.m_PathLength += d;
                    p0 = p.$clone();
                    this.m_PosToDistance[i] = this.m_PathLength;
                }

                // Resample the distances
                this.m_DistanceToPos = System.Array.init(numKeys, 0, System.Single);
                this.m_DistanceToPos[0] = 0;
                if (numKeys > 1) {
                    stepSize = this.m_PathLength / (numKeys - 1);
                    this.m_cachedDistanceStepSize = stepSize;
                    var distance = 0;
                    var posIndex = 1;
                    for (var i1 = 1; i1 < numKeys; ++i1) {
                        distance += stepSize;
                        var d1 = this.m_PosToDistance[posIndex];
                        while (d1 < distance && posIndex < numKeys - 1) {
                            d1 = this.m_PosToDistance[++posIndex];
                        }

                        var d0 = this.m_PosToDistance[posIndex - 1];
                        var delta = d1 - d0;
                        var t = (distance - d0) / delta;
                        this.m_DistanceToPos[i1] = this.m_cachedPosStepSize * (t + posIndex - 1);
                    }
                }
            },
            /*Cinemachine.CinemachinePathBase.ResamplePath end.*/


        }
    });
    /*Cinemachine.CinemachinePathBase end.*/

    /*Cinemachine.CinemachinePath+Waypoint start.*/
    /**
     * A waypoint along the path
     *
     * @public
     * @class Cinemachine.CinemachinePath.Waypoint
     */
    Bridge.define("Cinemachine.CinemachinePath.Waypoint", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath.Waypoint#getDefaultValue", this ); }
 return new Cinemachine.CinemachinePath.Waypoint(); }
            }
        },
        fields: {
            /**
             * Position in path-local space
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePath.Waypoint
             * @type UnityEngine.Vector3
             */
            position: null,
            /**
             * Offset from the position, which defines the tangent of the curve at the waypoint.
                 The length of the tangent encodes the strength of the bezier handle.
                 The same handle is used symmetrically on both sides of the waypoint, to ensure smoothness.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePath.Waypoint
             * @type UnityEngine.Vector3
             */
            tangent: null,
            /**
             * Defines the roll of the path at this waypoint.
                 The other orientation axes are inferred from the tangent and world up.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePath.Waypoint
             * @type number
             */
            roll: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath.Waypoint#init", this ); }

                this.position = new UnityEngine.Vector3();
                this.tangent = new UnityEngine.Vector3();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath.Waypoint#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath.Waypoint#getHashCode", this ); }

                var h = Bridge.addHash([3840395974, this.position, this.tangent, this.roll]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath.Waypoint#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachinePath.Waypoint)) {
                    return false;
                }
                return Bridge.equals(this.position, o.position) && Bridge.equals(this.tangent, o.tangent) && Bridge.equals(this.roll, o.roll);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath.Waypoint#$clone", this ); }

                var s = to || new Cinemachine.CinemachinePath.Waypoint();
                s.position = this.position.$clone();
                s.tangent = this.tangent.$clone();
                s.roll = this.roll;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachinePath+Waypoint end.*/

    /*Cinemachine.CinemachinePathBase+Appearance start.*/
    /**
     * This class holds the settings that control how the path
         will appear in the editor scene view.  The path is not visible in the game view
     *
     * @public
     * @class Cinemachine.CinemachinePathBase.Appearance
     */
    Bridge.define("Cinemachine.CinemachinePathBase.Appearance", {
        $kind: "nested class",
        fields: {
            inactivePathColor: null,
            pathColor: null,
            width: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePathBase.Appearance#init", this ); }

                this.inactivePathColor = new UnityEngine.Color();
                this.pathColor = new UnityEngine.Color();
                this.inactivePathColor = new pc.Color( 0.5, 0.5, 0.5, 1 );
                this.pathColor = new pc.Color( 0, 1, 0, 1 );
                this.width = 0.2;
            }
        }
    });
    /*Cinemachine.CinemachinePathBase+Appearance end.*/

    /*Cinemachine.CinemachinePathBase+PositionUnits start.*/
    /**
     * How to interpret the Path Position
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachinePathBase.PositionUnits", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Use PathPosition units, where 0 is first waypoint, 1 is second waypoint, etc
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                PathUnits: 0,
                /**
                 * Use Distance Along Path.  Path will be sampled according to its Resolution
                     setting, and a distance lookup table will be cached internally
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Distance: 1,
                /**
                 * Normalized units, where 0 is the start of the path, and 1 is the end.
                     Path will be sampled according to its Resolution
                     setting, and a distance lookup table will be cached internally
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Normalized: 2
            }
        }
    });
    /*Cinemachine.CinemachinePathBase+PositionUnits end.*/

    /*Cinemachine.CinemachinePipeline start.*/
    /**
     * Internal container for CinemachineComponentBase.  Does nothing but contain.
     *
     * @public
     * @class Cinemachine.CinemachinePipeline
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachinePipeline", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*Cinemachine.CinemachinePipeline end.*/

    /*Cinemachine.CinemachinePixelPerfect start.*/
    /**
     * An add-on module for Cinemachine Virtual Camera that tweaks the orthographic size
         of the virtual camera. It detects the presence of the Pixel Perfect Camera component and use the
         settings from that Pixel Perfect Camera to correct the orthographic size so that pixel art
         sprites would appear pixel perfect when the virtual camera becomes live.
     *
     * @public
     * @class Cinemachine.CinemachinePixelPerfect
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachinePixelPerfect", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*Cinemachine.CinemachinePixelPerfect end.*/

    /*Cinemachine.CinemachinePOV+RecenterTargetMode start.*/
    /**
     * Defines the recentering target: Recentering goes here
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachinePOV.RecenterTargetMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Just go to 0
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                None: 0,
                /**
                 * Axis angles are relative to Follow target's forward
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                FollowTargetForward: 1,
                /**
                 * Axis angles are relative to LookAt target's forward
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                LookAtTargetForward: 2
            }
        }
    });
    /*Cinemachine.CinemachinePOV+RecenterTargetMode end.*/

    /*Cinemachine.CinemachineSmoothPath+Waypoint start.*/
    /**
     * A waypoint along the path
     *
     * @public
     * @class Cinemachine.CinemachineSmoothPath.Waypoint
     */
    Bridge.define("Cinemachine.CinemachineSmoothPath.Waypoint", {
        $kind: "nested struct",
        statics: {
            methods: {
                /*Cinemachine.CinemachineSmoothPath+Waypoint.FromVector4:static start.*/
                FromVector4: function (v) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath.Waypoint#FromVector4", this ); }

                    var wp = new Cinemachine.CinemachineSmoothPath.Waypoint();
                    wp.position = new pc.Vec3( v.getitem(0), v.getitem(1), v.getitem(2) );
                    wp.roll = v.getitem(3);
                    return wp.$clone();
                },
                /*Cinemachine.CinemachineSmoothPath+Waypoint.FromVector4:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath.Waypoint#getDefaultValue", this ); }
 return new Cinemachine.CinemachineSmoothPath.Waypoint(); }
            }
        },
        fields: {
            /**
             * Position in path-local space
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineSmoothPath.Waypoint
             * @type UnityEngine.Vector3
             */
            position: null,
            /**
             * Defines the roll of the path at this waypoint.
                 The other orientation axes are inferred from the tangent and world up.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineSmoothPath.Waypoint
             * @type number
             */
            roll: 0
        },
        props: {
            /**
             * Representation as Vector4
             *
             * @instance
             * @readonly
             * @memberof Cinemachine.CinemachineSmoothPath.Waypoint
             * @function AsVector4
             * @type UnityEngine.Vector4
             */
            AsVector4: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath.Waypoint#AsVector4#get", this ); }

                    return new pc.Vec4( this.position.x, this.position.y, this.position.z, this.roll );
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath.Waypoint#init", this ); }

                this.position = new UnityEngine.Vector3();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath.Waypoint#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath.Waypoint#getHashCode", this ); }

                var h = Bridge.addHash([3840395974, this.position, this.roll]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath.Waypoint#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineSmoothPath.Waypoint)) {
                    return false;
                }
                return Bridge.equals(this.position, o.position) && Bridge.equals(this.roll, o.roll);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath.Waypoint#$clone", this ); }

                var s = to || new Cinemachine.CinemachineSmoothPath.Waypoint();
                s.position = this.position.$clone();
                s.roll = this.roll;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineSmoothPath+Waypoint end.*/

    /*Cinemachine.CinemachineStateDrivenCamera+HashPair start.*/
    Bridge.define("Cinemachine.CinemachineStateDrivenCamera.HashPair", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.HashPair#getDefaultValue", this ); }
 return new Cinemachine.CinemachineStateDrivenCamera.HashPair(); }
            }
        },
        fields: {
            parentHash: 0,
            hash: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.HashPair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.HashPair#getHashCode", this ); }

                var h = Bridge.addHash([3671900824, this.parentHash, this.hash]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.HashPair#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineStateDrivenCamera.HashPair)) {
                    return false;
                }
                return Bridge.equals(this.parentHash, o.parentHash) && Bridge.equals(this.hash, o.hash);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.HashPair#$clone", this ); }

                var s = to || new Cinemachine.CinemachineStateDrivenCamera.HashPair();
                s.parentHash = this.parentHash;
                s.hash = this.hash;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineStateDrivenCamera+HashPair end.*/

    /*Cinemachine.CinemachineStateDrivenCamera+Instruction start.*/
    /**
     * This represents a single instrunction to the StateDrivenCamera.  It associates
         an state from the state machine with a child Virtual Camera, and also holds
         activation tuning parameters.
     *
     * @public
     * @class Cinemachine.CinemachineStateDrivenCamera.Instruction
     */
    Bridge.define("Cinemachine.CinemachineStateDrivenCamera.Instruction", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.Instruction#getDefaultValue", this ); }
 return new Cinemachine.CinemachineStateDrivenCamera.Instruction(); }
            }
        },
        fields: {
            /**
             * The full hash of the animation state
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera.Instruction
             * @type number
             */
            m_FullHash: 0,
            /**
             * The virtual camera to activate whrn the animation state becomes active
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera.Instruction
             * @type Cinemachine.CinemachineVirtualCameraBase
             */
            m_VirtualCamera: null,
            /**
             * How long to wait (in seconds) before activating the virtual camera.
                 This filters out very short state durations
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera.Instruction
             * @type number
             */
            m_ActivateAfter: 0,
            /**
             * The minimum length of time (in seconds) to keep a virtual camera active
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera.Instruction
             * @type number
             */
            m_MinDuration: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.Instruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.Instruction#getHashCode", this ); }

                var h = Bridge.addHash([3913634596, this.m_FullHash, this.m_VirtualCamera, this.m_ActivateAfter, this.m_MinDuration]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.Instruction#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineStateDrivenCamera.Instruction)) {
                    return false;
                }
                return Bridge.equals(this.m_FullHash, o.m_FullHash) && Bridge.equals(this.m_VirtualCamera, o.m_VirtualCamera) && Bridge.equals(this.m_ActivateAfter, o.m_ActivateAfter) && Bridge.equals(this.m_MinDuration, o.m_MinDuration);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.Instruction#$clone", this ); }

                var s = to || new Cinemachine.CinemachineStateDrivenCamera.Instruction();
                s.m_FullHash = this.m_FullHash;
                s.m_VirtualCamera = this.m_VirtualCamera;
                s.m_ActivateAfter = this.m_ActivateAfter;
                s.m_MinDuration = this.m_MinDuration;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineStateDrivenCamera+Instruction end.*/

    /*Cinemachine.CinemachineStateDrivenCamera+ParentHash start.*/
    /**
     * Internal API for the Inspector editor.  This implements nested states.
     *
     * @class Cinemachine.CinemachineStateDrivenCamera.ParentHash
     */
    Bridge.define("Cinemachine.CinemachineStateDrivenCamera.ParentHash", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.ParentHash#getDefaultValue", this ); }
 return new Cinemachine.CinemachineStateDrivenCamera.ParentHash(); }
            }
        },
        fields: {
            /**
             * Internal API for the Inspector editor
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera.ParentHash
             * @type number
             */
            m_Hash: 0,
            /**
             * Internal API for the Inspector editor
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera.ParentHash
             * @type number
             */
            m_ParentHash: 0
        },
        ctors: {
            /**
             * Internal API for the Inspector editor
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineStateDrivenCamera.ParentHash
             * @memberof Cinemachine.CinemachineStateDrivenCamera.ParentHash
             * @param   {number}    h    
             * @param   {number}    p
             * @return  {void}
             */
            $ctor1: function (h, p) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.ParentHash#$ctor1", this ); }

                this.$initialize();
                this.m_Hash = h;
                this.m_ParentHash = p;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.ParentHash#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.ParentHash#getHashCode", this ); }

                var h = Bridge.addHash([3334159921, this.m_Hash, this.m_ParentHash]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.ParentHash#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineStateDrivenCamera.ParentHash)) {
                    return false;
                }
                return Bridge.equals(this.m_Hash, o.m_Hash) && Bridge.equals(this.m_ParentHash, o.m_ParentHash);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera.ParentHash#$clone", this ); }

                var s = to || new Cinemachine.CinemachineStateDrivenCamera.ParentHash();
                s.m_Hash = this.m_Hash;
                s.m_ParentHash = this.m_ParentHash;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineStateDrivenCamera+ParentHash end.*/

    /*Cinemachine.CinemachineStoryboard+CanvasInfo start.*/
    Bridge.define("Cinemachine.CinemachineStoryboard.CanvasInfo", {
        $kind: "nested class",
        fields: {
            mCanvas: null,
            mCanvasParent: null,
            mRawImage: null,
            mViewport: null
        }
    });
    /*Cinemachine.CinemachineStoryboard+CanvasInfo end.*/

    /*Cinemachine.CinemachineStoryboard+FillStrategy start.*/
    /**
     * How to fit the image in the frame, in the event that the aspect ratios don't match
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineStoryboard.FillStrategy", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Image will be as large as possible on the screen, without being cropped
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                BestFit: 0,
                /**
                 * Image will be cropped if necessary so that the screen is entirely filled
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                CropImageToFit: 1,
                /**
                 * Image will be stretched to cover any aspect mismatch with the screen
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                StretchToFit: 2
            }
        }
    });
    /*Cinemachine.CinemachineStoryboard+FillStrategy end.*/

    /*Cinemachine.ICinemachineTargetGroup start.*/
    Bridge.define("Cinemachine.ICinemachineTargetGroup", {
        $kind: "interface"
    });
    /*Cinemachine.ICinemachineTargetGroup end.*/

    /*Cinemachine.CinemachineTargetGroup+PositionMode start.*/
    /**
     * How the group's position is calculated
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineTargetGroup.PositionMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Group position will be the center of the group's axis-aligned bounding box
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                GroupCenter: 0,
                /**
                 * Group position will be the weighted average of the positions of the members
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                GroupAverage: 1
            }
        }
    });
    /*Cinemachine.CinemachineTargetGroup+PositionMode end.*/

    /*Cinemachine.CinemachineTargetGroup+RotationMode start.*/
    /**
     * How the group's orientation is calculated
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineTargetGroup.RotationMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Manually set in the group's transform
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Manual: 0,
                /**
                 * Weighted average of the orientation of its members.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                GroupAverage: 1
            }
        }
    });
    /*Cinemachine.CinemachineTargetGroup+RotationMode end.*/

    /*Cinemachine.CinemachineTargetGroup+Target start.*/
    /**
     * Holds the information that represents a member of the group
     *
     * @public
     * @class Cinemachine.CinemachineTargetGroup.Target
     */
    Bridge.define("Cinemachine.CinemachineTargetGroup.Target", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup.Target#getDefaultValue", this ); }
 return new Cinemachine.CinemachineTargetGroup.Target(); }
            }
        },
        fields: {
            /**
             * The target objects.  This object's position and orientation will contribute to the
                 group's average position and orientation, in accordance with its weight
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTargetGroup.Target
             * @type UnityEngine.Transform
             */
            target: null,
            /**
             * How much weight to give the target when averaging.  Cannot be negative
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTargetGroup.Target
             * @type number
             */
            weight: 0,
            /**
             * The radius of the target, used for calculating the bounding box.  Cannot be negative
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTargetGroup.Target
             * @type number
             */
            radius: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup.Target#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup.Target#getHashCode", this ); }

                var h = Bridge.addHash([1735579065, this.target, this.weight, this.radius]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup.Target#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineTargetGroup.Target)) {
                    return false;
                }
                return Bridge.equals(this.target, o.target) && Bridge.equals(this.weight, o.weight) && Bridge.equals(this.radius, o.radius);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup.Target#$clone", this ); }

                var s = to || new Cinemachine.CinemachineTargetGroup.Target();
                s.target = this.target;
                s.weight = this.weight;
                s.radius = this.radius;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineTargetGroup+Target end.*/

    /*Cinemachine.CinemachineTargetGroup+UpdateMethod start.*/
    /**
     * This enum defines the options available for the update method.
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineTargetGroup.UpdateMethod", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Updated in normal MonoBehaviour Update.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Update: 0,
                /**
                 * Updated in sync with the Physics module, in FixedUpdate
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                FixedUpdate: 1,
                /**
                 * Updated in MonoBehaviour LateUpdate.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                LateUpdate: 2
            }
        }
    });
    /*Cinemachine.CinemachineTargetGroup+UpdateMethod end.*/

    /*Cinemachine.CinemachineTrackedDolly+AutoDolly start.*/
    /**
     * Controls how automatic dollying occurs
     *
     * @public
     * @class Cinemachine.CinemachineTrackedDolly.AutoDolly
     */
    Bridge.define("Cinemachine.CinemachineTrackedDolly.AutoDolly", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly.AutoDolly#getDefaultValue", this ); }
 return new Cinemachine.CinemachineTrackedDolly.AutoDolly(); }
            }
        },
        fields: {
            /**
             * If checked, will enable automatic dolly, which chooses a path position
                 that is as close as possible to the Follow target.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly.AutoDolly
             * @type boolean
             */
            m_Enabled: false,
            /**
             * Offset, in current position units, from the closest point on the path to the follow target.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly.AutoDolly
             * @type number
             */
            m_PositionOffset: 0,
            /**
             * Search up to how many waypoints on either side of the current position.  Use 0 for Entire path
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly.AutoDolly
             * @type number
             */
            m_SearchRadius: 0,
            /**
             * We search between waypoints by dividing the segment into this many straight pieces.
                 The higher the number, the more accurate the result, but performance is
                 proportionally slower for higher numbers
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly.AutoDolly
             * @type number
             */
            m_SearchResolution: 0
        },
        ctors: {
            /**
             * Constructor with specific field values
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTrackedDolly.AutoDolly
             * @memberof Cinemachine.CinemachineTrackedDolly.AutoDolly
             * @param   {boolean}    enabled            
             * @param   {number}     positionOffset     
             * @param   {number}     searchRadius       
             * @param   {number}     stepsPerSegment
             * @return  {void}
             */
            $ctor1: function (enabled, positionOffset, searchRadius, stepsPerSegment) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly.AutoDolly#$ctor1", this ); }

                this.$initialize();
                this.m_Enabled = enabled;
                this.m_PositionOffset = positionOffset;
                this.m_SearchRadius = searchRadius;
                this.m_SearchResolution = stepsPerSegment;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly.AutoDolly#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly.AutoDolly#getHashCode", this ); }

                var h = Bridge.addHash([3688948990, this.m_Enabled, this.m_PositionOffset, this.m_SearchRadius, this.m_SearchResolution]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly.AutoDolly#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineTrackedDolly.AutoDolly)) {
                    return false;
                }
                return Bridge.equals(this.m_Enabled, o.m_Enabled) && Bridge.equals(this.m_PositionOffset, o.m_PositionOffset) && Bridge.equals(this.m_SearchRadius, o.m_SearchRadius) && Bridge.equals(this.m_SearchResolution, o.m_SearchResolution);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly.AutoDolly#$clone", this ); }

                var s = to || new Cinemachine.CinemachineTrackedDolly.AutoDolly();
                s.m_Enabled = this.m_Enabled;
                s.m_PositionOffset = this.m_PositionOffset;
                s.m_SearchRadius = this.m_SearchRadius;
                s.m_SearchResolution = this.m_SearchResolution;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineTrackedDolly+AutoDolly end.*/

    /*Cinemachine.CinemachineTrackedDolly+CameraUpMode start.*/
    /**
     * Different ways to set the camera's up vector
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineTrackedDolly.CameraUpMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Leave the camera's up vector alone.  It will be set according to the Brain's WorldUp.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Default: 0,
                /**
                 * Take the up vector from the path's up vector at the current point
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Path: 1,
                /**
                 * Take the up vector from the path's up vector at the current point, but with the roll zeroed out
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                PathNoRoll: 2,
                /**
                 * Take the up vector from the Follow target's up vector
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                FollowTarget: 3,
                /**
                 * Take the up vector from the Follow target's up vector, but with the roll zeroed out
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                FollowTargetNoRoll: 4
            }
        }
    });
    /*Cinemachine.CinemachineTrackedDolly+CameraUpMode end.*/

    /*Cinemachine.CinemachineTransposer+AngularDampingMode start.*/
    /**
     * How to calculate the angular damping for the target orientation
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineTransposer.AngularDampingMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Use Euler angles to specify damping values.
                     Subject to gimbal-lock fwhen pitch is steep.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Euler: 0,
                /**
                 * Use quaternions to calculate angular damping.
                     No per-channel control, but not susceptible to gimbal-lock
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Quaternion: 1
            }
        }
    });
    /*Cinemachine.CinemachineTransposer+AngularDampingMode end.*/

    /*Cinemachine.CinemachineTransposer+BindingMode start.*/
    /**
     * The coordinate space to use when interpreting the offset from the target
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineTransposer.BindingMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Camera will be bound to the Follow target using a frame of reference consisting
                     of the target's local frame at the moment when the virtual camera was enabled,
                     or when the target was assigned.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                LockToTargetOnAssign: 0,
                /**
                 * Camera will be bound to the Follow target using a frame of reference consisting
                     of the target's local frame, with the tilt and roll zeroed out.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                LockToTargetWithWorldUp: 1,
                /**
                 * Camera will be bound to the Follow target using a frame of reference consisting
                     of the target's local frame, with the roll zeroed out.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                LockToTargetNoRoll: 2,
                /**
                 * Camera will be bound to the Follow target using the target's local frame.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                LockToTarget: 3,
                /**
                 * Camera will be bound to the Follow target using a world space offset.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                WorldSpace: 4,
                /**
                 * Offsets will be calculated relative to the target, using Camera-local axes
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 5
                 * @type number
                 */
                SimpleFollowWithWorldUp: 5
            }
        }
    });
    /*Cinemachine.CinemachineTransposer+BindingMode end.*/

    /*Cinemachine.CinemachineTriggerAction start.*/
    /**
     * A multi-purpose script which causes an action to occur when
         a trigger collider is entered and exited.
     *
     * @public
     * @class Cinemachine.CinemachineTriggerAction
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Cinemachine.CinemachineTriggerAction", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            m_ActiveTriggerObjects: null,
            /**
             * Only triggers generated by objects on these layers will be considered.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction
             * @default 1
             * @type UnityEngine.LayerMask
             */
            m_LayerMask: null,
            /**
             * What action to take when an eligible object enters the collider or trigger zone
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction
             * @type Cinemachine.CinemachineTriggerAction.ActionSettings
             */
            m_OnObjectEnter: null,
            /**
             * What action to take when an eligible object exits the collider or trigger zone
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction
             * @type Cinemachine.CinemachineTriggerAction.ActionSettings
             */
            m_OnObjectExit: null,
            /**
             * Repeat the action for all subsequent trigger entries
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction
             * @default true
             * @type boolean
             */
            m_Repeating: false,
            /**
             * Skip this many trigger entries before taking action
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction
             * @type number
             */
            m_SkipFirst: 0,
            /**
             * Triggers generated by objects with this tag will be ignored
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction
             * @default ""
             * @type string
             */
            m_WithoutTag: null,
            /**
             * If set, only triggers generated by objects with this tag will be considered
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction
             * @default ""
             * @type string
             */
            m_WithTag: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#init", this ); }

                this.m_LayerMask = new UnityEngine.LayerMask();
                this.m_OnObjectEnter = new Cinemachine.CinemachineTriggerAction.ActionSettings();
                this.m_OnObjectExit = new Cinemachine.CinemachineTriggerAction.ActionSettings();
                this.m_ActiveTriggerObjects = new (System.Collections.Generic.HashSet$1(UnityEngine.GameObject)).ctor();
                this.m_LayerMask = UnityEngine.LayerMask.op_Implicit$1(1);
                this.m_OnObjectEnter = new Cinemachine.CinemachineTriggerAction.ActionSettings.$ctor1(Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Custom);
                this.m_OnObjectExit = new Cinemachine.CinemachineTriggerAction.ActionSettings.$ctor1(Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Custom);
                this.m_Repeating = true;
                this.m_WithoutTag = "";
                this.m_WithTag = "";
            }
        },
        methods: {
            /*Cinemachine.CinemachineTriggerAction.Filter start.*/
            Filter: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#Filter", this ); }

                if (!this.enabled) {
                    return false;
                }

                if (UnityEngine.LayerMask.op_Implicit((UnityEngine.LayerMask.op_BitwiseAnd(UnityEngine.LayerMask.op_Implicit$1((1 << other.layer)), this.m_LayerMask.$clone()))) === 0) {
                    return false;
                }

                if (this.m_WithTag.length !== 0 && !other.CompareTag(this.m_WithTag)) {
                    return false;
                }

                if (this.m_WithoutTag.length !== 0 && other.CompareTag(this.m_WithoutTag)) {
                    return false;
                }

                return true;
            },
            /*Cinemachine.CinemachineTriggerAction.Filter end.*/

            /*Cinemachine.CinemachineTriggerAction.InternalDoTriggerEnter start.*/
            InternalDoTriggerEnter: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#InternalDoTriggerEnter", this ); }

                if (!this.Filter(other)) {
                    return;
                }

                --this.m_SkipFirst;
                if (this.m_SkipFirst > -1) {
                    return;
                }

                if (!this.m_Repeating && this.m_SkipFirst !== -1) {
                    return;
                }

                this.m_ActiveTriggerObjects.add(other);
                this.m_OnObjectEnter.Invoke();
            },
            /*Cinemachine.CinemachineTriggerAction.InternalDoTriggerEnter end.*/

            /*Cinemachine.CinemachineTriggerAction.InternalDoTriggerExit start.*/
            InternalDoTriggerExit: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#InternalDoTriggerExit", this ); }

                if (!this.m_ActiveTriggerObjects.contains(other)) {
                    return;
                }

                this.m_ActiveTriggerObjects.remove(other);
                if (this.enabled) {
                    this.m_OnObjectExit.Invoke();
                }
            },
            /*Cinemachine.CinemachineTriggerAction.InternalDoTriggerExit end.*/

            /*Cinemachine.CinemachineTriggerAction.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnEnable", this ); }
 },
            /*Cinemachine.CinemachineTriggerAction.OnEnable end.*/

            /*Cinemachine.CinemachineTriggerAction.OnTriggerEnter start.*/
            OnTriggerEnter: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnTriggerEnter", this ); }

                this.InternalDoTriggerEnter(other.gameObject);
            },
            /*Cinemachine.CinemachineTriggerAction.OnTriggerEnter end.*/

            /*Cinemachine.CinemachineTriggerAction.OnTriggerExit start.*/
            OnTriggerExit: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnTriggerExit", this ); }

                this.InternalDoTriggerExit(other.gameObject);
            },
            /*Cinemachine.CinemachineTriggerAction.OnTriggerExit end.*/

            /*Cinemachine.CinemachineTriggerAction.OnCollisionEnter start.*/
            OnCollisionEnter: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnCollisionEnter", this ); }

                this.InternalDoTriggerEnter(other.gameObject);
            },
            /*Cinemachine.CinemachineTriggerAction.OnCollisionEnter end.*/

            /*Cinemachine.CinemachineTriggerAction.OnCollisionExit start.*/
            OnCollisionExit: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnCollisionExit", this ); }

                this.InternalDoTriggerExit(other.gameObject);
            },
            /*Cinemachine.CinemachineTriggerAction.OnCollisionExit end.*/

            /*Cinemachine.CinemachineTriggerAction.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnTriggerEnter2D", this ); }

                this.InternalDoTriggerEnter(other.gameObject);
            },
            /*Cinemachine.CinemachineTriggerAction.OnTriggerEnter2D end.*/

            /*Cinemachine.CinemachineTriggerAction.OnTriggerExit2D start.*/
            OnTriggerExit2D: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnTriggerExit2D", this ); }

                this.InternalDoTriggerExit(other.gameObject);
            },
            /*Cinemachine.CinemachineTriggerAction.OnTriggerExit2D end.*/

            /*Cinemachine.CinemachineTriggerAction.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnCollisionEnter2D", this ); }

                this.InternalDoTriggerEnter(other.gameObject);
            },
            /*Cinemachine.CinemachineTriggerAction.OnCollisionEnter2D end.*/

            /*Cinemachine.CinemachineTriggerAction.OnCollisionExit2D start.*/
            OnCollisionExit2D: function (other) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction#OnCollisionExit2D", this ); }

                this.InternalDoTriggerExit(other.gameObject);
            },
            /*Cinemachine.CinemachineTriggerAction.OnCollisionExit2D end.*/


        }
    });
    /*Cinemachine.CinemachineTriggerAction end.*/

    /*Cinemachine.CinemachineTriggerAction+ActionSettings start.*/
    /**
     * Defines what action to take on trigger enter/exit
     *
     * @public
     * @class Cinemachine.CinemachineTriggerAction.ActionSettings
     */
    Bridge.define("Cinemachine.CinemachineTriggerAction.ActionSettings", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction.ActionSettings#getDefaultValue", this ); }
 return new Cinemachine.CinemachineTriggerAction.ActionSettings(); }
            }
        },
        fields: {
            /**
             * What action to take
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction.ActionSettings
             * @type number
             */
            m_Action: 0,
            /**
             * The target object on which to operate.  If null, then the current behaviour/GameObject will be used
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction.ActionSettings
             * @type UnityEngine.Object
             */
            m_Target: null,
            /**
             * If PriorityBoost, this amount will be added to the virtual camera's priority
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction.ActionSettings
             * @type number
             */
            m_BoostAmount: 0,
            /**
             * If playing a timeline, start at this time
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction.ActionSettings
             * @type number
             */
            m_StartTime: 0,
            /**
             * How to interpret the start time
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction.ActionSettings
             * @type number
             */
            m_Mode: 0,
            /**
             * This event will be invoked
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTriggerAction.ActionSettings
             * @type Cinemachine.CinemachineTriggerAction.ActionSettings.TriggerEvent
             */
            m_Event: null
        },
        ctors: {
            /**
             * Constructor
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTriggerAction.ActionSettings
             * @memberof Cinemachine.CinemachineTriggerAction.ActionSettings
             * @param   {number}    action
             * @return  {void}
             */
            $ctor1: function (action) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction.ActionSettings#$ctor1", this ); }

                this.$initialize();
                this.m_Action = action;
                this.m_Target = null;
                this.m_BoostAmount = 0;
                this.m_StartTime = 0;
                this.m_Mode = Cinemachine.CinemachineTriggerAction.ActionSettings.TimeMode.FromStart;
                this.m_Event = new Cinemachine.CinemachineTriggerAction.ActionSettings.TriggerEvent();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction.ActionSettings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.CinemachineTriggerAction+ActionSettings.Invoke start.*/
            /**
             * Invoke the action.  Depending on the mode, different action will
                 be performed.  The embedded event will always be invoked, in addition to the
                 action specified by the Mode.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTriggerAction.ActionSettings
             * @memberof Cinemachine.CinemachineTriggerAction.ActionSettings
             * @return  {void}
             */
            Invoke: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction.ActionSettings#Invoke", this ); }

                var currentTarget = this.m_Target;
                if (currentTarget != null) {
                    var targetGameObject = Bridge.as(currentTarget, UnityEngine.GameObject);
                    var targetBehaviour = Bridge.as(currentTarget, UnityEngine.Behaviour);
                    if (UnityEngine.Component.op_Inequality(targetBehaviour, null)) {
                        targetGameObject = targetBehaviour.gameObject;
                    }

                    switch (this.m_Action) {
                        case Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Custom: 
                            break;
                        case Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.PriorityBoost: 
                            {
                                var vcam = targetGameObject.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                                if (UnityEngine.MonoBehaviour.op_Inequality(vcam, null)) {
                                    vcam.Priority += this.m_BoostAmount;
                                    vcam.MoveToTopOfPrioritySubqueue();
                                }

                                break;
                            }
                        case Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Activate: 
                            if (UnityEngine.GameObject.op_Inequality(targetGameObject, null)) {
                                targetGameObject.SetActive(true);
                                var vcam1 = targetGameObject.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                                if (UnityEngine.MonoBehaviour.op_Inequality(vcam1, null)) {
                                    vcam1.MoveToTopOfPrioritySubqueue();
                                }
                            }
                            break;
                        case Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Deactivate: 
                            if (UnityEngine.GameObject.op_Inequality(targetGameObject, null)) {
                                targetGameObject.SetActive(false);
                            }
                            break;
                        case Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Enable: 
                            {
                                if (UnityEngine.Component.op_Inequality(targetBehaviour, null)) {
                                    targetBehaviour.enabled = true;
                                }

                                break;
                            }
                        case Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Disable: 
                            {
                                if (UnityEngine.Component.op_Inequality(targetBehaviour, null)) {
                                    targetBehaviour.enabled = false;
                                }

                                break;
                            }
                        case Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Play: 
                            {
                                var playable = targetGameObject.GetComponent(UnityEngine.Playables.PlayableDirector);
                                if (UnityEngine.Component.op_Inequality(playable, null)) {
                                    var startTime = 0;
                                    var duration = playable.duration;
                                    var current = playable.time;
                                    switch (this.m_Mode) {
                                        default: 
                                        case Cinemachine.CinemachineTriggerAction.ActionSettings.TimeMode.FromStart: 
                                            startTime += this.m_StartTime;
                                            break;
                                        case Cinemachine.CinemachineTriggerAction.ActionSettings.TimeMode.FromEnd: 
                                            startTime = duration - this.m_StartTime;
                                            break;
                                        case Cinemachine.CinemachineTriggerAction.ActionSettings.TimeMode.BeforeNow: 
                                            startTime = current - this.m_StartTime;
                                            break;
                                        case Cinemachine.CinemachineTriggerAction.ActionSettings.TimeMode.AfterNow: 
                                            startTime = current + this.m_StartTime;
                                            break;
                                    }

                                    playable.time = startTime;
                                    playable.Play();
                                } else {
                                    var ani = targetGameObject.GetComponent(UnityEngine.Animation);
                                    if (UnityEngine.Component.op_Inequality(ani, null)) {
                                        ani.Play();
                                    }
                                }

                                break;
                            }
                        case Cinemachine.CinemachineTriggerAction.ActionSettings.Mode.Stop: 
                            {
                                var playable1 = targetGameObject.GetComponent(UnityEngine.Playables.PlayableDirector);
                                if (UnityEngine.Component.op_Inequality(playable1, null)) {
                                    playable1.Stop();
                                } else {
                                    var ani1 = targetGameObject.GetComponent(UnityEngine.Animation);
                                    if (UnityEngine.Component.op_Inequality(ani1, null)) {
                                        ani1.Stop();
                                    }
                                }

                                break;
                            }
                    }
                }

                this.m_Event.Invoke();
            },
            /*Cinemachine.CinemachineTriggerAction+ActionSettings.Invoke end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction.ActionSettings#getHashCode", this ); }

                var h = Bridge.addHash([5321636235, this.m_Action, this.m_Target, this.m_BoostAmount, this.m_StartTime, this.m_Mode, this.m_Event]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction.ActionSettings#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineTriggerAction.ActionSettings)) {
                    return false;
                }
                return Bridge.equals(this.m_Action, o.m_Action) && Bridge.equals(this.m_Target, o.m_Target) && Bridge.equals(this.m_BoostAmount, o.m_BoostAmount) && Bridge.equals(this.m_StartTime, o.m_StartTime) && Bridge.equals(this.m_Mode, o.m_Mode) && Bridge.equals(this.m_Event, o.m_Event);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTriggerAction.ActionSettings#$clone", this ); }

                var s = to || new Cinemachine.CinemachineTriggerAction.ActionSettings();
                s.m_Action = this.m_Action;
                s.m_Target = this.m_Target;
                s.m_BoostAmount = this.m_BoostAmount;
                s.m_StartTime = this.m_StartTime;
                s.m_Mode = this.m_Mode;
                s.m_Event = this.m_Event;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineTriggerAction+ActionSettings end.*/

    /*Cinemachine.CinemachineTriggerAction+ActionSettings+Mode start.*/
    /**
     * What action to take
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineTriggerAction.ActionSettings.Mode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Use the event only
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Custom: 0,
                /**
                 * Boost priority of virtual camera target
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                PriorityBoost: 1,
                /**
                 * Activate the target GameObject
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Activate: 2,
                /**
                 * Decativate target GameObject
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                Deactivate: 3,
                /**
                 * Enable a component
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                Enable: 4,
                /**
                 * Disable a component
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 5
                 * @type number
                 */
                Disable: 5,
                /**
                 * Start animation on target
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 6
                 * @type number
                 */
                Play: 6,
                /**
                 * Stop animation on target
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 7
                 * @type number
                 */
                Stop: 7
            }
        }
    });
    /*Cinemachine.CinemachineTriggerAction+ActionSettings+Mode end.*/

    /*Cinemachine.CinemachineTriggerAction+ActionSettings+TimeMode start.*/
    /**
     * How to interpret the start time
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineTriggerAction.ActionSettings.TimeMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                FromStart: 0,
                FromEnd: 1,
                BeforeNow: 2,
                AfterNow: 3
            }
        }
    });
    /*Cinemachine.CinemachineTriggerAction+ActionSettings+TimeMode end.*/

    /*Cinemachine.CinemachineTriggerAction+ActionSettings+TriggerEvent start.*/
    /**
     * Serializable parameterless game event
     *
     * @public
     * @class Cinemachine.CinemachineTriggerAction.ActionSettings.TriggerEvent
     * @augments UnityEngine.Events.UnityEvent
     */
    Bridge.define("Cinemachine.CinemachineTriggerAction.ActionSettings.TriggerEvent", {
        inherits: [UnityEngine.Events.UnityEvent],
        $kind: "nested class"
    });
    /*Cinemachine.CinemachineTriggerAction+ActionSettings+TriggerEvent end.*/

    /*Cinemachine.CinemachineVirtualCameraBase+BlendHint start.*/
    /**
     * Hint for blending to and from this virtual camera
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineVirtualCameraBase.BlendHint", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Standard linear position and aim blend
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                None: 0,
                /**
                 * Spherical blend about LookAt target position if there is a LookAt target, linear blend between LookAt targets
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                SphericalPosition: 1,
                /**
                 * Cylindrical blend about LookAt target position if there is a LookAt target (vertical co-ordinate is linearly
                     interpolated), linear blend between LookAt targets
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                CylindricalPosition: 2,
                /**
                 * Standard linear position blend, radial blend between LookAt targets
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                ScreenSpaceAimWhenTargetsDiffer: 3
            }
        }
    });
    /*Cinemachine.CinemachineVirtualCameraBase+BlendHint end.*/

    /*Cinemachine.CinemachineVirtualCameraBase+StandbyUpdateMode start.*/
    /**
     * How often to update a virtual camera when it is in Standby mode
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.CinemachineVirtualCameraBase.StandbyUpdateMode", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Only update if the virtual camera is Live
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Never: 0,
                /**
                 * Update the virtual camera every frame, even when it is not Live
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Always: 1,
                /**
                 * Update the virtual camera occasionally, the exact frequency depends
                     on how many other virtual cameras are in Standby
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                RoundRobin: 2
            }
        }
    });
    /*Cinemachine.CinemachineVirtualCameraBase+StandbyUpdateMode end.*/

    /*Cinemachine.CinemachineVirtualCameraBase+TransitionParams start.*/
    /**
     * Collection of parameters that influence how this virtual camera transitions from
         other virtual cameras
     *
     * @public
     * @class Cinemachine.CinemachineVirtualCameraBase.TransitionParams
     */
    Bridge.define("Cinemachine.CinemachineVirtualCameraBase.TransitionParams", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase.TransitionParams#getDefaultValue", this ); }
 return new Cinemachine.CinemachineVirtualCameraBase.TransitionParams(); }
            }
        },
        fields: {
            /**
             * Hint for blending positions to and from this virtual camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase.TransitionParams
             * @type number
             */
            m_BlendHint: 0,
            /**
             * When this virtual camera goes Live, attempt to force the position to be the same as the current position of
                 the Unity Camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase.TransitionParams
             * @type boolean
             */
            m_InheritPosition: false,
            /**
             * This event fires when the virtual camera goes Live
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase.TransitionParams
             * @type Cinemachine.CinemachineBrain.VcamActivatedEvent
             */
            m_OnCameraLive: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase.TransitionParams#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase.TransitionParams#getHashCode", this ); }

                var h = Bridge.addHash([7190326184, this.m_BlendHint, this.m_InheritPosition, this.m_OnCameraLive]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase.TransitionParams#equals", this ); }

                if (!Bridge.is(o, Cinemachine.CinemachineVirtualCameraBase.TransitionParams)) {
                    return false;
                }
                return Bridge.equals(this.m_BlendHint, o.m_BlendHint) && Bridge.equals(this.m_InheritPosition, o.m_InheritPosition) && Bridge.equals(this.m_OnCameraLive, o.m_OnCameraLive);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase.TransitionParams#$clone", this ); }

                var s = to || new Cinemachine.CinemachineVirtualCameraBase.TransitionParams();
                s.m_BlendHint = this.m_BlendHint;
                s.m_InheritPosition = this.m_InheritPosition;
                s.m_OnCameraLive = this.m_OnCameraLive;
                return s;
            }
        }
    });
    /*Cinemachine.CinemachineVirtualCameraBase+TransitionParams end.*/

    /*Cinemachine.DocumentationSortingAttribute start.*/
    /**
     * Atrtribute to control the automatic generation of documentation.
     *
     * @public
     * @class Cinemachine.DocumentationSortingAttribute
     * @augments System.Attribute
     */
    Bridge.define("Cinemachine.DocumentationSortingAttribute", {
        inherits: [System.Attribute],
        fields: {
            /**
             * Refinement level of the documentation.  The more refined, the more is excluded.
             *
             * @instance
             * @public
             * @memberof Cinemachine.DocumentationSortingAttribute
             * @function Category
             * @type number
             */
            Category: 0
        },
        ctors: {
            /**
             * Contructor with specific values
             *
             * @instance
             * @public
             * @this Cinemachine.DocumentationSortingAttribute
             * @memberof Cinemachine.DocumentationSortingAttribute
             * @param   {number}    category
             * @return  {void}
             */
            ctor: function (category) {
if ( TRACE ) { TRACE( "Cinemachine.DocumentationSortingAttribute#ctor", this ); }

                this.$initialize();
                System.Attribute.ctor.call(this);
                this.Category = category;
            }
        }
    });
    /*Cinemachine.DocumentationSortingAttribute end.*/

    /*Cinemachine.DocumentationSortingAttribute+Level start.*/
    /**
     * Refinement level of the documentation
     *
     * @public
     * @class number
     */
    Bridge.define("Cinemachine.DocumentationSortingAttribute.Level", {
        $kind: "nested enum",
        statics: {
            fields: {
                /**
                 * Type is excluded from documentation
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Undoc: 0,
                /**
                 * Type is documented in the API reference
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                API: 1,
                /**
                 * Type is documented in the highly-refined User Manual
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                UserRef: 2
            }
        }
    });
    /*Cinemachine.DocumentationSortingAttribute+Level end.*/

    /*Cinemachine.LensSettings start.*/
    /**
     * Describes the FOV and clip planes for a camera.  This generally mirrors the Unity Camera's
         lens settings, and will be used to drive the Unity camera when the vcam is active.
     *
     * @public
     * @class Cinemachine.LensSettings
     */
    Bridge.define("Cinemachine.LensSettings", {
        $kind: "struct",
        statics: {
            fields: {
                /**
                 * Default Lens Settings
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.LensSettings
                 * @type Cinemachine.LensSettings
                 */
                Default: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#init", this ); }

                    this.Default = new Cinemachine.LensSettings();
                    this.Default = new Cinemachine.LensSettings.$ctor1(40.0, 10.0, 0.1, 5000.0, 0);
                }
            },
            methods: {
                /*Cinemachine.LensSettings.FromCamera:static start.*/
                /**
                 * Creates a new LensSettings, copying the values from the
                     supplied Camera
                 *
                 * @static
                 * @public
                 * @this Cinemachine.LensSettings
                 * @memberof Cinemachine.LensSettings
                 * @param   {UnityEngine.Camera}          fromCamera    The Camera from which the FoV, near
                     and far clip planes will be copied.
                 * @return  {Cinemachine.LensSettings}
                 */
                FromCamera: function (fromCamera) {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#FromCamera", this ); }

                    var lens = Cinemachine.LensSettings.Default.$clone();
                    if (UnityEngine.Component.op_Inequality(fromCamera, null)) {
                        lens.FieldOfView = fromCamera.fieldOfView;
                        lens.OrthographicSize = fromCamera.orthographicSize;
                        lens.NearClipPlane = fromCamera.nearClipPlane;
                        lens.FarClipPlane = fromCamera.farClipPlane;
                        lens.SnapshotCameraReadOnlyProperties$1(fromCamera);

                    }

                    return lens.$clone();
                },
                /*Cinemachine.LensSettings.FromCamera:static end.*/

                /*Cinemachine.LensSettings.Lerp:static start.*/
                /**
                 * Linearly blends the fields of two LensSettings and returns the result
                 *
                 * @static
                 * @public
                 * @this Cinemachine.LensSettings
                 * @memberof Cinemachine.LensSettings
                 * @param   {Cinemachine.LensSettings}    lensA    The LensSettings to blend from
                 * @param   {Cinemachine.LensSettings}    lensB    The LensSettings to blend to
                 * @param   {number}                      t        The interpolation value. Internally clamped to the range [0,1]
                 * @return  {Cinemachine.LensSettings}             Interpolated settings
                 */
                Lerp: function (lensA, lensB, t) {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#Lerp", this ); }

                    t = Math.max(0, Math.min(1, t));
                    var blendedLens = new Cinemachine.LensSettings.ctor();
                    blendedLens.FarClipPlane = pc.math.lerp(lensA.FarClipPlane, lensB.FarClipPlane, t);
                    blendedLens.NearClipPlane = pc.math.lerp(lensA.NearClipPlane, lensB.NearClipPlane, t);
                    blendedLens.FieldOfView = pc.math.lerp(lensA.FieldOfView, lensB.FieldOfView, t);
                    blendedLens.OrthographicSize = pc.math.lerp(lensA.OrthographicSize, lensB.OrthographicSize, t);
                    blendedLens.Dutch = pc.math.lerp(lensA.Dutch, lensB.Dutch, t);
                    blendedLens.Orthographic = lensA.Orthographic && lensB.Orthographic;
                    blendedLens.IsPhysicalCamera = lensA.IsPhysicalCamera || lensB.IsPhysicalCamera;
                    blendedLens.SensorSize = new pc.Vec2().lerp( lensA.SensorSize, lensB.SensorSize, t );
                    blendedLens.LensShift = new pc.Vec2().lerp( lensA.LensShift, lensB.LensShift, t );

                    return blendedLens.$clone();
                },
                /*Cinemachine.LensSettings.Lerp:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#getDefaultValue", this ); }
 return new Cinemachine.LensSettings(); }
            }
        },
        fields: {
            /**
             * This is the camera view in vertical degrees. For cinematic people, a 50mm lens
                 on a super-35mm sensor would equal a 19.6 degree FOV
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @type number
             */
            FieldOfView: 0,
            /**
             * When using an orthographic camera, this defines the height, in world
                 co-ordinates, of the camera view.
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @type number
             */
            OrthographicSize: 0,
            /**
             * The near clip plane for this LensSettings
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @type number
             */
            NearClipPlane: 0,
            /**
             * The far clip plane for this LensSettings
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @type number
             */
            FarClipPlane: 0,
            /**
             * The dutch (tilt) to be applied to the camera. In degrees
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @type number
             */
            Dutch: 0,
            /**
             * This is set every frame by the virtual camera, based on the value found in the
                 currently associated Unity camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @function Orthographic
             * @type boolean
             */
            Orthographic: false,
            /**
             * This is set every frame by the virtual camera, based on the value
                 found in the currently associated Unity camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @function SensorSize
             * @type UnityEngine.Vector2
             */
            SensorSize: null,
            /**
             * This is set every frame by the virtual camera, based on the value
                 found in the currently associated Unity camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @function IsPhysicalCamera
             * @type boolean
             */
            IsPhysicalCamera: false,
            /**
             * For physical cameras only: position of the gate relative to the film back
             *
             * @instance
             * @public
             * @memberof Cinemachine.LensSettings
             * @type UnityEngine.Vector2
             */
            LensShift: null
        },
        props: {
            /**
             * Sensor aspect, not screen aspect.  For nonphysical cameras, this is the same thing.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.LensSettings
             * @function Aspect
             * @type number
             */
            Aspect: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#Aspect#get", this ); }

                    return this.SensorSize.y === 0 ? 1.0 : this.SensorSize.x / this.SensorSize.y;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#init", this ); }

                this.SensorSize = new UnityEngine.Vector2();
                this.LensShift = new UnityEngine.Vector2();
            },
            /**
             * Explicit constructor for this LensSettings
             *
             * @instance
             * @public
             * @this Cinemachine.LensSettings
             * @memberof Cinemachine.LensSettings
             * @param   {number}    fov                 The Vertical field of view
             * @param   {number}    orthographicSize    If orthographic, this is the half-height of the screen
             * @param   {number}    nearClip            The near clip plane
             * @param   {number}    farClip             The far clip plane
             * @param   {number}    dutch               Camera roll, in degrees.  This is applied at the end
                 after shot composition.
             * @return  {void}
             */
            $ctor1: function (fov, orthographicSize, nearClip, farClip, dutch) {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#$ctor1", this ); }

                Cinemachine.LensSettings.ctor.call(this);
                this.FieldOfView = fov;
                this.OrthographicSize = orthographicSize;
                this.NearClipPlane = nearClip;
                this.FarClipPlane = farClip;
                this.Dutch = dutch;

            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.LensSettings.SnapshotCameraReadOnlyProperties$1 start.*/
            /**
             * Snapshot the properties that are read-only in the Camera
             *
             * @instance
             * @public
             * @this Cinemachine.LensSettings
             * @memberof Cinemachine.LensSettings
             * @param   {UnityEngine.Camera}    camera    The Camera from which we will take the info
             * @return  {void}
             */
            SnapshotCameraReadOnlyProperties$1: function (camera) {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#SnapshotCameraReadOnlyProperties$1", this ); }

                if (UnityEngine.Component.op_Inequality(camera, null)) {
                    this.Orthographic = camera.orthographic;
                    this.SensorSize = new pc.Vec2( camera.aspect, 1.0 );
                }
            },
            /*Cinemachine.LensSettings.SnapshotCameraReadOnlyProperties$1 end.*/

            /*Cinemachine.LensSettings.SnapshotCameraReadOnlyProperties start.*/
            /**
             * Snapshot the properties that are read-only in the Camera
             *
             * @instance
             * @public
             * @this Cinemachine.LensSettings
             * @memberof Cinemachine.LensSettings
             * @param   {Cinemachine.LensSettings}    lens    The LensSettings from which we will take the info
             * @return  {void}
             */
            SnapshotCameraReadOnlyProperties: function (lens) {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#SnapshotCameraReadOnlyProperties", this ); }

                this.Orthographic = lens.v.Orthographic;
                this.SensorSize = lens.v.SensorSize.$clone();
            },
            /*Cinemachine.LensSettings.SnapshotCameraReadOnlyProperties end.*/

            /*Cinemachine.LensSettings.Validate start.*/
            /**
             * Make sure lens settings are sane.  Call this from OnValidate().
             *
             * @instance
             * @public
             * @this Cinemachine.LensSettings
             * @memberof Cinemachine.LensSettings
             * @return  {void}
             */
            Validate: function () {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#Validate", this ); }

                this.NearClipPlane = UnityEngine.Mathf.Max(this.NearClipPlane, this.Orthographic ? 0 : 0.001);
                this.FarClipPlane = UnityEngine.Mathf.Max(this.FarClipPlane, this.NearClipPlane + 0.001);
                this.FieldOfView = Math.max(0.01, Math.min(this.FieldOfView, 179.0));
            },
            /*Cinemachine.LensSettings.Validate end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#getHashCode", this ); }

                var h = Bridge.addHash([5826558216, this.FieldOfView, this.OrthographicSize, this.NearClipPlane, this.FarClipPlane, this.Dutch, this.Orthographic, this.SensorSize, this.IsPhysicalCamera, this.LensShift]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#equals", this ); }

                if (!Bridge.is(o, Cinemachine.LensSettings)) {
                    return false;
                }
                return Bridge.equals(this.FieldOfView, o.FieldOfView) && Bridge.equals(this.OrthographicSize, o.OrthographicSize) && Bridge.equals(this.NearClipPlane, o.NearClipPlane) && Bridge.equals(this.FarClipPlane, o.FarClipPlane) && Bridge.equals(this.Dutch, o.Dutch) && Bridge.equals(this.Orthographic, o.Orthographic) && Bridge.equals(this.SensorSize, o.SensorSize) && Bridge.equals(this.IsPhysicalCamera, o.IsPhysicalCamera) && Bridge.equals(this.LensShift, o.LensShift);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.LensSettings#$clone", this ); }

                var s = to || new Cinemachine.LensSettings();
                s.FieldOfView = this.FieldOfView;
                s.OrthographicSize = this.OrthographicSize;
                s.NearClipPlane = this.NearClipPlane;
                s.FarClipPlane = this.FarClipPlane;
                s.Dutch = this.Dutch;
                s.Orthographic = this.Orthographic;
                s.SensorSize = this.SensorSize.$clone();
                s.IsPhysicalCamera = this.IsPhysicalCamera;
                s.LensShift = this.LensShift.$clone();
                return s;
            }
        },
        overloads: {
            "SnapshotCameraReadOnlyProperties(Camera)": "SnapshotCameraReadOnlyProperties$1"
        }
    });
    /*Cinemachine.LensSettings end.*/

    /*Cinemachine.LensSettingsPropertyAttribute start.*/
    /**
     * Property applied to LensSettings.  Used for custom drawing in the inspector.
     *
     * @public
     * @class Cinemachine.LensSettingsPropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.LensSettingsPropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.LensSettingsPropertyAttribute end.*/

    /*Cinemachine.NoiseSettings+NoiseParams start.*/
    /**
     * Describes the behaviour for a channel of noise
     *
     * @public
     * @class Cinemachine.NoiseSettings.NoiseParams
     */
    Bridge.define("Cinemachine.NoiseSettings.NoiseParams", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.NoiseParams#getDefaultValue", this ); }
 return new Cinemachine.NoiseSettings.NoiseParams(); }
            }
        },
        fields: {
            /**
             * The frequency of noise for this channel.  Higher magnitudes vibrate faster
             *
             * @instance
             * @public
             * @memberof Cinemachine.NoiseSettings.NoiseParams
             * @type number
             */
            Frequency: 0,
            /**
             * The amplitude of the noise for this channel.  Larger numbers vibrate higher
             *
             * @instance
             * @public
             * @memberof Cinemachine.NoiseSettings.NoiseParams
             * @type number
             */
            Amplitude: 0,
            /**
             * If checked, then the amplitude and frequency will not be randomized
             *
             * @instance
             * @public
             * @memberof Cinemachine.NoiseSettings.NoiseParams
             * @type boolean
             */
            Constant: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.NoiseParams#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.NoiseSettings+NoiseParams.GetValueAt start.*/
            /**
             * Get the signal value at a given time, offset by a given amount
             *
             * @instance
             * @public
             * @this Cinemachine.NoiseSettings.NoiseParams
             * @memberof Cinemachine.NoiseSettings.NoiseParams
             * @param   {number}    time          
             * @param   {number}    timeOffset
             * @return  {number}
             */
            GetValueAt: function (time, timeOffset) {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.NoiseParams#GetValueAt", this ); }

                var t = this.Frequency * time + timeOffset;
                if (this.Constant) {
                    return Math.cos(t * 2 * UnityEngine.Mathf.PI) * this.Amplitude * 0.5;
                }

                return (pc.noise.perlin2(t, 0.0) - 0.5) * this.Amplitude;
            },
            /*Cinemachine.NoiseSettings+NoiseParams.GetValueAt end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.NoiseParams#getHashCode", this ); }

                var h = Bridge.addHash([3862834452, this.Frequency, this.Amplitude, this.Constant]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.NoiseParams#equals", this ); }

                if (!Bridge.is(o, Cinemachine.NoiseSettings.NoiseParams)) {
                    return false;
                }
                return Bridge.equals(this.Frequency, o.Frequency) && Bridge.equals(this.Amplitude, o.Amplitude) && Bridge.equals(this.Constant, o.Constant);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.NoiseParams#$clone", this ); }

                var s = to || new Cinemachine.NoiseSettings.NoiseParams();
                s.Frequency = this.Frequency;
                s.Amplitude = this.Amplitude;
                s.Constant = this.Constant;
                return s;
            }
        }
    });
    /*Cinemachine.NoiseSettings+NoiseParams end.*/

    /*Cinemachine.NoiseSettings+TransformNoiseParams start.*/
    /**
     * Contains the behaviour of noise for the noise module for all 3 cardinal axes of the camera
     *
     * @public
     * @class Cinemachine.NoiseSettings.TransformNoiseParams
     */
    Bridge.define("Cinemachine.NoiseSettings.TransformNoiseParams", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.TransformNoiseParams#getDefaultValue", this ); }
 return new Cinemachine.NoiseSettings.TransformNoiseParams(); }
            }
        },
        fields: {
            /**
             * Noise definition for X-axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.NoiseSettings.TransformNoiseParams
             * @type Cinemachine.NoiseSettings.NoiseParams
             */
            X: null,
            /**
             * Noise definition for Y-axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.NoiseSettings.TransformNoiseParams
             * @type Cinemachine.NoiseSettings.NoiseParams
             */
            Y: null,
            /**
             * Noise definition for Z-axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.NoiseSettings.TransformNoiseParams
             * @type Cinemachine.NoiseSettings.NoiseParams
             */
            Z: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.TransformNoiseParams#init", this ); }

                this.X = new Cinemachine.NoiseSettings.NoiseParams();
                this.Y = new Cinemachine.NoiseSettings.NoiseParams();
                this.Z = new Cinemachine.NoiseSettings.NoiseParams();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.TransformNoiseParams#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Cinemachine.NoiseSettings+TransformNoiseParams.GetValueAt start.*/
            /**
             * Get the signal value at a given time, offset by a given amount
             *
             * @instance
             * @public
             * @this Cinemachine.NoiseSettings.TransformNoiseParams
             * @memberof Cinemachine.NoiseSettings.TransformNoiseParams
             * @param   {number}                 time           
             * @param   {UnityEngine.Vector3}    timeOffsets
             * @return  {UnityEngine.Vector3}
             */
            GetValueAt: function (time, timeOffsets) {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.TransformNoiseParams#GetValueAt", this ); }

                return new pc.Vec3( this.X.GetValueAt(time, timeOffsets.x), this.Y.GetValueAt(time, timeOffsets.y), this.Z.GetValueAt(time, timeOffsets.z) );
            },
            /*Cinemachine.NoiseSettings+TransformNoiseParams.GetValueAt end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.TransformNoiseParams#getHashCode", this ); }

                var h = Bridge.addHash([9109892633, this.X, this.Y, this.Z]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.TransformNoiseParams#equals", this ); }

                if (!Bridge.is(o, Cinemachine.NoiseSettings.TransformNoiseParams)) {
                    return false;
                }
                return Bridge.equals(this.X, o.X) && Bridge.equals(this.Y, o.Y) && Bridge.equals(this.Z, o.Z);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings.TransformNoiseParams#$clone", this ); }

                var s = to || new Cinemachine.NoiseSettings.TransformNoiseParams();
                s.X = this.X.$clone();
                s.Y = this.Y.$clone();
                s.Z = this.Z.$clone();
                return s;
            }
        }
    });
    /*Cinemachine.NoiseSettings+TransformNoiseParams end.*/

    /*Cinemachine.NoiseSettingsPropertyAttribute start.*/
    /**
     * Property field is a NoiseSettings asset.
     *
     * @public
     * @class Cinemachine.NoiseSettingsPropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.NoiseSettingsPropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.NoiseSettingsPropertyAttribute end.*/

    /*Cinemachine.NoSaveDuringPlayAttribute start.*/
    /**
     * Suppresses play-mode-save for a field.  Use it if the calsee has [SaveDuringPlay]
         attribute but there are fields in the class that shouldn't be saved.
     *
     * @public
     * @class Cinemachine.NoSaveDuringPlayAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.NoSaveDuringPlayAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.NoSaveDuringPlayAttribute end.*/

    /*Cinemachine.OrbitalTransposerHeadingPropertyAttribute start.*/
    /**
     * Property applied to OrbitalTransposer.Heading.  Used for custom drawing in the inspector.
     *
     * @public
     * @class Cinemachine.OrbitalTransposerHeadingPropertyAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.OrbitalTransposerHeadingPropertyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.OrbitalTransposerHeadingPropertyAttribute end.*/

    /*Cinemachine.PostFX.CinemachinePostProcessing start.*/
    Bridge.define("Cinemachine.PostFX.CinemachinePostProcessing", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*Cinemachine.PostFX.CinemachinePostProcessing end.*/

    /*Cinemachine.PostFX.CinemachineVolumeSettings start.*/
    Bridge.define("Cinemachine.PostFX.CinemachineVolumeSettings", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*Cinemachine.PostFX.CinemachineVolumeSettings end.*/

    /*Cinemachine.RuntimeUtility start.*/
    /**
     * An ad-hoc collection of helpers, used by Cinemachine
         or its editor tools in various places
     *
     * @static
     * @abstract
     * @public
     * @class Cinemachine.RuntimeUtility
     */
    Bridge.define("Cinemachine.RuntimeUtility", {
        statics: {
            methods: {
                /*Cinemachine.RuntimeUtility.DestroyObject:static start.*/
                /**
                 * Convenience to destroy an object, using the appropriate method depending
                     on whether the game is playing
                 *
                 * @static
                 * @public
                 * @this Cinemachine.RuntimeUtility
                 * @memberof Cinemachine.RuntimeUtility
                 * @param   {UnityEngine.Object}    obj    The object to destroy
                 * @return  {void}
                 */
                DestroyObject: function (obj) {
if ( TRACE ) { TRACE( "Cinemachine.RuntimeUtility#DestroyObject", this ); }

                    if (obj != null) {
                        UnityEngine.Object.Destroy(obj);
                    }
                },
                /*Cinemachine.RuntimeUtility.DestroyObject:static end.*/


            }
        }
    });
    /*Cinemachine.RuntimeUtility end.*/

    /*Cinemachine.SaveDuringPlayAttribute start.*/
    /**
     * Invoke play-mode-save for a class.  This class's fields will be scanned
         upon exiting play mode, and its property values will be applied to the scene object.
         This is a stopgap measure that will become obsolete once Unity implements
         play-mode-save in a more general way.
     *
     * @public
     * @class Cinemachine.SaveDuringPlayAttribute
     * @augments System.Attribute
     */
    Bridge.define("Cinemachine.SaveDuringPlayAttribute", {
        inherits: [System.Attribute]
    });
    /*Cinemachine.SaveDuringPlayAttribute end.*/

    /*Cinemachine.TagFieldAttribute start.*/
    /**
     * Property field is a Tag.
     *
     * @public
     * @class Cinemachine.TagFieldAttribute
     * @augments UnityEngine.PropertyAttribute
     */
    Bridge.define("Cinemachine.TagFieldAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*Cinemachine.TagFieldAttribute end.*/

    /*Cinemachine.UpdateTracker start.*/
    /**
     * Attempt to track on what clock transforms get updated
     *
     * @class Cinemachine.UpdateTracker
     */
    Bridge.define("Cinemachine.UpdateTracker", {
        statics: {
            fields: {
                mUpdateStatus: null,
                sToDelete: null,
                mLastUpdateTime: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker#init", this ); }

                    this.mUpdateStatus = new (System.Collections.Generic.Dictionary$2(UnityEngine.Transform,Cinemachine.UpdateTracker.UpdateStatus)).ctor();
                    this.sToDelete = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                }
            },
            methods: {
                /*Cinemachine.UpdateTracker.InitializeModule:static start.*/
                InitializeModule: function () {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker#InitializeModule", this ); }

                    Cinemachine.UpdateTracker.mUpdateStatus.clear();
                },
                /*Cinemachine.UpdateTracker.InitializeModule:static end.*/

                /*Cinemachine.UpdateTracker.UpdateTargets:static start.*/
                UpdateTargets: function (currentClock) {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker#UpdateTargets", this ); }

                    // Update the registry for all known targets
                    var now = UnityEngine.Time.frameCount;
                    var iter = Cinemachine.UpdateTracker.mUpdateStatus.GetEnumerator();
                    while (iter.moveNext()) {
                        var current = iter.Current;
                        if (UnityEngine.Component.op_Equality(current.key, null)) {
                            Cinemachine.UpdateTracker.sToDelete.add(current.key); // target was deleted
                        } else {
                            current.value.OnUpdate(now, currentClock, current.key.localToWorldMatrix.$clone());
                        }
                    }

                    for (var i = Cinemachine.UpdateTracker.sToDelete.Count - 1; i >= 0; --i) {
                        Cinemachine.UpdateTracker.mUpdateStatus.remove(Cinemachine.UpdateTracker.sToDelete.getItem(i));
                    }

                    Cinemachine.UpdateTracker.sToDelete.clear();
                },
                /*Cinemachine.UpdateTracker.UpdateTargets:static end.*/

                /*Cinemachine.UpdateTracker.GetPreferredUpdate:static start.*/
                GetPreferredUpdate: function (target) {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker#GetPreferredUpdate", this ); }

                    if (UnityEngine.Application.isPlaying && UnityEngine.Component.op_Inequality(target, null)) {
                        var status = { };
                        if (Cinemachine.UpdateTracker.mUpdateStatus.tryGetValue(target, status)) {
                            return status.v.PreferredUpdate;
                        }

                        // Add the target to the registry
                        status.v = new Cinemachine.UpdateTracker.UpdateStatus(UnityEngine.Time.frameCount, target.localToWorldMatrix.$clone());
                        Cinemachine.UpdateTracker.mUpdateStatus.add(target, status.v);
                    }

                    return Cinemachine.UpdateTracker.UpdateClock.Late;
                },
                /*Cinemachine.UpdateTracker.GetPreferredUpdate:static end.*/

                /*Cinemachine.UpdateTracker.OnUpdate:static start.*/
                OnUpdate: function (currentClock) {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker#OnUpdate", this ); }

                    // Do something only if we are the first controller processing this frame
                    var now = UnityEngine.Time.time;
                    if (now !== Cinemachine.UpdateTracker.mLastUpdateTime) {
                        Cinemachine.UpdateTracker.mLastUpdateTime = now;
                        Cinemachine.UpdateTracker.UpdateTargets(currentClock);
                    }
                },
                /*Cinemachine.UpdateTracker.OnUpdate:static end.*/


            }
        }
    });
    /*Cinemachine.UpdateTracker end.*/

    /*Cinemachine.UpdateTracker+UpdateClock start.*/
    Bridge.define("Cinemachine.UpdateTracker.UpdateClock", {
        $kind: "nested enum",
        statics: {
            fields: {
                Fixed: 0,
                Late: 1
            }
        }
    });
    /*Cinemachine.UpdateTracker+UpdateClock end.*/

    /*Cinemachine.UpdateTracker+UpdateStatus start.*/
    Bridge.define("Cinemachine.UpdateTracker.UpdateStatus", {
        $kind: "nested class",
        statics: {
            fields: {
                kWindowSize: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker.UpdateStatus#init", this ); }

                    this.kWindowSize = 30;
                }
            }
        },
        fields: {
            windowStart: 0,
            numWindowLateUpdateMoves: 0,
            numWindowFixedUpdateMoves: 0,
            numWindows: 0,
            lastFrameUpdated: 0,
            lastPos: null,
            PreferredUpdate: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker.UpdateStatus#init", this ); }

                this.lastPos = new UnityEngine.Matrix4x4();
            },
            ctor: function (currentFrame, pos) {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker.UpdateStatus#ctor", this ); }

                this.$initialize();
                this.windowStart = currentFrame;
                this.lastFrameUpdated = UnityEngine.Time.frameCount;
                this.PreferredUpdate = Cinemachine.UpdateTracker.UpdateClock.Late;
                this.lastPos = pos.$clone();
            }
        },
        methods: {
            /*Cinemachine.UpdateTracker+UpdateStatus.OnUpdate start.*/
            OnUpdate: function (currentFrame, currentClock, pos) {
if ( TRACE ) { TRACE( "Cinemachine.UpdateTracker.UpdateStatus#OnUpdate", this ); }

                if (pc.Mat4.equals( this.lastPos, pos )) {
                    return;
                }

                if (currentClock === Cinemachine.UpdateTracker.UpdateClock.Late) {
                    ++this.numWindowLateUpdateMoves;
                } else if (this.lastFrameUpdated !== currentFrame) {
                    ++this.numWindowFixedUpdateMoves;
                }

                this.lastPos = pos.$clone();

                var choice = new Cinemachine.UpdateTracker.UpdateClock();
                if (this.numWindowFixedUpdateMoves > 3 && this.numWindowLateUpdateMoves < this.numWindowFixedUpdateMoves / 3) {
                    choice = Cinemachine.UpdateTracker.UpdateClock.Fixed;
                } else {
                    choice = Cinemachine.UpdateTracker.UpdateClock.Late;
                }

                if (this.numWindows === 0) {
                    this.PreferredUpdate = choice;
                }

                if (this.windowStart + Cinemachine.UpdateTracker.UpdateStatus.kWindowSize <= currentFrame) {
                    this.PreferredUpdate = choice;
                    ++this.numWindows;
                    this.windowStart = currentFrame;
                    this.numWindowLateUpdateMoves = this.PreferredUpdate === Cinemachine.UpdateTracker.UpdateClock.Late ? 1 : 0;
                    this.numWindowFixedUpdateMoves = this.PreferredUpdate === Cinemachine.UpdateTracker.UpdateClock.Fixed ? 1 : 0;
                }
            },
            /*Cinemachine.UpdateTracker+UpdateStatus.OnUpdate end.*/


        }
    });
    /*Cinemachine.UpdateTracker+UpdateStatus end.*/
    /**
     * @memberof Cinemachine.Utility
     * @callback Cinemachine.Utility.CinemachineDebug.OnGUIDelegate
     * @return  {void}
     */


    /*Cinemachine.Utility.CinemachineDebug start.*/
    /** @namespace Cinemachine.Utility */

    /**
     * Manages onscreen positions for Cinemachine debugging output
     *
     * @public
     * @class Cinemachine.Utility.CinemachineDebug
     */
    Bridge.define("Cinemachine.Utility.CinemachineDebug", {
        statics: {
            fields: {
                mClients: null,
                /**
                 * Delegate for OnGUI debugging.
                     This will be called by the CinemachineBrain in its OnGUI (editor only)
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.Utility.CinemachineDebug
                 * @type Cinemachine.Utility.CinemachineDebug.OnGUIDelegate
                 */
                OnGUIHandlers: null,
                mAvailableStringBuilders: null
            },
            methods: {
                /*Cinemachine.Utility.CinemachineDebug.ReleaseScreenPos:static start.*/
                /**
                 * Release a screen rectangle previously obtained through GetScreenPos()
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.CinemachineDebug
                 * @memberof Cinemachine.Utility.CinemachineDebug
                 * @param   {UnityEngine.Object}    client    The client caller.  Used as a handle.
                 * @return  {void}
                 */
                ReleaseScreenPos: function (client) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.CinemachineDebug#ReleaseScreenPos", this ); }

                    if (Cinemachine.Utility.CinemachineDebug.mClients != null && Cinemachine.Utility.CinemachineDebug.mClients.contains(client)) {
                        Cinemachine.Utility.CinemachineDebug.mClients.remove(client);
                    }
                },
                /*Cinemachine.Utility.CinemachineDebug.ReleaseScreenPos:static end.*/

                /*Cinemachine.Utility.CinemachineDebug.GetScreenPos:static start.*/
                /**
                 * Reserve an on-screen rectangle for debugging output.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.CinemachineDebug
                 * @memberof Cinemachine.Utility.CinemachineDebug
                 * @param   {UnityEngine.Object}      client    The client caller.  This is used as a handle.
                 * @param   {string}                  text      Sample text, for determining rectangle size
                 * @param   {UnityEngine.GUIStyle}    style     What style will be used to draw, used here for
                     determining rect size
                 * @return  {UnityEngine.Rect}                  An area on the game screen large enough to print the text
                     in the style indicated
                 */
                GetScreenPos: function (client, text, style) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.CinemachineDebug#GetScreenPos", this ); }

                    var $t;
                    if (Cinemachine.Utility.CinemachineDebug.mClients == null) {
                        Cinemachine.Utility.CinemachineDebug.mClients = new (System.Collections.Generic.HashSet$1(UnityEngine.Object)).ctor();
                    }

                    if (!Cinemachine.Utility.CinemachineDebug.mClients.contains(client)) {
                        Cinemachine.Utility.CinemachineDebug.mClients.add(client);
                    }

                    var pos = new pc.Vec2( 0, 0 );
                    var size = style.CalcSize(new UnityEngine.GUIContent.$ctor1(text));
                    if (Cinemachine.Utility.CinemachineDebug.mClients != null) {
                        $t = Bridge.getEnumerator(Cinemachine.Utility.CinemachineDebug.mClients);
                        try {
                            while ($t.moveNext()) {
                                var c = $t.Current;
                                if (Bridge.referenceEquals(c, client)) {
                                    break;
                                }

                                pos.y += size.y;
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                    }

                    return new UnityEngine.Rect.$ctor3(pos.$clone(), size.$clone());
                },
                /*Cinemachine.Utility.CinemachineDebug.GetScreenPos:static end.*/

                /*Cinemachine.Utility.CinemachineDebug.SBFromPool:static start.*/
                /**
                 * Get a preallocated StringBuilder from the pool
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.CinemachineDebug
                 * @memberof Cinemachine.Utility.CinemachineDebug
                 * @return  {System.Text.StringBuilder}
                 */
                SBFromPool: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.CinemachineDebug#SBFromPool", this ); }

                    if (Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders == null || Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders.Count === 0) {
                        return new System.Text.StringBuilder();
                    }

                    var sb = Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders.getItem(Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders.Count - 1);
                    Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders.removeAt(Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders.Count - 1);
                    sb.setLength(0);
                    return sb;
                },
                /*Cinemachine.Utility.CinemachineDebug.SBFromPool:static end.*/

                /*Cinemachine.Utility.CinemachineDebug.ReturnToPool:static start.*/
                /**
                 * Return a StringBuilder to the preallocated pool
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.CinemachineDebug
                 * @memberof Cinemachine.Utility.CinemachineDebug
                 * @param   {System.Text.StringBuilder}    sb
                 * @return  {void}
                 */
                ReturnToPool: function (sb) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.CinemachineDebug#ReturnToPool", this ); }

                    if (Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders == null) {
                        Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders = new (System.Collections.Generic.List$1(System.Text.StringBuilder)).ctor();
                    }

                    Cinemachine.Utility.CinemachineDebug.mAvailableStringBuilders.add(sb);
                },
                /*Cinemachine.Utility.CinemachineDebug.ReturnToPool:static end.*/


            }
        }
    });
    /*Cinemachine.Utility.CinemachineDebug end.*/

    /*Cinemachine.Utility.Damper start.*/
    /**
     * Utility to perform realistic damping of float or Vector3 values.
         The algorithm is based on exponentially decaying the delta until only
         a negligible amount remains.
     *
     * @static
     * @abstract
     * @public
     * @class Cinemachine.Utility.Damper
     */
    Bridge.define("Cinemachine.Utility.Damper", {
        statics: {
            fields: {
                Epsilon: 0,
                /**
                 * Standard residual
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.Utility.Damper
                 * @constant
                 * @default 0.01
                 * @type number
                 */
                kNegligibleResidual: 0,
                kLogNegligibleResidual: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.Damper#init", this ); }

                    this.Epsilon = 0.0001;
                    this.kNegligibleResidual = 0.01;
                    this.kLogNegligibleResidual = -4.60517025;
                }
            },
            methods: {
                /*Cinemachine.Utility.Damper.DecayConstant:static start.*/
                DecayConstant: function (time, residual) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.Damper#DecayConstant", this ); }

                    return Math.log(1.0 / residual) / time;
                },
                /*Cinemachine.Utility.Damper.DecayConstant:static end.*/

                /*Cinemachine.Utility.Damper.DecayedRemainder:static start.*/
                DecayedRemainder: function (initial, decayConstant, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.Damper#DecayedRemainder", this ); }

                    return initial / UnityEngine.Mathf.Exp(decayConstant * deltaTime);
                },
                /*Cinemachine.Utility.Damper.DecayedRemainder:static end.*/

                /*Cinemachine.Utility.Damper.Damp:static start.*/
                /**
                 * Get a damped version of a quantity.  This is the portion of the
                     quantity that will take effect over the given time.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.Damper
                 * @memberof Cinemachine.Utility.Damper
                 * @param   {number}    initial      The amount that will be damped
                 * @param   {number}    dampTime     The rate of damping.  This is the time it would
                     take to reduce the original amount to a negligible percentage
                 * @param   {number}    deltaTime    The time over which to damp
                 * @return  {number}                 The damped amount.  This will be the original amount scaled by
                     a value between 0 and 1.
                 */
                Damp: function (initial, dampTime, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.Damper#Damp", this ); }

                    if (dampTime < Cinemachine.Utility.Damper.Epsilon || Math.abs(initial) < Cinemachine.Utility.Damper.Epsilon) {
                        return initial;
                    }

                    if (deltaTime < Cinemachine.Utility.Damper.Epsilon) {
                        return 0;
                    }

                    var k = 4.60517025 / dampTime; //DecayConstant(dampTime, kNegligibleResidual);

                    return initial * (1 - UnityEngine.Mathf.Exp(-k * deltaTime));
                },
                /*Cinemachine.Utility.Damper.Damp:static end.*/

                /*Cinemachine.Utility.Damper.Damp$2:static start.*/
                /**
                 * Get a damped version of a quantity.  This is the portion of the
                     quantity that will take effect over the given time.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.Damper
                 * @memberof Cinemachine.Utility.Damper
                 * @param   {UnityEngine.Vector3}    initial      The amount that will be damped
                 * @param   {UnityEngine.Vector3}    dampTime     The rate of damping.  This is the time it would
                     take to reduce the original amount to a negligible percentage
                 * @param   {number}                 deltaTime    The time over which to damp
                 * @return  {UnityEngine.Vector3}                 The damped amount.  This will be the original amount scaled by
                     a value between 0 and 1.
                 */
                Damp$2: function (initial, dampTime, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.Damper#Damp$2", this ); }

                    for (var i = 0; i < 3; ++i) {
                        initial.setitem(i, Cinemachine.Utility.Damper.Damp(initial.getitem(i), dampTime.getitem(i), deltaTime));
                    }

                    return initial.$clone();
                },
                /*Cinemachine.Utility.Damper.Damp$2:static end.*/

                /*Cinemachine.Utility.Damper.Damp$1:static start.*/
                /**
                 * Get a damped version of a quantity.  This is the portion of the
                     quantity that will take effect over the given time.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.Damper
                 * @memberof Cinemachine.Utility.Damper
                 * @param   {UnityEngine.Vector3}    initial      The amount that will be damped
                 * @param   {number}                 dampTime     The rate of damping.  This is the time it would
                     take to reduce the original amount to a negligible percentage
                 * @param   {number}                 deltaTime    The time over which to damp
                 * @return  {UnityEngine.Vector3}                 The damped amount.  This will be the original amount scaled by
                     a value between 0 and 1.
                 */
                Damp$1: function (initial, dampTime, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.Damper#Damp$1", this ); }

                    for (var i = 0; i < 3; ++i) {
                        initial.setitem(i, Cinemachine.Utility.Damper.Damp(initial.getitem(i), dampTime, deltaTime));
                    }

                    return initial.$clone();
                },
                /*Cinemachine.Utility.Damper.Damp$1:static end.*/


            }
        }
    });
    /*Cinemachine.Utility.Damper end.*/

    /*Cinemachine.Utility.GaussianWindow1d$1 start.*/
    Bridge.define("Cinemachine.Utility.GaussianWindow1d$1", function (T) { return {
        fields: {
            mCurrentPos: 0,
            mData: null,
            mKernel: null,
            Sigma: 0
        },
        props: {
            KernelSize: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#KernelSize#get", this ); }

                    return this.mKernel.length;
                }
            },
            BufferLength: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#BufferLength#get", this ); }

                    return this.mData.length;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#init", this ); }

                this.mCurrentPos = -1;
            },
            ctor: function (sigma, maxKernelRadius) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#ctor", this ); }

                if (maxKernelRadius === void 0) { maxKernelRadius = 10; }

                this.$initialize();
                this.GenerateKernel(sigma, maxKernelRadius);
                this.mData = System.Array.init(this.KernelSize, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                this.mCurrentPos = -1;
            }
        },
        methods: {
            /*Cinemachine.Utility.GaussianWindow1d$1.GenerateKernel start.*/
            GenerateKernel: function (sigma, maxKernelRadius) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#GenerateKernel", this ); }

                // Weight is close to 0 at a distance of sigma*3, so let's just cut it off a little early
                var kernelRadius = Math.min(maxKernelRadius, Math.floor(Math.abs(sigma) * 2.5));
                this.mKernel = System.Array.init(2 * kernelRadius + 1, 0, System.Single);
                if (kernelRadius === 0) {
                    this.mKernel[0] = 1;
                } else {
                    var sum = 0;
                    for (var i = -kernelRadius; i <= kernelRadius; ++i) {
                        this.mKernel[i + kernelRadius] = Math.exp(-(i * i) / (2 * sigma * sigma)) / (6.2831853071795862 * sigma * sigma);
                        sum += this.mKernel[i + kernelRadius];
                    }

                    for (var i1 = -kernelRadius; i1 <= kernelRadius; ++i1) {
                        this.mKernel[i1 + kernelRadius] /= sum;
                    }
                }

                this.Sigma = sigma;
            },
            /*Cinemachine.Utility.GaussianWindow1d$1.GenerateKernel end.*/

            /*Cinemachine.Utility.GaussianWindow1d$1.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#Reset", this ); }

                this.mCurrentPos = -1;
            },
            /*Cinemachine.Utility.GaussianWindow1d$1.Reset end.*/

            /*Cinemachine.Utility.GaussianWindow1d$1.IsEmpty start.*/
            IsEmpty: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#IsEmpty", this ); }

                return this.mCurrentPos < 0;
            },
            /*Cinemachine.Utility.GaussianWindow1d$1.IsEmpty end.*/

            /*Cinemachine.Utility.GaussianWindow1d$1.AddValue start.*/
            AddValue: function (v) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#AddValue", this ); }

                if (this.mCurrentPos < 0) {
                    for (var i = 0; i < this.KernelSize; ++i) {
                        this.mData[i] = v;
                    }

                    this.mCurrentPos = UnityEngine.Mathf.Min(1, this.KernelSize - 1);
                }

                this.mData[this.mCurrentPos] = v;
                if (++this.mCurrentPos === this.KernelSize) {
                    this.mCurrentPos = 0;
                }
            },
            /*Cinemachine.Utility.GaussianWindow1d$1.AddValue end.*/

            /*Cinemachine.Utility.GaussianWindow1d$1.Filter start.*/
            Filter: function (v) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#Filter", this ); }

                if (this.KernelSize < 3) {
                    return v;
                }

                this.AddValue(v);
                return this.Value();
            },
            /*Cinemachine.Utility.GaussianWindow1d$1.Filter end.*/

            /*Cinemachine.Utility.GaussianWindow1d$1.Value start.*/
            /**
             * @instance
             * @public
             * @this Cinemachine.Utility.GaussianWindow1d$1
             * @memberof Cinemachine.Utility.GaussianWindow1d$1
             * @return  {T}
             */
            Value: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#Value", this ); }

                return this.Compute(this.mCurrentPos);
            },
            /*Cinemachine.Utility.GaussianWindow1d$1.Value end.*/

            /*Cinemachine.Utility.GaussianWindow1d$1.SetBufferValue start.*/
            SetBufferValue: function (index, value) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#SetBufferValue", this ); }

                this.mData[index] = value;
            },
            /*Cinemachine.Utility.GaussianWindow1d$1.SetBufferValue end.*/

            /*Cinemachine.Utility.GaussianWindow1d$1.GetBufferValue start.*/
            GetBufferValue: function (index) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1d$1#GetBufferValue", this ); }

                return this.mData[index];
            },
            /*Cinemachine.Utility.GaussianWindow1d$1.GetBufferValue end.*/


        }
    }; });
    /*Cinemachine.Utility.GaussianWindow1d$1 end.*/

    /*Cinemachine.Utility.HeadingTracker start.*/
    /**
     * Tracks an object's velocity with a filter to determine a reasonably
         steady direction for the object's current trajectory.
     *
     * @public
     * @class Cinemachine.Utility.HeadingTracker
     */
    Bridge.define("Cinemachine.Utility.HeadingTracker", {
        statics: {
            fields: {
                mDecayExponent: 0
            },
            methods: {
                /*Cinemachine.Utility.HeadingTracker.Decay:static start.*/
                Decay: function (time) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#Decay", this ); }

                    return UnityEngine.Mathf.Exp(time * Cinemachine.Utility.HeadingTracker.mDecayExponent);
                },
                /*Cinemachine.Utility.HeadingTracker.Decay:static end.*/


            }
        },
        fields: {
            mBottom: 0,
            mCount: 0,
            mHeadingSum: null,
            mHistory: null,
            mLastGoodHeading: null,
            mTop: 0,
            mWeightSum: 0,
            mWeightTime: 0
        },
        props: {
            /**
             * Get the current filter size
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.Utility.HeadingTracker
             * @function FilterSize
             * @type number
             */
            FilterSize: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#FilterSize#get", this ); }

                    return this.mHistory.length;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#init", this ); }

                this.mHeadingSum = new UnityEngine.Vector3();
                this.mLastGoodHeading = new UnityEngine.Vector3();
                this.mLastGoodHeading = pc.Vec3.ZERO.clone();
            },
            /**
             * Construct a heading tracker with a given filter size
             *
             * @instance
             * @public
             * @this Cinemachine.Utility.HeadingTracker
             * @memberof Cinemachine.Utility.HeadingTracker
             * @param   {number}    filterSize    The size of the filter.  The larger the filter, the
                 more constanct (and laggy) is the heading.  30 is pretty big.
             * @return  {void}
             */
            ctor: function (filterSize) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#ctor", this ); }

                this.$initialize();
                this.mHistory = System.Array.init(filterSize, function (){
                    return new Cinemachine.Utility.HeadingTracker.Item();
                }, Cinemachine.Utility.HeadingTracker.Item);
                var historyHalfLife = filterSize / 5.0; // somewhat arbitrarily
                Cinemachine.Utility.HeadingTracker.mDecayExponent = -Math.log(2.0) / historyHalfLife;
                this.ClearHistory();
            }
        },
        methods: {
            /*Cinemachine.Utility.HeadingTracker.ClearHistory start.*/
            ClearHistory: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#ClearHistory", this ); }

                this.mTop = (this.mBottom = (this.mCount = 0));
                this.mWeightSum = 0;
                this.mHeadingSum = pc.Vec3.ZERO.clone();
            },
            /*Cinemachine.Utility.HeadingTracker.ClearHistory end.*/

            /*Cinemachine.Utility.HeadingTracker.Add start.*/
            /**
             * Add a new velocity frame.  This should be called once per frame,
                 unless the velocity is zero
             *
             * @instance
             * @public
             * @this Cinemachine.Utility.HeadingTracker
             * @memberof Cinemachine.Utility.HeadingTracker
             * @param   {UnityEngine.Vector3}    velocity    The object's velocity this frame
             * @return  {void}
             */
            Add: function (velocity) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#Add", this ); }

                if (this.FilterSize === 0) {
                    this.mLastGoodHeading = velocity.$clone();
                    return;
                }

                var weight = velocity.length();
                if (weight > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    var item = new Cinemachine.Utility.HeadingTracker.Item();
                    item.velocity = velocity.$clone();
                    item.weight = weight;
                    item.time = UnityEngine.Time.time;
                    if (this.mCount === this.FilterSize) {
                        this.PopBottom();
                    }

                    ++this.mCount;
                    this.mHistory[this.mTop] = item.$clone();
                    if (++this.mTop === this.FilterSize) {
                        this.mTop = 0;
                    }

                    this.mWeightSum *= Cinemachine.Utility.HeadingTracker.Decay(item.time - this.mWeightTime);
                    this.mWeightTime = item.time;
                    this.mWeightSum += weight;
                    this.mHeadingSum = this.mHeadingSum.$clone().add( item.velocity.$clone() );
                }
            },
            /*Cinemachine.Utility.HeadingTracker.Add end.*/

            /*Cinemachine.Utility.HeadingTracker.PopBottom start.*/
            PopBottom: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#PopBottom", this ); }

                if (this.mCount > 0) {
                    var time = UnityEngine.Time.time;
                    var item = this.mHistory[this.mBottom].$clone();
                    if (++this.mBottom === this.FilterSize) {
                        this.mBottom = 0;
                    }

                    --this.mCount;

                    var decay = Cinemachine.Utility.HeadingTracker.Decay(time - item.time);
                    this.mWeightSum -= item.weight * decay;
                    this.mHeadingSum = this.mHeadingSum.$clone().sub( item.velocity.$clone().clone().scale( decay ) );
                    if (this.mWeightSum <= Cinemachine.Utility.UnityVectorExtensions.Epsilon || this.mCount === 0) {
                        this.ClearHistory();
                    }
                }
            },
            /*Cinemachine.Utility.HeadingTracker.PopBottom end.*/

            /*Cinemachine.Utility.HeadingTracker.DecayHistory start.*/
            /**
             * Decay the history.  This should be called every frame.
             *
             * @instance
             * @public
             * @this Cinemachine.Utility.HeadingTracker
             * @memberof Cinemachine.Utility.HeadingTracker
             * @return  {void}
             */
            DecayHistory: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#DecayHistory", this ); }

                var time = UnityEngine.Time.time;
                var decay = Cinemachine.Utility.HeadingTracker.Decay(time - this.mWeightTime);
                this.mWeightSum *= decay;
                this.mWeightTime = time;
                if (this.mWeightSum < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    this.ClearHistory();
                } else {
                    this.mHeadingSum = this.mHeadingSum.$clone().clone().scale( decay );
                }
            },
            /*Cinemachine.Utility.HeadingTracker.DecayHistory end.*/

            /*Cinemachine.Utility.HeadingTracker.GetReliableHeading start.*/
            /**
             * Get the filtered heading.
             *
             * @instance
             * @public
             * @this Cinemachine.Utility.HeadingTracker
             * @memberof Cinemachine.Utility.HeadingTracker
             * @return  {UnityEngine.Vector3}        The filtered direction of motion
             */
            GetReliableHeading: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker#GetReliableHeading", this ); }

                // Update Last Good Heading
                if (this.mWeightSum > Cinemachine.Utility.UnityVectorExtensions.Epsilon && (this.mCount === this.mHistory.length || Cinemachine.Utility.UnityVectorExtensions.AlmostZero(this.mLastGoodHeading))) {
                    var h = this.mHeadingSum.$clone().scale( 1.0 / ( this.mWeightSum ) );
                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(h)) {
                        this.mLastGoodHeading = h.clone().normalize().$clone();
                    }
                }

                return this.mLastGoodHeading.$clone();
            },
            /*Cinemachine.Utility.HeadingTracker.GetReliableHeading end.*/


        }
    });
    /*Cinemachine.Utility.HeadingTracker end.*/

    /*Cinemachine.Utility.HeadingTracker+Item start.*/
    Bridge.define("Cinemachine.Utility.HeadingTracker.Item", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker.Item#getDefaultValue", this ); }
 return new Cinemachine.Utility.HeadingTracker.Item(); }
            }
        },
        fields: {
            velocity: null,
            weight: 0,
            time: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker.Item#init", this ); }

                this.velocity = new UnityEngine.Vector3();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker.Item#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker.Item#getHashCode", this ); }

                var h = Bridge.addHash([1835365449, this.velocity, this.weight, this.time]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker.Item#equals", this ); }

                if (!Bridge.is(o, Cinemachine.Utility.HeadingTracker.Item)) {
                    return false;
                }
                return Bridge.equals(this.velocity, o.velocity) && Bridge.equals(this.weight, o.weight) && Bridge.equals(this.time, o.time);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.HeadingTracker.Item#$clone", this ); }

                var s = to || new Cinemachine.Utility.HeadingTracker.Item();
                s.velocity = this.velocity.$clone();
                s.weight = this.weight;
                s.time = this.time;
                return s;
            }
        }
    });
    /*Cinemachine.Utility.HeadingTracker+Item end.*/

    /*Cinemachine.Utility.PositionPredictor start.*/
    Bridge.define("Cinemachine.Utility.PositionPredictor", {
        statics: {
            fields: {
                kSmoothingDefault: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#init", this ); }

                    this.kSmoothingDefault = 10;
                }
            }
        },
        fields: {
            m_Accel: null,
            m_Position: null,
            m_Velocity: null,
            mLastVelAddedTime: 0,
            mSmoothing: 0
        },
        props: {
            Smoothing: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#Smoothing#get", this ); }

                    return this.mSmoothing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#Smoothing#set", this ); }

                    if (value !== this.mSmoothing) {
                        this.mSmoothing = value;
                        var maxRadius = UnityEngine.Mathf.Max(10, Math.floor(value * 1.5));
                        this.m_Velocity = new Cinemachine.Utility.GaussianWindow1D_Vector3(this.mSmoothing, maxRadius);
                        this.m_Accel = new Cinemachine.Utility.GaussianWindow1D_Vector3(this.mSmoothing, maxRadius);
                    }
                }
            },
            IsEmpty: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#IsEmpty#get", this ); }

                    return this.m_Velocity.IsEmpty();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#init", this ); }

                this.m_Position = new UnityEngine.Vector3();
                this.m_Accel = new Cinemachine.Utility.GaussianWindow1D_Vector3(Cinemachine.Utility.PositionPredictor.kSmoothingDefault);
                this.m_Velocity = new Cinemachine.Utility.GaussianWindow1D_Vector3(Cinemachine.Utility.PositionPredictor.kSmoothingDefault);
                this.mSmoothing = 10.0;
            }
        },
        methods: {
            /*Cinemachine.Utility.PositionPredictor.ApplyTransformDelta start.*/
            ApplyTransformDelta: function (positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#ApplyTransformDelta", this ); }

                this.m_Position = this.m_Position.$clone().add( positionDelta.$clone() );
            },
            /*Cinemachine.Utility.PositionPredictor.ApplyTransformDelta end.*/

            /*Cinemachine.Utility.PositionPredictor.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#Reset", this ); }

                this.m_Velocity.Reset();
                this.m_Accel.Reset();
            },
            /*Cinemachine.Utility.PositionPredictor.Reset end.*/

            /*Cinemachine.Utility.PositionPredictor.AddPosition start.*/
            AddPosition: function (pos, deltaTime, lookaheadTime) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#AddPosition", this ); }

                if (deltaTime < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    this.Reset();
                } else if (this.IsEmpty) {
                    this.m_Velocity.AddValue(pc.Vec3.ZERO.clone());
                } else {
                    var vel = (pos.$clone().sub( this.m_Position )).scale( 1.0 / ( deltaTime ) );
                    if (vel.lengthSq() > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        var vel0 = this.m_Velocity.Value().$clone();
                        var now = UnityEngine.Time.time;
                        if (vel.lengthSq() >= vel0.lengthSq() || Math.acos( pc.math.clamp( vel.clone().normalize().dot( vel0.clone().normalize() ), -1, 1 ) ) * pc.math.RAD_TO_DEG > 10 || now > this.mLastVelAddedTime + lookaheadTime) {
                            this.m_Velocity.AddValue(vel.$clone());
                            this.m_Accel.AddValue(vel.$clone().sub( vel0 ));
                            this.mLastVelAddedTime = now;
                        }
                    }
                }

                this.m_Position = pos.$clone();
            },
            /*Cinemachine.Utility.PositionPredictor.AddPosition end.*/

            /*Cinemachine.Utility.PositionPredictor.PredictPositionDelta start.*/
            PredictPositionDelta: function (lookaheadTime) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#PredictPositionDelta", this ); }

                var vel = this.m_Velocity.IsEmpty() ? pc.Vec3.ZERO.clone() : this.m_Velocity.Value();
                var accel = this.m_Accel.IsEmpty() ? pc.Vec3.ZERO.clone() : this.m_Accel.Value();
                var delta = vel.$clone().clone().scale( lookaheadTime );
                delta = delta.$clone().add( accel.$clone().clone().scale( lookaheadTime ).clone().scale( lookaheadTime ).clone().scale( 0.5 ) );
                return delta.$clone();
            },
            /*Cinemachine.Utility.PositionPredictor.PredictPositionDelta end.*/

            /*Cinemachine.Utility.PositionPredictor.PredictPosition start.*/
            PredictPosition: function (lookaheadTime) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.PositionPredictor#PredictPosition", this ); }

                return this.m_Position.$clone().add( this.PredictPositionDelta(lookaheadTime) );
            },
            /*Cinemachine.Utility.PositionPredictor.PredictPosition end.*/


        }
    });
    /*Cinemachine.Utility.PositionPredictor end.*/

    /*Cinemachine.Utility.SplineHelpers start.*/
    Bridge.define("Cinemachine.Utility.SplineHelpers", {
        statics: {
            methods: {
                /*Cinemachine.Utility.SplineHelpers.Bezier3:static start.*/
                Bezier3: function (t, p0, p1, p2, p3) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.SplineHelpers#Bezier3", this ); }

                    t = Math.max(0, Math.min(1, t));
                    var d = 1.0 - t;
                    return p0.clone().scale( d * d * d ).add( p1.clone().scale( 3.0 * d * d * t ) ).add( p2.clone().scale( 3.0 * d * t * t ) ).add( p3.clone().scale( t * t * t ) );
                },
                /*Cinemachine.Utility.SplineHelpers.Bezier3:static end.*/

                /*Cinemachine.Utility.SplineHelpers.BezierTangent3:static start.*/
                BezierTangent3: function (t, p0, p1, p2, p3) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.SplineHelpers#BezierTangent3", this ); }

                    t = Math.max(0, Math.min(1, t));
                    return (p0.clone().scale( -3.0 ).add( p1.clone().scale( 9.0 ) ).sub( p2.clone().scale( 9.0 ) ).add( p3.clone().scale( 3.0 ) )).clone().scale( t ).clone().scale( t ).add( (p0.clone().scale( 6.0 ).sub( p1.clone().scale( 12.0 ) ).add( p2.clone().scale( 6.0 ) )).clone().scale( t ) ).sub( p0.clone().scale( 3.0 ) ).add( p1.clone().scale( 3.0 ) );
                },
                /*Cinemachine.Utility.SplineHelpers.BezierTangent3:static end.*/

                /*Cinemachine.Utility.SplineHelpers.Bezier1:static start.*/
                Bezier1: function (t, p0, p1, p2, p3) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.SplineHelpers#Bezier1", this ); }

                    t = Math.max(0, Math.min(1, t));
                    var d = 1.0 - t;
                    return d * d * d * p0 + 3.0 * d * d * t * p1 + 3.0 * d * t * t * p2 + t * t * t * p3;
                },
                /*Cinemachine.Utility.SplineHelpers.Bezier1:static end.*/

                /*Cinemachine.Utility.SplineHelpers.BezierTangent1:static start.*/
                BezierTangent1: function (t, p0, p1, p2, p3) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.SplineHelpers#BezierTangent1", this ); }

                    t = Math.max(0, Math.min(1, t));
                    return (-3.0 * p0 + 9.0 * p1 - 9.0 * p2 + 3.0 * p3) * t * t + (6.0 * p0 - 12.0 * p1 + 6.0 * p2) * t - 3.0 * p0 + 3.0 * p1;
                },
                /*Cinemachine.Utility.SplineHelpers.BezierTangent1:static end.*/

                /*Cinemachine.Utility.SplineHelpers.ComputeSmoothControlPoints:static start.*/
                ComputeSmoothControlPoints: function (knot, ctrl1, ctrl2) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.SplineHelpers#ComputeSmoothControlPoints", this ); }

                    var $t;
                    var numPoints = knot.v.length;
                    if (numPoints <= 2) {
                        if (numPoints === 2) {
                            ctrl1.v[0] = new pc.Vec4().lerp( knot.v[0], knot.v[1], 0.33333 );
                            ctrl2.v[0] = new pc.Vec4().lerp( knot.v[0], knot.v[1], 0.66666 );
                        } else if (numPoints === 1) {
                            ctrl1.v[0] = ($t = knot.v[0].$clone(), ctrl2.v[0] = $t.$clone(), $t);
                        }

                        return;
                    }

                    var a = System.Array.init(numPoints, 0, System.Single);
                    var b = System.Array.init(numPoints, 0, System.Single);
                    var c = System.Array.init(numPoints, 0, System.Single);
                    var r = System.Array.init(numPoints, 0, System.Single);
                    for (var axis = 0; axis < 4; ++axis) {
                        var n = numPoints - 1;

                        // Linear into the first segment
                        a[0] = 0;
                        b[0] = 2;
                        c[0] = 1;
                        r[0] = knot.v[0].getitem(axis) + 2 * knot.v[1].getitem(axis);

                        // Internal segments
                        for (var i = 1; i < n - 1; ++i) {
                            a[i] = 1;
                            b[i] = 4;
                            c[i] = 1;
                            r[i] = 4 * knot.v[i].getitem(axis) + 2 * knot.v[i + 1].getitem(axis);
                        }

                        // Linear out of the last segment
                        a[n - 1] = 2;
                        b[n - 1] = 7;
                        c[n - 1] = 0;
                        r[n - 1] = 8 * knot.v[n - 1].getitem(axis) + knot.v[n].getitem(axis);

                        // Solve with Thomas algorithm
                        for (var i1 = 1; i1 < n; ++i1) {
                            var m = a[i1] / b[i1 - 1];
                            b[i1] = b[i1] - m * c[i1 - 1];
                            r[i1] = r[i1] - m * r[i1 - 1];
                        }

                        // Compute ctrl1
                        ctrl1.v[n - 1].setitem(axis, r[n - 1] / b[n - 1]);
                        for (var i2 = n - 2; i2 >= 0; --i2) {
                            ctrl1.v[i2].setitem(axis, (r[i2] - c[i2] * ctrl1.v[i2 + 1].getitem(axis)) / b[i2]);
                        }

                        // Compute ctrl2 from ctrl1
                        for (var i3 = 0; i3 < n; i3++) {
                            ctrl2.v[i3].setitem(axis, 2 * knot.v[i3 + 1].getitem(axis) - ctrl1.v[i3 + 1].getitem(axis));
                        }

                        ctrl2.v[n - 1].setitem(axis, 0.5 * (knot.v[n].getitem(axis) + ctrl1.v[n - 1].getitem(axis)));
                    }
                },
                /*Cinemachine.Utility.SplineHelpers.ComputeSmoothControlPoints:static end.*/

                /*Cinemachine.Utility.SplineHelpers.ComputeSmoothControlPointsLooped:static start.*/
                ComputeSmoothControlPointsLooped: function (knot, ctrl1, ctrl2) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.SplineHelpers#ComputeSmoothControlPointsLooped", this ); }

                    var $t;
                    var numPoints = knot.v.length;
                    if (numPoints < 2) {
                        if (numPoints === 1) {
                            ctrl1.v[0] = ($t = knot.v[0].$clone(), ctrl2.v[0] = $t.$clone(), $t);
                        }

                        return;
                    }

                    var margin = UnityEngine.Mathf.Min(4, numPoints - 1);
                    var knotLooped = { v : System.Array.init(numPoints + 2 * margin, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4) };
                    var ctrl1Looped = { v : System.Array.init(numPoints + 2 * margin, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4) };
                    var ctrl2Looped = { v : System.Array.init(numPoints + 2 * margin, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4) };
                    for (var i = 0; i < margin; ++i) {
                        knotLooped.v[i] = knot.v[numPoints - (margin - i)].$clone();
                        knotLooped.v[numPoints + margin + i] = knot.v[i].$clone();
                    }

                    for (var i1 = 0; i1 < numPoints; ++i1) {
                        knotLooped.v[i1 + margin] = knot.v[i1].$clone();
                    }

                    Cinemachine.Utility.SplineHelpers.ComputeSmoothControlPoints(knotLooped, ctrl1Looped, ctrl2Looped);
                    for (var i2 = 0; i2 < numPoints; ++i2) {
                        ctrl1.v[i2] = ctrl1Looped.v[i2 + margin].$clone();
                        ctrl2.v[i2] = ctrl2Looped.v[i2 + margin].$clone();
                    }
                },
                /*Cinemachine.Utility.SplineHelpers.ComputeSmoothControlPointsLooped:static end.*/


            }
        }
    });
    /*Cinemachine.Utility.SplineHelpers end.*/

    /*Cinemachine.Utility.UnityQuaternionExtensions start.*/
    /**
     * Extensions to the Quaternion class, usen in various places by Cinemachine
     *
     * @static
     * @abstract
     * @public
     * @class Cinemachine.Utility.UnityQuaternionExtensions
     */
    Bridge.define("Cinemachine.Utility.UnityQuaternionExtensions", {
        statics: {
            methods: {
                /*Cinemachine.Utility.UnityQuaternionExtensions.SlerpWithReferenceUp:static start.*/
                /**
                 * This is a slerp that mimics a camera operator's movement in that
                     it chooses a path that avoids the lower hemisphere, as defined by
                     the up param
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityQuaternionExtensions
                 * @memberof Cinemachine.Utility.UnityQuaternionExtensions
                 * @param   {UnityEngine.Quaternion}    qA    First direction
                 * @param   {UnityEngine.Quaternion}    qB    Second direction
                 * @param   {number}                    t     Interpolation amoun t
                 * @param   {UnityEngine.Vector3}       up    Defines the up direction.  Must have a length of 1.
                 * @return  {UnityEngine.Quaternion}
                 */
                SlerpWithReferenceUp: function (qA, qB, t, up) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityQuaternionExtensions#SlerpWithReferenceUp", this ); }

                    var dirA = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane((qA.transformVector( new pc.Vec3( 0, 0, 1 ) )), up.$clone());
                    var dirB = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane((qB.transformVector( new pc.Vec3( 0, 0, 1 ) )), up.$clone());
                    if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(dirA) || Cinemachine.Utility.UnityVectorExtensions.AlmostZero(dirB)) {
                        return new pc.Quat().slerp( qA, qB, t );
                    }

                    // Work on the plane, in eulers
                    var qBase = new pc.Quat().setLookAt( dirA, up );
                    var qA1 = qBase.clone().invert().clone().mul( qA );
                    var qB1 = qBase.clone().invert().clone().mul( qB );
                    var eA = qA1.getPositiveEulerAngles().$clone();
                    var eB = qB1.getPositiveEulerAngles().$clone();
                    return qBase.clone().mul( new pc.Quat().setFromEulerAngles_Unity( UnityEngine.Mathf.LerpAngle(eA.x, eB.x, t), UnityEngine.Mathf.LerpAngle(eA.y, eB.y, t), UnityEngine.Mathf.LerpAngle(eA.z, eB.z, t) ) );
                },
                /*Cinemachine.Utility.UnityQuaternionExtensions.SlerpWithReferenceUp:static end.*/

                /*Cinemachine.Utility.UnityQuaternionExtensions.Normalized:static start.*/
                /**
                 * Normalize a quaternion
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityQuaternionExtensions
                 * @memberof Cinemachine.Utility.UnityQuaternionExtensions
                 * @param   {UnityEngine.Quaternion}    q
                 * @return  {UnityEngine.Quaternion}         The normalized quaternion.  Unit length is 1.
                 */
                Normalized: function (q) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityQuaternionExtensions#Normalized", this ); }

                    var v = new pc.Vec4( q.x, q.y, q.z, q.w ).clone().normalize().$clone();
                    return new pc.Quat( v.x, v.y, v.z, v.w );
                },
                /*Cinemachine.Utility.UnityQuaternionExtensions.Normalized:static end.*/

                /*Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget:static start.*/
                /**
                 * Get the rotations, first about world up, then about (travelling) local right,
                     necessary to align the quaternion's forward with the target direction.
                     This represents the tripod head movement needed to look at the target.
                     This formulation makes it easy to interpolate without introducing spurious roll.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityQuaternionExtensions
                 * @memberof Cinemachine.Utility.UnityQuaternionExtensions
                 * @param   {UnityEngine.Quaternion}    orient       
                 * @param   {UnityEngine.Vector3}       lookAtDir    The worldspace target direction in which we want to look
                 * @param   {UnityEngine.Vector3}       worldUp      Which way is up.  Must have a length of 1.
                 * @return  {UnityEngine.Vector2}                    Vector2.y is rotation about worldUp, and Vector2.x is second rotation,
                     about local right.
                 */
                GetCameraRotationToTarget: function (orient, lookAtDir, worldUp) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityQuaternionExtensions#GetCameraRotationToTarget", this ); }

                    if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(lookAtDir)) {
                        return pc.Vec2.ZERO.clone(); // degenerate
                    }

                    // Work in local space
                    var toLocal = orient.clone().invert();
                    var up = toLocal.transformVector( worldUp );
                    lookAtDir = toLocal.transformVector( lookAtDir );

                    // Align yaw based on world up
                    var angleH = 0;
                    {
                        var targetDirH = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(lookAtDir, up.$clone());
                        if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(targetDirH)) {
                            var currentDirH = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(new pc.Vec3( 0, 0, 1 ), up.$clone());
                            if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(currentDirH)) {
                                // We're looking at the north or south pole
                                if (currentDirH.dot( up ) > 0) {
                                    currentDirH = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(pc.Vec3.DOWN.clone(), up.$clone());
                                } else {
                                    currentDirH = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(pc.Vec3.UP.clone(), up.$clone());
                                }
                            }

                            angleH = Cinemachine.Utility.UnityVectorExtensions.SignedAngle(currentDirH.$clone(), targetDirH.$clone(), up.$clone());
                        }
                    }
                    var q = new pc.Quat().setFromAxisAngle( up, angleH );

                    // Get local vertical angle
                    var angleV = Cinemachine.Utility.UnityVectorExtensions.SignedAngle(q.transformVector( new pc.Vec3( 0, 0, 1 ) ), lookAtDir.$clone(), q.transformVector( pc.Vec3.RIGHT.clone() ));

                    return new pc.Vec2( angleV, angleH );
                },
                /*Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget:static end.*/

                /*Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation:static start.*/
                /**
                 * Apply rotations, first about world up, then about (travelling) local right.
                     rot.y is rotation about worldUp, and rot.x is second rotation, about local right.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityQuaternionExtensions
                 * @memberof Cinemachine.Utility.UnityQuaternionExtensions
                 * @param   {UnityEngine.Quaternion}    orient     
                 * @param   {UnityEngine.Vector2}       rot        Vector2.y is rotation about worldUp, and Vector2.x is second rotation,
                     about local right.
                 * @param   {UnityEngine.Vector3}       worldUp    Which way is up
                 * @return  {UnityEngine.Quaternion}
                 */
                ApplyCameraRotation: function (orient, rot, worldUp) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityQuaternionExtensions#ApplyCameraRotation", this ); }

                    var q = new pc.Quat().setFromAxisAngle( pc.Vec3.RIGHT.clone(), rot.x );
                    return new pc.Quat().setFromAxisAngle( worldUp, rot.y ).clone().mul( orient ).clone().mul( q );
                },
                /*Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation:static end.*/


            }
        }
    });
    /*Cinemachine.Utility.UnityQuaternionExtensions end.*/

    /*Cinemachine.Utility.UnityRectExtensions start.*/
    /**
     * Ad-hoc xxtentions to the Rect structure, used by Cinemachine
     *
     * @static
     * @abstract
     * @public
     * @class Cinemachine.Utility.UnityRectExtensions
     */
    Bridge.define("Cinemachine.Utility.UnityRectExtensions", {
        statics: {
            methods: {
                /*Cinemachine.Utility.UnityRectExtensions.Inflated:static start.*/
                /**
                 * Inflate a rect
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityRectExtensions
                 * @memberof Cinemachine.Utility.UnityRectExtensions
                 * @param   {UnityEngine.Rect}       r        
                 * @param   {UnityEngine.Vector2}    delta    x and y are added/subtracted fto/from the edges of
                     the rect, inflating it in all directions
                 * @return  {UnityEngine.Rect}                The inflated rect
                 */
                Inflated: function (r, delta) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityRectExtensions#Inflated", this ); }

                    return new UnityEngine.Rect.$ctor1(r.xMin - delta.x, r.yMin - delta.y, r.width + delta.x * 2, r.height + delta.y * 2);
                },
                /*Cinemachine.Utility.UnityRectExtensions.Inflated:static end.*/


            }
        }
    });
    /*Cinemachine.Utility.UnityRectExtensions end.*/

    /*Cinemachine.Utility.UnityVectorExtensions start.*/
    /**
     * Extensions to the Vector3 class, used by Cinemachine
     *
     * @static
     * @abstract
     * @public
     * @class Cinemachine.Utility.UnityVectorExtensions
     */
    Bridge.define("Cinemachine.Utility.UnityVectorExtensions", {
        statics: {
            fields: {
                /**
                 * A useful Epsilon
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @constant
                 * @default 0.0001
                 * @type number
                 */
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#init", this ); }

                    this.Epsilon = 0.0001;
                }
            },
            methods: {
                /*Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment$1:static start.*/
                /**
                 * Get the closest point on a line segment.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityVectorExtensions
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @param   {UnityEngine.Vector3}    p     A point in space
                 * @param   {UnityEngine.Vector3}    s0    Start of line segment
                 * @param   {UnityEngine.Vector3}    s1    End of line segment
                 * @return  {number}                       The interpolation parameter representing the point on the segment, with 0==s0, and 1==s1
                 */
                ClosestPointOnSegment$1: function (p, s0, s1) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#ClosestPointOnSegment$1", this ); }

                    var s = s1.$clone().sub( s0 );
                    var len2 = s.lengthSq();
                    if (len2 < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        return 0; // degenrate segment
                    }

                    return Math.max(0, Math.min(1, p.$clone().sub( s0 ).dot( s ) / len2));
                },
                /*Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment$1:static end.*/

                /*Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment:static start.*/
                /**
                 * Get the closest point on a line segment.
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityVectorExtensions
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @param   {UnityEngine.Vector2}    p     A point in space
                 * @param   {UnityEngine.Vector2}    s0    Start of line segment
                 * @param   {UnityEngine.Vector2}    s1    End of line segment
                 * @return  {number}                       The interpolation parameter representing the point on the segment, with 0==s0, and 1==s1
                 */
                ClosestPointOnSegment: function (p, s0, s1) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#ClosestPointOnSegment", this ); }

                    var s = s1.$clone().sub( s0 );
                    var len2 = s.lengthSq();
                    if (len2 < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        return 0; // degenrate segment
                    }

                    return Math.max(0, Math.min(1, p.$clone().sub( s0 ).dot( s ) / len2));
                },
                /*Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment:static end.*/

                /*Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane:static start.*/
                /**
                 * Returns a non-normalized projection of the supplied vector onto a plane
                     as described by its normal
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityVectorExtensions
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @param   {UnityEngine.Vector3}    vector         
                 * @param   {UnityEngine.Vector3}    planeNormal    The normal that defines the plane.  Must have a length of 1.
                 * @return  {UnityEngine.Vector3}                   The component of the vector that lies in the plane
                 */
                ProjectOntoPlane: function (vector, planeNormal) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#ProjectOntoPlane", this ); }

                    return vector.$clone().sub( planeNormal.clone().scale( vector.dot( planeNormal ) ) );
                },
                /*Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane:static end.*/

                /*Cinemachine.Utility.UnityVectorExtensions.Abs:static start.*/
                /**
                 * Component-wise absolute value
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityVectorExtensions
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @param   {UnityEngine.Vector3}    v
                 * @return  {UnityEngine.Vector3}
                 */
                Abs: function (v) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#Abs", this ); }

                    return new pc.Vec3( Math.abs(v.x), Math.abs(v.y), Math.abs(v.z) );
                },
                /*Cinemachine.Utility.UnityVectorExtensions.Abs:static end.*/

                /*Cinemachine.Utility.UnityVectorExtensions.AlmostZero:static start.*/
                /**
                 * Is the vector within Epsilon of zero length?
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityVectorExtensions
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @param   {UnityEngine.Vector3}    v
                 * @return  {boolean}                     True if the square magnitude of the vector is within Epsilon of zero
                 */
                AlmostZero: function (v) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#AlmostZero", this ); }

                    return v.lengthSq() < 9.999999E-09;
                },
                /*Cinemachine.Utility.UnityVectorExtensions.AlmostZero:static end.*/

                /*Cinemachine.Utility.UnityVectorExtensions.Angle:static start.*/
                /**
                 * Much more stable for small angles than Unity's native implementation
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityVectorExtensions
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @param   {UnityEngine.Vector3}    v1    
                 * @param   {UnityEngine.Vector3}    v2
                 * @return  {number}
                 */
                Angle: function (v1, v2) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#Angle", this ); }

                    v1.normalize();
                    v2.normalize();
                    return Math.atan2((v1.$clone().sub( v2 )).length(), (v1.$clone().add( v2 )).length()) * UnityEngine.Mathf.Rad2Deg * 2;
                },
                /*Cinemachine.Utility.UnityVectorExtensions.Angle:static end.*/

                /*Cinemachine.Utility.UnityVectorExtensions.SignedAngle:static start.*/
                /**
                 * Much more stable for small angles than Unity's native implementation
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityVectorExtensions
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @param   {UnityEngine.Vector3}    v1    
                 * @param   {UnityEngine.Vector3}    v2    
                 * @param   {UnityEngine.Vector3}    up
                 * @return  {number}
                 */
                SignedAngle: function (v1, v2, up) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#SignedAngle", this ); }

                    var $t;
                    var angle = Cinemachine.Utility.UnityVectorExtensions.Angle(v1.$clone(), v2.$clone());
                    if (($t = up.dot( new pc.Vec3().cross( v1, v2 ) ), ($t === 0 ? 1 : Math.sign($t))) < 0) {
                        return -angle;
                    }

                    return angle;
                },
                /*Cinemachine.Utility.UnityVectorExtensions.SignedAngle:static end.*/

                /*Cinemachine.Utility.UnityVectorExtensions.SlerpWithReferenceUp:static start.*/
                /**
                 * This is a slerp that mimics a camera operator's movement in that
                     it chooses a path that avoids the lower hemisphere, as defined by
                     the up param
                 *
                 * @static
                 * @public
                 * @this Cinemachine.Utility.UnityVectorExtensions
                 * @memberof Cinemachine.Utility.UnityVectorExtensions
                 * @param   {UnityEngine.Vector3}    vA    First direction
                 * @param   {UnityEngine.Vector3}    vB    Second direction
                 * @param   {number}                 t     Interpolation amoun t
                 * @param   {UnityEngine.Vector3}    up    Defines the up direction
                 * @return  {UnityEngine.Vector3}
                 */
                SlerpWithReferenceUp: function (vA, vB, t, up) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.UnityVectorExtensions#SlerpWithReferenceUp", this ); }

                    var dA = vA.length();
                    var dB = vB.length();
                    if (dA < Cinemachine.Utility.UnityVectorExtensions.Epsilon || dB < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        return new pc.Vec3().lerp( vA, vB, t );
                    }

                    var dirA = vA.$clone().scale( 1.0 / ( dA ) );
                    var dirB = vB.$clone().scale( 1.0 / ( dB ) );
                    var qA = new pc.Quat().setLookAt( dirA, up );
                    var qB = new pc.Quat().setLookAt( dirB, up );
                    var q = Cinemachine.Utility.UnityQuaternionExtensions.SlerpWithReferenceUp(qA.$clone(), qB.$clone(), t, up.$clone());
                    var dir = q.transformVector( new pc.Vec3( 0, 0, 1 ) );
                    return dir.$clone().clone().scale( pc.math.lerp(dA, dB, t) );
                },
                /*Cinemachine.Utility.UnityVectorExtensions.SlerpWithReferenceUp:static end.*/


            }
        }
    });
    /*Cinemachine.Utility.UnityVectorExtensions end.*/

    /*CinemachineMixer start.*/
    Bridge.define("CinemachineMixer", {
        inherits: [UnityEngine.Playables.PlayableBehaviour],
        fields: {
            mBrain: null,
            mBrainOverrideId: 0,
            mLastOverrideTime: 0,
            mPlaying: false
        },
        alias: [
            "OnPlayableDestroy", "UnityEngine$Playables$IPlayableBehaviour$OnPlayableDestroy",
            "PrepareFrame", "UnityEngine$Playables$IPlayableBehaviour$PrepareFrame",
            "ProcessFrame", "UnityEngine$Playables$IPlayableBehaviour$ProcessFrame"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CinemachineMixer#init", this ); }

                this.mBrainOverrideId = -1;
            }
        },
        methods: {
            /*CinemachineMixer.OnPlayableDestroy start.*/
            OnPlayableDestroy: function (playable) {
if ( TRACE ) { TRACE( "CinemachineMixer#OnPlayableDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.mBrain, null)) {
                    this.mBrain.ReleaseCameraOverride(this.mBrainOverrideId); // clean up
                }

                this.mBrainOverrideId = -1;
            },
            /*CinemachineMixer.OnPlayableDestroy end.*/

            /*CinemachineMixer.PrepareFrame start.*/
            PrepareFrame: function (playable, info) {
if ( TRACE ) { TRACE( "CinemachineMixer#PrepareFrame", this ); }

                this.mPlaying = info.evaluationType === UnityEngine.Playables.FrameData.EvaluationType.Playback;
            },
            /*CinemachineMixer.PrepareFrame end.*/

            /*CinemachineMixer.ProcessFrame start.*/
            ProcessFrame: function (playable, info, playerData) {
if ( TRACE ) { TRACE( "CinemachineMixer#ProcessFrame", this ); }

                UnityEngine.Playables.PlayableBehaviour.prototype.ProcessFrame.call(this, playable, info, playerData);

                // Get the brain that this track controls.
                // Older versions of timeline sent the gameObject by mistake.
                var go = Bridge.as(playerData, UnityEngine.GameObject);
                if (UnityEngine.GameObject.op_Equality(go, null)) {
                    this.mBrain = Bridge.cast(playerData, Cinemachine.CinemachineBrain);
                } else {
                    this.mBrain = go.GetComponent(Cinemachine.CinemachineBrain);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.mBrain, null)) {
                    return;
                }

                // Find which clips are active.  We can process a maximum of 2.
                // In the case that the weights don't add up to 1, the outgoing weight
                // will be calculated as the inverse of the incoming weight.
                var activeInputs = 0;
                var clipA = new CinemachineMixer.ClipInfo();
                var clipB = new CinemachineMixer.ClipInfo();
                for (var i = 0; i < UnityEngine.Playables.PlayableExtensions.GetInputCount(UnityEngine.Playables.Playable, playable); ++i) {
                    var weight = UnityEngine.Playables.PlayableExtensions.GetInputWeight(UnityEngine.Playables.Playable, playable, i);
                    var clip = UnityEngine.Playables.ScriptPlayable$1(CinemachineShotPlayable).op_Explicit(UnityEngine.Playables.PlayableExtensions.GetInput(UnityEngine.Playables.Playable, playable, i));
                    var shot = clip.GetBehaviour();
                    if (shot != null && shot.IsValid && UnityEngine.Playables.PlayableExtensions.GetPlayState(UnityEngine.Playables.Playable, playable) === UnityEngine.Playables.PlayState.Playing && weight > 0) {
                        clipA = clipB.$clone();
                        clipB.vcam = shot.VirtualCamera;
                        clipB.weight = weight;
                        clipB.localTime = UnityEngine.Playables.PlayableExtensions.GetTime(UnityEngine.Playables.ScriptPlayable$1(CinemachineShotPlayable), clip);
                        clipB.duration = UnityEngine.Playables.PlayableExtensions.GetDuration(UnityEngine.Playables.ScriptPlayable$1(CinemachineShotPlayable), clip);
                        if (++activeInputs === 2) {
                            break;
                        }
                    }
                }

                // Figure out which clip is incoming
                var incomingIsB = clipB.weight >= 1 || clipB.localTime < clipB.duration / 2;
                if (activeInputs === 2) {
                    if (clipB.localTime < clipA.localTime) {
                        incomingIsB = true;
                    } else if (clipB.localTime > clipA.localTime) {
                        incomingIsB = false;
                    } else {
                        incomingIsB = clipB.duration >= clipA.duration;
                    }
                }

                // Override the Cinemachine brain with our results
                var camA = incomingIsB ? clipA.vcam : clipB.vcam;
                var camB = incomingIsB ? clipB.vcam : clipA.vcam;
                var camWeightB = incomingIsB ? clipB.weight : 1 - clipB.weight;
                this.mBrainOverrideId = this.mBrain.SetCameraOverride(this.mBrainOverrideId, camA, camB, camWeightB, this.GetDeltaTime(info.deltaTime));
            },
            /*CinemachineMixer.ProcessFrame end.*/

            /*CinemachineMixer.GetDeltaTime start.*/
            GetDeltaTime: function (deltaTime) {
if ( TRACE ) { TRACE( "CinemachineMixer#GetDeltaTime", this ); }

                if (!this.mPlaying) {
                    // We're scrubbing or paused
                    if (this.mBrainOverrideId < 0) {
                        this.mLastOverrideTime = -1;
                    }

                    // When force-scrubbing in playmode, we use timeline's suggested deltaTime
                    // otherwise we look at the real clock for scrubbing in edit mode
                    if (!UnityEngine.Application.isPlaying) {
                        deltaTime = UnityEngine.Time.unscaledDeltaTime;
                        var time = UnityEngine.Time.realtimeSinceStartup;
                        if (this.mLastOverrideTime < 0 || time - this.mLastOverrideTime > UnityEngine.Time.maximumDeltaTime * 5) {
                            deltaTime = -1; // paused long enough - kill time-dependent stuff
                        }

                        this.mLastOverrideTime = time;
                    }
                }

                return deltaTime;
            },
            /*CinemachineMixer.GetDeltaTime end.*/


        }
    });
    /*CinemachineMixer end.*/

    /*CinemachineMixer+ClipInfo start.*/
    Bridge.define("CinemachineMixer.ClipInfo", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "CinemachineMixer.ClipInfo#getDefaultValue", this ); }
 return new CinemachineMixer.ClipInfo(); }
            }
        },
        fields: {
            vcam: null,
            weight: 0,
            localTime: 0,
            duration: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "CinemachineMixer.ClipInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "CinemachineMixer.ClipInfo#getHashCode", this ); }

                var h = Bridge.addHash([3754941068, this.vcam, this.weight, this.localTime, this.duration]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "CinemachineMixer.ClipInfo#equals", this ); }

                if (!Bridge.is(o, CinemachineMixer.ClipInfo)) {
                    return false;
                }
                return Bridge.equals(this.vcam, o.vcam) && Bridge.equals(this.weight, o.weight) && Bridge.equals(this.localTime, o.localTime) && Bridge.equals(this.duration, o.duration);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "CinemachineMixer.ClipInfo#$clone", this ); }

                var s = to || new CinemachineMixer.ClipInfo();
                s.vcam = this.vcam;
                s.weight = this.weight;
                s.localTime = this.localTime;
                s.duration = this.duration;
                return s;
            }
        }
    });
    /*CinemachineMixer+ClipInfo end.*/

    /*CinemachineShot start.*/
    /**
     * Internal use only.  Not part of the public API.
     *
     * @public
     * @class CinemachineShot
     * @augments UnityEngine.Playables.PlayableAsset
     * @implements  UnityEngine.Timeline.IPropertyPreview
     */
    Bridge.define("CinemachineShot", {
        inherits: [UnityEngine.Playables.PlayableAsset,UnityEngine.Timeline.IPropertyPreview],
        fields: {
            VirtualCamera: null
        },
        alias: ["GatherProperties", "UnityEngine$Timeline$IPropertyPreview$GatherProperties"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CinemachineShot#init", this ); }

                this.VirtualCamera = new (UnityEngine.ExposedReference$1(Cinemachine.CinemachineVirtualCameraBase))();
            }
        },
        methods: {
            /*CinemachineShot.CreatePlayable start.*/
            CreatePlayable: function (graph, owner) {
if ( TRACE ) { TRACE( "CinemachineShot#CreatePlayable", this ); }

                var playable = UnityEngine.Playables.ScriptPlayable$1(CinemachineShotPlayable).Create$1(graph);
                playable.GetBehaviour().VirtualCamera = this.VirtualCamera.Resolve(graph.GetResolver());
                return UnityEngine.Playables.ScriptPlayable$1(CinemachineShotPlayable).op_Implicit(playable);
            },
            /*CinemachineShot.CreatePlayable end.*/

            /*CinemachineShot.GatherProperties start.*/
            GatherProperties: function (director, driver) {
if ( TRACE ) { TRACE( "CinemachineShot#GatherProperties", this ); }

                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Transform, "m_LocalPosition.x");
                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Transform, "m_LocalPosition.y");
                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Transform, "m_LocalPosition.z");
                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Transform, "m_LocalRotation.x");
                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Transform, "m_LocalRotation.y");
                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Transform, "m_LocalRotation.z");

                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Camera, "field of view");
                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Camera, "near clip plane");
                driver.UnityEngine$Timeline$IPropertyCollector$AddFromName$3(UnityEngine.Camera, "far clip plane");
            },
            /*CinemachineShot.GatherProperties end.*/


        }
    });
    /*CinemachineShot end.*/

    /*CinemachineShotPlayable start.*/
    Bridge.define("CinemachineShotPlayable", {
        inherits: [UnityEngine.Playables.PlayableBehaviour],
        fields: {
            VirtualCamera: null
        },
        props: {
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "CinemachineShotPlayable#IsValid#get", this ); }

                    return UnityEngine.MonoBehaviour.op_Inequality(this.VirtualCamera, null);
                }
            }
        }
    });
    /*CinemachineShotPlayable end.*/

    /*CinemachineTouchInputMapper start.*/
    /**
     * This is an add-on behaviour that globally maps the touch control
         to standard input channels, such as mouse X and mouse Y.
         Drop it on any game object in your scene.
     *
     * @public
     * @class CinemachineTouchInputMapper
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("CinemachineTouchInputMapper", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            TouchSensitivityX: 0,
            TouchSensitivityY: 0,
            TouchXInputMapTo: null,
            TouchYInputMapTo: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CinemachineTouchInputMapper#init", this ); }

                this.TouchSensitivityX = 10.0;
                this.TouchSensitivityY = 10.0;
                this.TouchXInputMapTo = "Mouse X";
                this.TouchYInputMapTo = "Mouse Y";
            }
        },
        methods: {
            /*CinemachineTouchInputMapper.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "CinemachineTouchInputMapper#Start", this ); }

                Cinemachine.CinemachineCore.GetInputAxis = Bridge.fn.cacheBind(this, this.GetInputAxis);
            },
            /*CinemachineTouchInputMapper.Start end.*/

            /*CinemachineTouchInputMapper.GetInputAxis start.*/
            GetInputAxis: function (axisName) {
if ( TRACE ) { TRACE( "CinemachineTouchInputMapper#GetInputAxis", this ); }

                var $t, $t1;
                if (UnityEngine.Input.touchCount > 0) {
                    if (Bridge.referenceEquals(axisName, this.TouchXInputMapTo)) {
                        return ($t = UnityEngine.Input.touches)[0].deltaPosition.x / this.TouchSensitivityX;
                    }

                    if (Bridge.referenceEquals(axisName, this.TouchYInputMapTo)) {
                        return ($t1 = UnityEngine.Input.touches)[0].deltaPosition.y / this.TouchSensitivityY;
                    }
                }

                return UnityEngine.Input.GetAxis(axisName);
            },
            /*CinemachineTouchInputMapper.GetInputAxis end.*/


        }
    });
    /*CinemachineTouchInputMapper end.*/

    /*CinemachineTrack start.*/
    Bridge.define("CinemachineTrack", {
        inherits: [UnityEngine.Timeline.TrackAsset],
        methods: {
            /*CinemachineTrack.CreateTrackMixer start.*/
            CreateTrackMixer: function (graph, go, inputCount) {
if ( TRACE ) { TRACE( "CinemachineTrack#CreateTrackMixer", this ); }

                var $t;
                // Hack to set the display name of the clip to match the vcam
                $t = Bridge.getEnumerator(this.GetClips(), UnityEngine.Timeline.TimelineClip);
                try {
                    while ($t.moveNext()) {
                        var c = $t.Current;
                        var shot = Bridge.cast(c.asset, CinemachineShot);
                        var vcam = shot.VirtualCamera.Resolve(graph.GetResolver());
                        if (UnityEngine.MonoBehaviour.op_Inequality(vcam, null)) {
                            c.displayName = vcam.Name;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var mixer = UnityEngine.Playables.ScriptPlayable$1(CinemachineMixer).Create$1(graph);
                UnityEngine.Playables.PlayableExtensions.SetInputCount(UnityEngine.Playables.ScriptPlayable$1(CinemachineMixer), mixer, inputCount);
                return UnityEngine.Playables.ScriptPlayable$1(CinemachineMixer).op_Implicit(mixer);
            },
            /*CinemachineTrack.CreateTrackMixer end.*/


        }
    });
    /*CinemachineTrack end.*/

    /*Cinemachine.BlendSourceVirtualCamera start.*/
    /**
     * Blend result source for blending.   This exposes a CinemachineBlend object
         as an ersatz virtual camera for the purposes of blending.  This achieves the purpose
         of blending the result oif a blend.
     *
     * @class Cinemachine.BlendSourceVirtualCamera
     * @implements  Cinemachine.ICinemachineCamera
     */
    Bridge.define("Cinemachine.BlendSourceVirtualCamera", {
        inherits: [Cinemachine.ICinemachineCamera],
        fields: {
            Blend: null,
            Priority: 0,
            LookAt: null,
            Follow: null,
            State: null
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#Name#get", this ); }

                    return "Mid-blend";
                }
            },
            Description: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#Description#get", this ); }

                    return this.Blend == null ? "(null)" : this.Blend.Description;
                }
            },
            VirtualCameraGameObject: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#VirtualCameraGameObject#get", this ); }

                    return null;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#IsValid#get", this ); }

                    return this.Blend != null && this.Blend.IsValid;
                }
            },
            ParentCamera: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#ParentCamera#get", this ); }

                    return null;
                }
            }
        },
        alias: [
            "Name", "Cinemachine$ICinemachineCamera$Name",
            "Description", "Cinemachine$ICinemachineCamera$Description",
            "Priority", "Cinemachine$ICinemachineCamera$Priority",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "State", "Cinemachine$ICinemachineCamera$State",
            "VirtualCameraGameObject", "Cinemachine$ICinemachineCamera$VirtualCameraGameObject",
            "IsValid", "Cinemachine$ICinemachineCamera$IsValid",
            "ParentCamera", "Cinemachine$ICinemachineCamera$ParentCamera",
            "IsLiveChild", "Cinemachine$ICinemachineCamera$IsLiveChild",
            "UpdateCameraState", "Cinemachine$ICinemachineCamera$UpdateCameraState",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#init", this ); }

                this.State = new Cinemachine.CameraState();
            },
            ctor: function (blend) {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#ctor", this ); }

                this.$initialize();
                this.Blend = blend;
            }
        },
        methods: {
            /*Cinemachine.BlendSourceVirtualCamera.IsLiveChild start.*/
            IsLiveChild: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#IsLiveChild", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                return this.Blend != null && (Bridge.referenceEquals(vcam, this.Blend.CamA) || Bridge.referenceEquals(vcam, this.Blend.CamB));
            },
            /*Cinemachine.BlendSourceVirtualCamera.IsLiveChild end.*/

            /*Cinemachine.BlendSourceVirtualCamera.UpdateCameraState start.*/
            UpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#UpdateCameraState", this ); }

                if (this.Blend != null) {
                    this.Blend.UpdateCameraState(worldUp.$clone(), deltaTime);
                    this.State = this.Blend.State.$clone();
                }
            },
            /*Cinemachine.BlendSourceVirtualCamera.UpdateCameraState end.*/

            /*Cinemachine.BlendSourceVirtualCamera.InternalUpdateCameraState start.*/
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#InternalUpdateCameraState", this ); }
 },
            /*Cinemachine.BlendSourceVirtualCamera.InternalUpdateCameraState end.*/

            /*Cinemachine.BlendSourceVirtualCamera.OnTransitionFromCamera start.*/
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#OnTransitionFromCamera", this ); }
 },
            /*Cinemachine.BlendSourceVirtualCamera.OnTransitionFromCamera end.*/

            /*Cinemachine.BlendSourceVirtualCamera.OnTargetObjectWarped start.*/
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#OnTargetObjectWarped", this ); }
 },
            /*Cinemachine.BlendSourceVirtualCamera.OnTargetObjectWarped end.*/

            /*Cinemachine.BlendSourceVirtualCamera.CalculateNewState start.*/
            CalculateNewState: function (deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.BlendSourceVirtualCamera#CalculateNewState", this ); }

                return this.State.$clone();
            },
            /*Cinemachine.BlendSourceVirtualCamera.CalculateNewState end.*/


        }
    });
    /*Cinemachine.BlendSourceVirtualCamera end.*/

    /*Cinemachine.CinemachineBasicMultiChannelPerlin start.*/
    /**
     * As a part of the Cinemachine Pipeline implementing the Noise stage, this
         component adds Perlin Noise to the Camera state, in the Correction
         channel of the CameraState.
         The noise is created by using a predefined noise profile asset.  This defines the
         shape of the noise over time.  You can scale this in amplitude or in time, to produce
         a large family of different noises using the same profile.
     *
     * @public
     * @class Cinemachine.CinemachineBasicMultiChannelPerlin
     * @augments Cinemachine.CinemachineComponentBase
     * @see {@link NoiseSettings}
     */
    Bridge.define("Cinemachine.CinemachineBasicMultiChannelPerlin", {
        inherits: [Cinemachine.CinemachineComponentBase],
        fields: {
            /**
             * Gain to apply to the amplitudes defined in the settings asset.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBasicMultiChannelPerlin
             * @default 1.0
             * @type number
             */
            m_AmplitudeGain: 0,
            /**
             * Scale factor to apply to the frequencies defined in the settings asset.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBasicMultiChannelPerlin
             * @default 1.0
             * @type number
             */
            m_FrequencyGain: 0,
            /**
             * Serialized property for referencing a NoiseSettings asset
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBasicMultiChannelPerlin
             * @type Cinemachine.NoiseSettings
             */
            m_NoiseProfile: null,
            /**
             * When rotating the camera, offset the camera's pivot position by this much (camera space)
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBasicMultiChannelPerlin
             * @type UnityEngine.Vector3
             */
            m_PivotOffset: null,
            mInitialized: false,
            mNoiseOffsets: null,
            mNoiseTime: 0
        },
        props: {
            /**
             * True if the component is valid, i.e. it has a noise definition and is enabled.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineBasicMultiChannelPerlin
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBasicMultiChannelPerlin#IsValid#get", this ); }

                    return this.enabled && this.m_NoiseProfile != null;
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Noise stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineBasicMultiChannelPerlin
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBasicMultiChannelPerlin#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Noise;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBasicMultiChannelPerlin#init", this ); }

                this.m_PivotOffset = new UnityEngine.Vector3();
                this.mNoiseOffsets = new UnityEngine.Vector3();
                this.m_AmplitudeGain = 1.0;
                this.m_FrequencyGain = 1.0;
                this.m_PivotOffset = pc.Vec3.ZERO.clone();
                this.mNoiseOffsets = pc.Vec3.ZERO.clone();
            }
        },
        methods: {
            /*Cinemachine.CinemachineBasicMultiChannelPerlin.MutateCameraState start.*/
            /**
             * Applies noise to the Correction channel of the CameraState if the
                 delta time is greater than 0.  Otherwise, does nothing.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineBasicMultiChannelPerlin
             * @memberof Cinemachine.CinemachineBasicMultiChannelPerlin
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    How much to advance the perlin noise generator.
                 Noise is only applied if this value is greater than or equal to 0
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBasicMultiChannelPerlin#MutateCameraState", this ); }

                var $t, $t1;
                if (!this.IsValid || deltaTime < 0) {
                    return;
                }

                if (!this.mInitialized) {
                    this.Initialize();
                }

                this.mNoiseTime += deltaTime * this.m_FrequencyGain;
                curState.v.PositionCorrection = curState.v.PositionCorrection.$clone().add( curState.v.CorrectedOrientation.transformVector( Cinemachine.NoiseSettings.GetCombinedFilterResults(this.m_NoiseProfile.PositionNoise, this.mNoiseTime, this.mNoiseOffsets.$clone()) ).clone().scale( this.m_AmplitudeGain ) );
                var rotNoise = ($t = Cinemachine.NoiseSettings.GetCombinedFilterResults(this.m_NoiseProfile.OrientationNoise, this.mNoiseTime, this.mNoiseOffsets.$clone()).clone().scale( this.m_AmplitudeGain ), new pc.Quat().setFromEulerAngles_Unity( $t.x, $t.y, $t.z ));
                curState.v.OrientationCorrection = curState.v.OrientationCorrection.clone().mul( rotNoise );

                if (!pc.Vec3.equals( this.m_PivotOffset, pc.Vec3.ZERO.clone() )) {
                    var m = ($t1 = this.m_PivotOffset.$clone().scale( -1 ), new pc.Mat4().setTranslate( $t1.x, $t1.y, $t1.z ));
                    m = new pc.Mat4().mul2( new pc.Mat4().setTRS( pc.Vec3.ZERO, curState.v.CorrectedOrientation, pc.Vec3.ONE ), m );
                    m = new pc.Mat4().mul2( new pc.Mat4().setTranslate( this.m_PivotOffset.x, this.m_PivotOffset.y, this.m_PivotOffset.z ), m );
                    curState.v.PositionCorrection = curState.v.PositionCorrection.$clone().add( m.multiplyPoint( pc.Vec3.ZERO.clone() ) );
                }
            },
            /*Cinemachine.CinemachineBasicMultiChannelPerlin.MutateCameraState end.*/

            /*Cinemachine.CinemachineBasicMultiChannelPerlin.ReSeed start.*/
            /**
             * Generate a new random seed
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineBasicMultiChannelPerlin
             * @memberof Cinemachine.CinemachineBasicMultiChannelPerlin
             * @return  {void}
             */
            ReSeed: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBasicMultiChannelPerlin#ReSeed", this ); }

                this.mNoiseOffsets = new pc.Vec3( UnityEngine.Random.Range$1(-1000.0, 1000.0), UnityEngine.Random.Range$1(-1000.0, 1000.0), UnityEngine.Random.Range$1(-1000.0, 1000.0) );
            },
            /*Cinemachine.CinemachineBasicMultiChannelPerlin.ReSeed end.*/

            /*Cinemachine.CinemachineBasicMultiChannelPerlin.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBasicMultiChannelPerlin#Initialize", this ); }

                this.mInitialized = true;
                this.mNoiseTime = 0;
                if (pc.Vec3.equals( this.mNoiseOffsets, pc.Vec3.ZERO.clone() )) {
                    this.ReSeed();
                }
            },
            /*Cinemachine.CinemachineBasicMultiChannelPerlin.Initialize end.*/


        }
    });
    /*Cinemachine.CinemachineBasicMultiChannelPerlin end.*/

    /*Cinemachine.CinemachineVirtualCameraBase start.*/
    /**
     * Base class for a Monobehaviour that represents a Virtual Camera within the Unity scene.
         This is intended to be attached to an empty Transform GameObject.
         Inherited classes can be either standalone virtual cameras such
         as CinemachineVirtualCamera, or meta-cameras such as
         CinemachineClearShot or CinemachineFreeLook.
         A CinemachineVirtualCameraBase exposes a Priority property.  When the behaviour is
         enabled in the game, the Virtual Camera is automatically placed in a queue
         maintained by the static CinemachineCore singleton.
         The queue is sorted by priority.  When a Unity camera is equipped with a
         CinemachineBrain behaviour, the brain will choose the camera
         at the head of the queue.  If you have multiple Unity cameras with CinemachineBrain
         behaviours (say in a split-screen context), then you can filter the queue by
         setting the culling flags on the virtual cameras.  The culling mask of the
         Unity Camera will then act as a filter for the brain.  Apart from this,
         there is nothing that prevents a virtual camera from controlling multiple
         Unity cameras simultaneously.
     *
     * @abstract
     * @public
     * @class Cinemachine.CinemachineVirtualCameraBase
     * @augments UnityEngine.MonoBehaviour
     * @implements  Cinemachine.ICinemachineCamera
     */
    Bridge.define("Cinemachine.CinemachineVirtualCameraBase", {
        inherits: [UnityEngine.MonoBehaviour,Cinemachine.ICinemachineCamera],
        fields: {
            /**
             * Inspector control - Use for hiding sections of the Inspector UI.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @type Array.<string>
             */
            m_ExcludedPropertiesInInspector: null,
            /**
             * Inspector control - Use for enabling sections of the Inspector UI.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @type Array.<number>
             */
            m_LockStageInInspector: null,
            m_OnValidateCalled: false,
            m_parentVcam: null,
            /**
             * The priority will determine which camera becomes active based on the
                 state of other cameras and this camera.  Higher numbers have greater priority.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @default 10
             * @type number
             */
            m_Priority: 0,
            m_QueuePriority: 0,
            /**
             * When the virtual camera is not live, this is how often the virtual camera will
                 be updated.  Set this to tune for performance. Most of the time Never is fine, unless
                 the virtual camera is doing shot evaluation.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @type number
             */
            m_StandbyUpdate: 0,
            m_StreamingVersion: 0,
            m_ValidatingStreamVersion: 0,
            /**
             * THe extensions connected to this vcam
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @type System.Collections.Generic.List$1
             */
            mExtensions: null,
            mSlaveStatusUpdated: false,
            /**
             * Set this to force the next update to ignore deltaTime and reset itself
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @function PreviousStateIsValid
             * @type boolean
             */
            PreviousStateIsValid: false
        },
        props: {
            /**
             * Version that was last streamed, for upgrading legacy
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @function ValidatingStreamVersion
             * @type number
             */
            ValidatingStreamVersion: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#ValidatingStreamVersion#get", this ); }

                    return this.m_OnValidateCalled ? this.m_ValidatingStreamVersion : Cinemachine.CinemachineCore.kStreamingVersion;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#ValidatingStreamVersion#set", this ); }

                    this.m_ValidatingStreamVersion = value;
                }
            },
            /**
             * Get the name of the Virtual Camera.  Base implementation
                 returns the owner GameObject's name.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * Gets a brief debug description of this virtual camera, for use when displayiong debug info
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @function Description
             * @type string
             */
            Description: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#Description#get", this ); }

                    return "";
                }
            },
            /**
             * Get the Priority of the virtual camera.  This determines its placement
                 in the CinemachineCore's queue of eligible shots.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @function Priority
             * @type number
             */
            Priority: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#Priority#get", this ); }

                    return this.m_Priority;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#Priority#set", this ); }

                    this.m_Priority = value;
                }
            },
            /**
             * The GameObject owner of the Virtual Camera behaviour.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @function VirtualCameraGameObject
             * @type UnityEngine.GameObject
             */
            VirtualCameraGameObject: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#VirtualCameraGameObject#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this, null)) {
                        return null; // object deleted
                    }

                    return this.gameObject;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#IsValid#get", this ); }

                    return !(UnityEngine.MonoBehaviour.op_Equality(this, null));
                }
            },
            /**
             * Support for meta-virtual-cameras.  This is the situation where a
                 virtual camera is in fact the public face of a private army of virtual cameras, which
                 it manages on its own.  This method gets the VirtualCamera owner, if any.
                 Private armies are implemented as Transform children of the parent vcam.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @function ParentCamera
             * @type Cinemachine.ICinemachineCamera
             */
            ParentCamera: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#ParentCamera#get", this ); }

                    if (!this.mSlaveStatusUpdated || !UnityEngine.Application.isPlaying) {
                        this.UpdateSlaveStatus();
                    }

                    return this.m_parentVcam;
                }
            }
        },
        alias: [
            "Name", "Cinemachine$ICinemachineCamera$Name",
            "Description", "Cinemachine$ICinemachineCamera$Description",
            "Priority", "Cinemachine$ICinemachineCamera$Priority",
            "VirtualCameraGameObject", "Cinemachine$ICinemachineCamera$VirtualCameraGameObject",
            "IsValid", "Cinemachine$ICinemachineCamera$IsValid",
            "ParentCamera", "Cinemachine$ICinemachineCamera$ParentCamera",
            "IsLiveChild", "Cinemachine$ICinemachineCamera$IsLiveChild",
            "UpdateCameraState", "Cinemachine$ICinemachineCamera$UpdateCameraState",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#init", this ); }

                this.m_ExcludedPropertiesInInspector = System.Array.init(["m_Script"], System.String);
                this.m_Priority = 10;
                this.m_QueuePriority = 2147483647;
                this.m_StandbyUpdate = Cinemachine.CinemachineVirtualCameraBase.StandbyUpdateMode.RoundRobin;
            }
        },
        methods: {
            /*Cinemachine.CinemachineVirtualCameraBase.IsLiveChild start.*/
            /**
             * Check whether the vcam a live child of this camera.
                 This base class implementation always returns false.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {Cinemachine.ICinemachineCamera}    vcam                 The Virtual Camera to check
             * @param   {boolean}                           dominantChildOnly    If truw, will only return true if this vcam is the dominat live child
             * @return  {boolean}                                                True if the vcam is currently actively influencing the state of this vcam
             */
            IsLiveChild: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#IsLiveChild", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                return false;
            },
            /*Cinemachine.CinemachineVirtualCameraBase.IsLiveChild end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.UpdateCameraState start.*/
            /**
             * Update the camera's state.
                 The implementation must guarantee against multiple calls per frame, and should
                 use CinemachineCore.UpdateVirtualCamera(ICinemachineCamera, Vector3, float), which
                 has protection against multiple calls per frame.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {UnityEngine.Vector3}    worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                 deltaTime    Delta time for time-based effects (ignore if less than 0)
             * @return  {void}
             */
            UpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#UpdateCameraState", this ); }

                Cinemachine.CinemachineCore.Instance.UpdateVirtualCamera(this, worldUp.$clone(), deltaTime);
            },
            /*Cinemachine.CinemachineVirtualCameraBase.UpdateCameraState end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
                 Base class implementation must be called by any overridden method.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}               worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                            deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#OnTransitionFromCamera", this ); }

                if (!this.gameObject.activeInHierarchy) {
                    this.PreviousStateIsValid = false;
                }
            },
            /*Cinemachine.CinemachineVirtualCameraBase.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the component that a target got warped,
                 so that the component can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#OnTargetObjectWarped", this ); }

                // inform the extensions
                if (this.mExtensions != null) {
                    for (var i = 0; i < this.mExtensions.Count; ++i) {
                        this.mExtensions.getItem(i).OnTargetObjectWarped(target, positionDelta.$clone());
                    }
                }
            },
            /*Cinemachine.CinemachineVirtualCameraBase.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.AddExtension start.*/
            /**
             * A delegate to hook into the state calculation pipeline.
                 This will be called after each pipeline stage, to allow others to hook into the pipeline.
                 See CinemachineCore.Stage.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {Cinemachine.CinemachineExtension}    extension    The extension to add.
             * @return  {void}
             */
            AddExtension: function (extension) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#AddExtension", this ); }

                if (this.mExtensions == null) {
                    this.mExtensions = new (System.Collections.Generic.List$1(Cinemachine.CinemachineExtension)).ctor();
                } else {
                    this.mExtensions.remove(extension);
                }

                this.mExtensions.add(extension);
            },
            /*Cinemachine.CinemachineVirtualCameraBase.AddExtension end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.RemoveExtension start.*/
            /**
             * Remove a Pipeline stage hook callback.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {Cinemachine.CinemachineExtension}    extension    The extension to remove.
             * @return  {void}
             */
            RemoveExtension: function (extension) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#RemoveExtension", this ); }

                if (this.mExtensions != null) {
                    this.mExtensions.remove(extension);
                }
            },
            /*Cinemachine.CinemachineVirtualCameraBase.RemoveExtension end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.InvokePostPipelineStageCallback start.*/
            /**
             * Invokes the PostPipelineStageDelegate for this camera, and up the hierarchy for all
                 parent cameras (if any).
                 Implementaion must be sure to call this after each pipeline stage, to allow
                 other services to hook into the pipeline.
                 See CinemachineCore.Stage.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam         
             * @param   {number}                                      stage        
             * @param   {Cinemachine.CameraState}                     newState     
             * @param   {number}                                      deltaTime
             * @return  {void}
             */
            InvokePostPipelineStageCallback: function (vcam, stage, newState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#InvokePostPipelineStageCallback", this ); }

                if (this.mExtensions != null) {
                    for (var i = 0; i < this.mExtensions.Count; ++i) {
                        var e = this.mExtensions.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(e, null)) {
                            // Object was deleted (possibly because of Undo in the editor)
                            this.mExtensions.removeAt(i);
                            --i;
                        } else if (e.enabled) {
                            e.InvokePostPipelineStageCallback(vcam, stage, newState, deltaTime);
                        }
                    }
                }

                var parent = Bridge.as(this.ParentCamera, Cinemachine.CinemachineVirtualCameraBase);
                if (UnityEngine.MonoBehaviour.op_Inequality(parent, null)) {
                    parent.InvokePostPipelineStageCallback(vcam, stage, newState, deltaTime);
                }
            },
            /*Cinemachine.CinemachineVirtualCameraBase.InvokePostPipelineStageCallback end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.InvokeOnTransitionInExtensions start.*/
            /**
             * Invokes the OnTransitionFromCamera for all extensions on this camera
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      
             * @param   {UnityEngine.Vector3}               worldUp      
             * @param   {number}                            deltaTime
             * @return  {boolean}                                        True to request a vcam update of internal state
             */
            InvokeOnTransitionInExtensions: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#InvokeOnTransitionInExtensions", this ); }

                var forceUpdate = false;
                if (this.mExtensions != null) {
                    for (var i = 0; i < this.mExtensions.Count; ++i) {
                        var e = this.mExtensions.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(e, null)) {
                            // Object was deleted (possibly because of Undo in the editor)
                            this.mExtensions.removeAt(i);
                            --i;
                        } else if (e.enabled && e.OnTransitionFromCamera(fromCam, worldUp.$clone(), deltaTime)) {
                            forceUpdate = true;
                        }
                    }
                }

                return forceUpdate;
            },
            /*Cinemachine.CinemachineVirtualCameraBase.InvokeOnTransitionInExtensions end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.ApplyPositionBlendMethod start.*/
            /**
             * Applies a position blend hint to the camera state
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {Cinemachine.CameraState}    state    
             * @param   {number}                     hint
             * @return  {void}
             */
            ApplyPositionBlendMethod: function (state, hint) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#ApplyPositionBlendMethod", this ); }

                switch (hint) {
                    case Cinemachine.CinemachineVirtualCameraBase.BlendHint.SphericalPosition: 
                        state.v.BlendHint |= Cinemachine.CameraState.BlendHintValue.SphericalPositionBlend;
                        break;
                    case Cinemachine.CinemachineVirtualCameraBase.BlendHint.CylindricalPosition: 
                        state.v.BlendHint |= Cinemachine.CameraState.BlendHintValue.CylindricalPositionBlend;
                        break;
                    case Cinemachine.CinemachineVirtualCameraBase.BlendHint.ScreenSpaceAimWhenTargetsDiffer: 
                        state.v.BlendHint |= Cinemachine.CameraState.BlendHintValue.RadialAimBlend;
                        break;
                }
            },
            /*Cinemachine.CinemachineVirtualCameraBase.ApplyPositionBlendMethod end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.OnDestroy start.*/
            /**
             * Maintains the global vcam registry.  Always call the base class implementation.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @return  {void}
             */
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#OnDestroy", this ); }

                Cinemachine.CinemachineCore.Instance.RemoveActiveCamera(this);
            },
            /*Cinemachine.CinemachineVirtualCameraBase.OnDestroy end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.OnTransformParentChanged start.*/
            /**
             * Base class implementation makes sure the priority queue remains up-to-date.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @return  {void}
             */
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#OnTransformParentChanged", this ); }

                Cinemachine.CinemachineCore.Instance.CameraDestroyed(this);
                Cinemachine.CinemachineCore.Instance.CameraAwakened(this);
                this.UpdateSlaveStatus();
                this.UpdateVcamPoolStatus();
            },
            /*Cinemachine.CinemachineVirtualCameraBase.OnTransformParentChanged end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.Start start.*/
            /**
             * Base class implementation does nothing.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @return  {void}
             */
            Start: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#Start", this ); }
 },
            /*Cinemachine.CinemachineVirtualCameraBase.Start end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.OnValidate start.*/
            /**
             * Enforce bounds for fields, when changed in inspector.
                 Call base class implementation at the beginning of overridden method.
                 After base method is called, ValidatingStreamVersion will be valid.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @return  {void}
             */
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#OnValidate", this ); }

                this.m_OnValidateCalled = true;
                this.ValidatingStreamVersion = this.m_StreamingVersion;
                this.m_StreamingVersion = Cinemachine.CinemachineCore.kStreamingVersion;
            },
            /*Cinemachine.CinemachineVirtualCameraBase.OnValidate end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.OnEnable start.*/
            /**
             * Base class implementation adds the virtual camera from the priority queue.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#OnEnable", this ); }

                // Sanity check - if another vcam component is enabled, shut down
                var vcamComponents = this.GetComponents(Cinemachine.CinemachineVirtualCameraBase);
                for (var i = 0; i < vcamComponents.length; ++i) {
                    if (vcamComponents[i].enabled && UnityEngine.MonoBehaviour.op_Inequality(vcamComponents[i], this)) {
                        UnityEngine.Debug.LogError$2((this.Name || "") + " has multiple CinemachineVirtualCameraBase-derived components.  Disabling " + (Bridge.Reflection.getTypeName(Bridge.getType(this)) || "") + ".");
                        this.enabled = false;
                    }
                }

                this.UpdateSlaveStatus();
                this.UpdateVcamPoolStatus(); // Add to queue
                if (!Cinemachine.CinemachineCore.Instance.IsLive(this)) {
                    this.PreviousStateIsValid = false;
                }

                Cinemachine.CinemachineCore.Instance.CameraAwakened(this);
            },
            /*Cinemachine.CinemachineVirtualCameraBase.OnEnable end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.OnDisable start.*/
            /**
             * Base class implementation makes sure the priority queue remains up-to-date.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @return  {void}
             */
            OnDisable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#OnDisable", this ); }

                this.UpdateVcamPoolStatus(); // Remove from queue
                Cinemachine.CinemachineCore.Instance.CameraDestroyed(this);
            },
            /*Cinemachine.CinemachineVirtualCameraBase.OnDisable end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.Update start.*/
            /**
             * Base class implementation makes sure the priority queue remains up-to-date.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @return  {void}
             */
            Update: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#Update", this ); }

                if (this.m_Priority !== this.m_QueuePriority) {
                    this.UpdateVcamPoolStatus();
                }
            },
            /*Cinemachine.CinemachineVirtualCameraBase.Update end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.UpdateSlaveStatus start.*/
            UpdateSlaveStatus: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#UpdateSlaveStatus", this ); }

                this.mSlaveStatusUpdated = true;
                this.m_parentVcam = null;
                var p = this.transform.parent;
                if (UnityEngine.Component.op_Inequality(p, null)) {
                    this.m_parentVcam = p.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                }
            },
            /*Cinemachine.CinemachineVirtualCameraBase.UpdateSlaveStatus end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.ResolveLookAt start.*/
            /**
             * Returns this vcam's LookAt target, or if that is null, will retrun
                 the parent vcam's LookAt target.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {UnityEngine.Transform}    localLookAt    This vcam's LookAt value.
             * @return  {UnityEngine.Transform}                   The same value, or the parent's if null and a parent exists.
             */
            ResolveLookAt: function (localLookAt) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#ResolveLookAt", this ); }

                var lookAt = localLookAt;
                if (UnityEngine.Component.op_Equality(lookAt, null) && this.ParentCamera != null) {
                    lookAt = this.ParentCamera.Cinemachine$ICinemachineCamera$LookAt; // Parent provides default
                }

                return lookAt;
            },
            /*Cinemachine.CinemachineVirtualCameraBase.ResolveLookAt end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.ResolveFollow start.*/
            /**
             * Returns this vcam's Follow target, or if that is null, will retrun
                 the parent vcam's Follow target.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {UnityEngine.Transform}    localFollow    This vcam's Follow value.
             * @return  {UnityEngine.Transform}                   The same value, or the parent's if null and a parent exists.
             */
            ResolveFollow: function (localFollow) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#ResolveFollow", this ); }

                var follow = localFollow;
                if (UnityEngine.Component.op_Equality(follow, null) && this.ParentCamera != null) {
                    follow = this.ParentCamera.Cinemachine$ICinemachineCamera$Follow; // Parent provides default
                }

                return follow;
            },
            /*Cinemachine.CinemachineVirtualCameraBase.ResolveFollow end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.UpdateVcamPoolStatus start.*/
            UpdateVcamPoolStatus: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#UpdateVcamPoolStatus", this ); }

                Cinemachine.CinemachineCore.Instance.RemoveActiveCamera(this);
                if (UnityEngine.MonoBehaviour.op_Equality(this.m_parentVcam, null) && this.isActiveAndEnabled) {
                    Cinemachine.CinemachineCore.Instance.AddActiveCamera(this);
                }

                this.m_QueuePriority = this.m_Priority;
            },
            /*Cinemachine.CinemachineVirtualCameraBase.UpdateVcamPoolStatus end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.MoveToTopOfPrioritySubqueue start.*/
            /**
             * When multiple virtual cameras have the highest priority, there is
                 sometimes the need to push one to the top, making it the current Live camera if
                 it shares the highest priority in the queue with its peers.
                 This happens automatically when a
                 new vcam is enabled: the most recent one goes to the top of the priority subqueue.
                 Use this method to push a vcam to the top of its priority peers.
                 If it and its peers share the highest priority, then this vcam will become Live.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @return  {void}
             */
            MoveToTopOfPrioritySubqueue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#MoveToTopOfPrioritySubqueue", this ); }

                this.UpdateVcamPoolStatus();
            },
            /*Cinemachine.CinemachineVirtualCameraBase.MoveToTopOfPrioritySubqueue end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.CreateBlend start.*/
            /**
             * Create a blend between 2 virtual cameras, taking into account
                 any existing active blend.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {Cinemachine.ICinemachineCamera}            camA           
             * @param   {Cinemachine.ICinemachineCamera}            camB           
             * @param   {Cinemachine.CinemachineBlendDefinition}    blendDef       
             * @param   {Cinemachine.CinemachineBlend}              activeBlend
             * @return  {Cinemachine.CinemachineBlend}
             */
            CreateBlend: function (camA, camB, blendDef, activeBlend) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#CreateBlend", this ); }

                if (blendDef.BlendCurve == null || blendDef.m_Time <= 0 || camA == null && camB == null) {
                    return null;
                }

                if (activeBlend != null) {
                    // Special case: if backing out of a blend-in-progress
                    // with the same blend in reverse, adjust the belnd time
                    if (Bridge.referenceEquals(activeBlend.CamA, camB) && Bridge.referenceEquals(activeBlend.CamB, camA) && activeBlend.Duration <= blendDef.m_Time) {
                        blendDef.m_Time = activeBlend.TimeInBlend;
                    }

                    camA = new Cinemachine.BlendSourceVirtualCamera(activeBlend);
                } else if (camA == null) {
                    camA = new Cinemachine.StaticPointVirtualCamera(this.State.$clone(), "(none)");
                }

                return new Cinemachine.CinemachineBlend(camA, camB, blendDef.BlendCurve, blendDef.m_Time, 0);
            },
            /*Cinemachine.CinemachineVirtualCameraBase.CreateBlend end.*/

            /*Cinemachine.CinemachineVirtualCameraBase.PullStateFromVirtualCamera start.*/
            /**
             * Create a camera state based on the current transform of this vcam
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineVirtualCameraBase
             * @memberof Cinemachine.CinemachineVirtualCameraBase
             * @param   {UnityEngine.Vector3}         worldUp    Current World Up direction, as provided by the brain
             * @param   {Cinemachine.LensSettings}    lens       Lens settings to serve as base, will be combined with lens from brain, if any
             * @return  {Cinemachine.CameraState}
             */
            PullStateFromVirtualCamera: function (worldUp, lens) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCameraBase#PullStateFromVirtualCamera", this ); }

                var state = Cinemachine.CameraState.Default.$clone();
                state.RawPosition = this.transform.position.$clone();
                state.RawOrientation = this.transform.rotation.$clone();
                state.ReferenceUp = worldUp.$clone();

                var brain = Cinemachine.CinemachineCore.Instance.FindPotentialTargetBrain(this);
                if (UnityEngine.MonoBehaviour.op_Inequality(brain, null)) {
                    lens.v.SnapshotCameraReadOnlyProperties$1(brain.OutputCamera);
                }

                state.Lens = lens.v.$clone();
                return state.$clone();
            },
            /*Cinemachine.CinemachineVirtualCameraBase.PullStateFromVirtualCamera end.*/


        }
    });
    /*Cinemachine.CinemachineVirtualCameraBase end.*/

    /*Cinemachine.CinemachineBrain+BrainEvent start.*/
    /**
     * Event with a CinemachineBrain parameter
     *
     * @public
     * @class Cinemachine.CinemachineBrain.BrainEvent
     * @augments UnityEngine.Events.UnityEvent$1
     */
    Bridge.define("Cinemachine.CinemachineBrain.BrainEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(Cinemachine.CinemachineBrain)],
        $kind: "nested class"
    });
    /*Cinemachine.CinemachineBrain+BrainEvent end.*/

    /*Cinemachine.CinemachineBrain+VcamActivatedEvent start.*/
    /**
     * Event with a ICinemachineCamera parameter
     *
     * @public
     * @class Cinemachine.CinemachineBrain.VcamActivatedEvent
     * @augments UnityEngine.Events.UnityEvent$2
     */
    Bridge.define("Cinemachine.CinemachineBrain.VcamActivatedEvent", {
        inherits: [UnityEngine.Events.UnityEvent$2(Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera)],
        $kind: "nested class"
    });
    /*Cinemachine.CinemachineBrain+VcamActivatedEvent end.*/

    /*Cinemachine.CinemachineCollider start.*/
    /**
     * An add-on module for Cinemachine Virtual Camera that post-processes
         the final position of the virtual camera. Based on the supplied settings,
         the Collider will attempt to preserve the line of sight
         with the LookAt target of the virtual camera by moving
         away from objects that will obstruct the view.
         Additionally, the Collider can be used to assess the shot quality and
         report this as a field in the camera State.
     *
     * @public
     * @class Cinemachine.CinemachineCollider
     * @augments Cinemachine.CinemachineExtension
     */
    Bridge.define("Cinemachine.CinemachineCollider", {
        inherits: [Cinemachine.CinemachineExtension],
        statics: {
            fields: {
                /**
                 * @static
                 * @private
                 * @memberof Cinemachine.CinemachineCollider
                 * @constant
                 * @default 0.001
                 * @type number
                 */
                PrecisionSlush: 0,
                AngleThreshold: 0,
                mCameraCollider: null,
                mCameraColliderGameObject: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#init", this ); }

                    this.PrecisionSlush = 0.001;
                    this.AngleThreshold = 0.1;
                }
            },
            methods: {
                /*Cinemachine.CinemachineCollider.DestroyCollider:static start.*/
                DestroyCollider: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#DestroyCollider", this ); }

                    if (UnityEngine.GameObject.op_Inequality(Cinemachine.CinemachineCollider.mCameraColliderGameObject, null)) {
                        Cinemachine.CinemachineCollider.mCameraColliderGameObject.SetActive(false);
                        Cinemachine.RuntimeUtility.DestroyObject(Cinemachine.CinemachineCollider.mCameraColliderGameObject.GetComponent(UnityEngine.Rigidbody));
                    }

                    Cinemachine.RuntimeUtility.DestroyObject(Cinemachine.CinemachineCollider.mCameraCollider);
                    Cinemachine.RuntimeUtility.DestroyObject(Cinemachine.CinemachineCollider.mCameraColliderGameObject);
                    Cinemachine.CinemachineCollider.mCameraColliderGameObject = null;
                    Cinemachine.CinemachineCollider.mCameraCollider = null;
                },
                /*Cinemachine.CinemachineCollider.DestroyCollider:static end.*/


            }
        },
        fields: {
            /**
             * Objects on these layers will be detected.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default 1
             * @type UnityEngine.LayerMask
             */
            m_CollideAgainst: null,
            /**
             * Obstacles with this tag will be ignored.  It is a good idea to set this field to the target's tag
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default ""
             * @type string
             */
            m_IgnoreTag: null,
            /**
             * Objects on these layers will never obstruct view of the target.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default 0
             * @type UnityEngine.LayerMask
             */
            m_TransparentLayers: null,
            /**
             * Obstacles closer to the target than this will be ignored
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default 0.1
             * @type number
             */
            m_MinimumDistanceFromTarget: 0,
            /**
             * When enabled, will attempt to resolve situations where the line of sight to the
                 target is blocked by an obstacle
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default true
             * @type boolean
             */
            m_AvoidObstacles: false,
            /**
             * The raycast distance to test for when checking if the line of sight to this camera's target is clear.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @type number
             */
            m_DistanceLimit: 0,
            /**
             * Don't take action unless occlusion has lasted at least this long.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @type number
             */
            m_MinimumOcclusionTime: 0,
            /**
             * Camera will try to maintain this distance from any obstacle.
                 Increase this value if you are seeing inside obstacles due to a large
                 FOV on the camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default 0.1
             * @type number
             */
            m_CameraRadius: 0,
            /**
             * The way in which the Collider will attempt to preserve sight of the target.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @type number
             */
            m_Strategy: 0,
            /**
             * Upper limit on how many obstacle hits to process.  Higher numbers may impact performance.
                 In most environments, 4 is enough.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default 4
             * @type number
             */
            m_MaximumEffort: 0,
            /**
             * Smoothing to apply to obstruction resolution.  Nearest camera point is held for at least this long.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default 0
             * @type number
             */
            m_SmoothingTime: 0,
            /**
             * How gradually the camera returns to its normal position after having been corrected.
                 Higher numbers will move the camera more gradually back to normal.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default 0
             * @type number
             */
            m_Damping: 0,
            /**
             * How gradually the camera moves to resolve an occlusion.
                 Higher numbers will move the camera more gradually.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @default 0
             * @type number
             */
            m_DampingWhenOccluded: 0,
            /**
             * If greater than zero, a higher score will be given to shots when the target is closer to
                 this distance.  Set this to zero to disable this feature
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollider
             * @type number
             */
            m_OptimalTargetDistance: 0,
            m_CornerBuffer: null,
            mColliderBuffer: null
        },
        props: {
            /**
             * Inspector API for debugging collision resolution path
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineCollider
             * @function DebugPaths
             * @type System.Collections.Generic.List$1
             */
            DebugPaths: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#DebugPaths#get", this ); }

                    var $t;
                    var list = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(UnityEngine.Vector3))).ctor();
                    var extraStates = this.GetAllExtraStates(Cinemachine.CinemachineCollider.VcamExtraState);
                    $t = Bridge.getEnumerator(extraStates);
                    try {
                        while ($t.moveNext()) {
                            var v = $t.Current;
                            if (v.debugResolutionPath != null && v.debugResolutionPath.Count > 0) {
                                list.add(v.debugResolutionPath);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return list;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#init", this ); }

                this.m_CollideAgainst = new UnityEngine.LayerMask();
                this.m_TransparentLayers = new UnityEngine.LayerMask();
                this.m_CollideAgainst = UnityEngine.LayerMask.op_Implicit$1(1);
                this.m_IgnoreTag = "";
                this.m_TransparentLayers = UnityEngine.LayerMask.op_Implicit$1(0);
                this.m_MinimumDistanceFromTarget = 0.1;
                this.m_AvoidObstacles = true;
                this.m_CameraRadius = 0.1;
                this.m_Strategy = Cinemachine.CinemachineCollider.ResolutionStrategy.PreserveCameraHeight;
                this.m_MaximumEffort = 4;
                this.m_SmoothingTime = 0;
                this.m_Damping = 0;
                this.m_DampingWhenOccluded = 0;
                this.m_CornerBuffer = System.Array.init(4, function (){
                    return new UnityEngine.RaycastHit();
                }, UnityEngine.RaycastHit);
                this.mColliderBuffer = System.Array.init(5, null, UnityEngine.Collider);
            }
        },
        methods: {
            /*Cinemachine.CinemachineCollider.IsTargetObscured start.*/
            /**
             * See wheter an object is blocking the camera's view of the target
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineCollider
             * @memberof Cinemachine.CinemachineCollider
             * @param   {Cinemachine.ICinemachineCamera}    vcam    The virtual camera in question.  This might be different from the
                 virtual camera that owns the collider, in the event that the camera has children
             * @return  {boolean}                                   True if something is blocking the view
             */
            IsTargetObscured: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#IsTargetObscured", this ); }

                return this.GetExtraState(Cinemachine.CinemachineCollider.VcamExtraState, vcam).targetObscured;
            },
            /*Cinemachine.CinemachineCollider.IsTargetObscured end.*/

            /*Cinemachine.CinemachineCollider.CameraWasDisplaced start.*/
            /**
             * See whether the virtual camera has been moved nby the collider
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineCollider
             * @memberof Cinemachine.CinemachineCollider
             * @param   {Cinemachine.ICinemachineCamera}    vcam    The virtual camera in question.  This might be different from the
                 virtual camera that owns the collider, in the event that the camera has children
             * @return  {boolean}                                   True if the virtual camera has been displaced due to collision or
                 target obstruction
             */
            CameraWasDisplaced: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#CameraWasDisplaced", this ); }

                return this.GetExtraState(Cinemachine.CinemachineCollider.VcamExtraState, vcam).colliderDisplacement > 0;
            },
            /*Cinemachine.CinemachineCollider.CameraWasDisplaced end.*/

            /*Cinemachine.CinemachineCollider.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#OnValidate", this ); }

                this.m_DistanceLimit = UnityEngine.Mathf.Max(0, this.m_DistanceLimit);
                this.m_MinimumOcclusionTime = UnityEngine.Mathf.Max(0, this.m_MinimumOcclusionTime);
                this.m_CameraRadius = UnityEngine.Mathf.Max(0, this.m_CameraRadius);
                this.m_MinimumDistanceFromTarget = UnityEngine.Mathf.Max(0.01, this.m_MinimumDistanceFromTarget);
                this.m_OptimalTargetDistance = UnityEngine.Mathf.Max(0, this.m_OptimalTargetDistance);
            },
            /*Cinemachine.CinemachineCollider.OnValidate end.*/

            /*Cinemachine.CinemachineCollider.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#OnDestroy", this ); }

                Cinemachine.CinemachineCollider.DestroyCollider();
                Cinemachine.CinemachineExtension.prototype.OnDestroy.call(this);
            },
            /*Cinemachine.CinemachineCollider.OnDestroy end.*/

            /*Cinemachine.CinemachineCollider.PostPipelineStageCallback start.*/
            /**
             * Callback to do the collision resolution and shot evaluation
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineCollider
             * @memberof Cinemachine.CinemachineCollider
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam         
             * @param   {number}                                      stage        
             * @param   {Cinemachine.CameraState}                     state        
             * @param   {number}                                      deltaTime
             * @return  {void}
             */
            PostPipelineStageCallback: function (vcam, stage, state, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#PostPipelineStageCallback", this ); }

                var extra = { v : null };
                if (stage === Cinemachine.CinemachineCore.Stage.Body) {
                    extra.v = this.GetExtraState(Cinemachine.CinemachineCollider.VcamExtraState, vcam);
                    extra.v.targetObscured = false;
                    extra.v.colliderDisplacement = 0;
                    if (extra.v.debugResolutionPath != null) {
                        extra.v.debugResolutionPath.RemoveRange(0, extra.v.debugResolutionPath.Count);
                    }
                }

                // Move the body before the Aim is calculated
                if (stage === Cinemachine.CinemachineCore.Stage.Body) {
                    if (this.m_AvoidObstacles) {
                        var displacement = pc.Vec3.ZERO.clone();
                        displacement = this.PreserveLignOfSight(state, extra);
                        if (this.m_MinimumOcclusionTime > Cinemachine.CinemachineExtension.Epsilon) {
                            var now = UnityEngine.Time.timeSinceLevelLoad;
                            if (displacement.lengthSq() < Cinemachine.CinemachineExtension.Epsilon) {
                                extra.v.occlusionStartTime = 0;
                            } else {
                                if (extra.v.occlusionStartTime <= 0) {
                                    extra.v.occlusionStartTime = now;
                                }

                                if (now - extra.v.occlusionStartTime < this.m_MinimumOcclusionTime) {
                                    displacement = extra.v.m_previousDisplacement.$clone();
                                }
                            }
                        }

                        // Apply distance smoothing
                        if (this.m_SmoothingTime > Cinemachine.CinemachineExtension.Epsilon) {
                            var pos = state.v.CorrectedPosition.$clone().add( displacement );
                            var dir = pos.$clone().sub( state.v.ReferenceLookAt );
                            var distance = dir.length();
                            if (distance > Cinemachine.CinemachineExtension.Epsilon) {
                                dir = dir.$clone().scale( 1.0 / ( distance ) );
                                if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(displacement)) {
                                    extra.v.UpdateDistanceSmoothing(distance, this.m_SmoothingTime);
                                }

                                distance = extra.v.ApplyDistanceSmoothing(distance, this.m_SmoothingTime);
                                displacement = displacement.$clone().add( state.v.ReferenceLookAt.$clone().add( dir.$clone().clone().scale( distance ) ).sub( pos ) );
                            }
                        }

                        var damping = this.m_Damping;
                        if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(displacement)) {
                            extra.v.ResetDistanceSmoothing(this.m_SmoothingTime);
                        } else {
                            damping = this.m_DampingWhenOccluded;
                        }

                        if (damping > 0 && deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                            var delta = displacement.$clone().sub( extra.v.m_previousDisplacement );
                            delta = Cinemachine.Utility.Damper.Damp$1(delta.$clone(), damping, deltaTime);
                            displacement = extra.v.m_previousDisplacement.$clone().add( delta );
                        }

                        extra.v.m_previousDisplacement = displacement.$clone();
                        var correction = this.RespectCameraRadius(state.v.CorrectedPosition.$clone().add( displacement ), state);
                        if (damping > 0 && deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                            var delta1 = correction.$clone().sub( extra.v.m_previousDisplacementCorrection );
                            delta1 = Cinemachine.Utility.Damper.Damp$1(delta1.$clone(), damping, deltaTime);
                            correction = extra.v.m_previousDisplacementCorrection.$clone().add( delta1 );
                        }

                        displacement = displacement.$clone().add( correction.$clone() );
                        extra.v.m_previousDisplacementCorrection = correction.$clone();
                        state.v.PositionCorrection = state.v.PositionCorrection.$clone().add( displacement.$clone() );
                        extra.v.colliderDisplacement += displacement.length();
                    }
                }

                // Rate the shot after the aim was set
                if (stage === Cinemachine.CinemachineCore.Stage.Aim) {
                    extra.v = this.GetExtraState(Cinemachine.CinemachineCollider.VcamExtraState, vcam);
                    extra.v.targetObscured = this.IsTargetOffscreen(state.v.$clone()) || this.CheckForTargetObstructions(state.v.$clone());

                    // GML these values are an initial arbitrary attempt at rating quality
                    if (extra.v.targetObscured) {
                        state.v.ShotQuality *= 0.2;
                    }

                    if (extra.v.colliderDisplacement > 0) {
                        state.v.ShotQuality *= 0.8;
                    }

                    var nearnessBoost = 0;
                    var kMaxNearBoost = 0.2;
                    if (this.m_OptimalTargetDistance > 0 && state.v.HasLookAt) {
                        var distance1 = state.v.ReferenceLookAt.$clone().sub( state.v.FinalPosition ).length();
                        if (distance1 <= this.m_OptimalTargetDistance) {
                            var threshold = this.m_OptimalTargetDistance / 2;
                            if (distance1 >= threshold) {
                                nearnessBoost = kMaxNearBoost * (distance1 - threshold) / (this.m_OptimalTargetDistance - threshold);
                            }
                        } else {
                            distance1 -= this.m_OptimalTargetDistance;
                            var threshold1 = this.m_OptimalTargetDistance * 3;
                            if (distance1 < threshold1) {
                                nearnessBoost = kMaxNearBoost * (1.0 - distance1 / threshold1);
                            }
                        }

                        state.v.ShotQuality *= 1.0 + nearnessBoost;
                    }
                }
            },
            /*Cinemachine.CinemachineCollider.PostPipelineStageCallback end.*/

            /*Cinemachine.CinemachineCollider.PreserveLignOfSight start.*/
            PreserveLignOfSight: function (state, extra) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#PreserveLignOfSight", this ); }

                var displacement = pc.Vec3.ZERO.clone();
                if (state.v.HasLookAt && UnityEngine.LayerMask.op_Implicit(this.m_CollideAgainst) !== 0 && UnityEngine.LayerMask.op_Implicit(this.m_CollideAgainst) !== UnityEngine.LayerMask.op_Implicit(this.m_TransparentLayers)) {
                    var cameraPos = state.v.CorrectedPosition.$clone();
                    var lookAtPos = state.v.ReferenceLookAt.$clone();
                    var hitInfo = { v : new UnityEngine.RaycastHit.ctor() };
                    displacement = this.PullCameraInFrontOfNearestObstacle(cameraPos.$clone(), lookAtPos.$clone(), UnityEngine.LayerMask.op_Implicit(UnityEngine.LayerMask.op_BitwiseAnd(this.m_CollideAgainst.$clone(), UnityEngine.LayerMask.op_Implicit$1(~UnityEngine.LayerMask.op_Implicit(this.m_TransparentLayers)))), hitInfo);
                    var pos = cameraPos.$clone().add( displacement );
                    if (UnityEngine.Component.op_Inequality(hitInfo.v.collider, null)) {
                        extra.v.AddPointToDebugPath(pos.$clone());
                        if (this.m_Strategy !== Cinemachine.CinemachineCollider.ResolutionStrategy.PullCameraForward) {
                            var targetToCamera = cameraPos.$clone().sub( lookAtPos );
                            pos = this.PushCameraBack(pos.$clone(), targetToCamera.$clone(), hitInfo.v.$clone(), lookAtPos.$clone(), new UnityEngine.Plane.$ctor2(state.v.ReferenceUp, cameraPos), targetToCamera.length(), this.m_MaximumEffort, extra);
                        }
                    }

                    displacement = pos.$clone().sub( cameraPos );
                }

                return displacement.$clone();
            },
            /*Cinemachine.CinemachineCollider.PreserveLignOfSight end.*/

            /*Cinemachine.CinemachineCollider.PullCameraInFrontOfNearestObstacle start.*/
            PullCameraInFrontOfNearestObstacle: function (cameraPos, lookAtPos, layerMask, hitInfo) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#PullCameraInFrontOfNearestObstacle", this ); }

                var displacement = pc.Vec3.ZERO.clone();
                var dir = cameraPos.$clone().sub( lookAtPos );
                var targetDistance = dir.length();
                if (targetDistance > Cinemachine.CinemachineExtension.Epsilon) {
                    dir = dir.$clone().scale( 1.0 / ( targetDistance ) );
                    var minDistanceFromTarget = UnityEngine.Mathf.Max(this.m_MinimumDistanceFromTarget, Cinemachine.CinemachineExtension.Epsilon);
                    if (targetDistance < minDistanceFromTarget + Cinemachine.CinemachineExtension.Epsilon) {
                        displacement = dir.$clone().clone().scale( (minDistanceFromTarget - targetDistance) );
                    } else {
                        var rayLength = targetDistance - minDistanceFromTarget;
                        if (this.m_DistanceLimit > Cinemachine.CinemachineExtension.Epsilon) {
                            rayLength = UnityEngine.Mathf.Min(this.m_DistanceLimit, rayLength);
                        }

                        // Make a ray that looks towards the camera, to get the obstacle closest to target
                        var ray = new UnityEngine.Ray.$ctor1(cameraPos.$clone().sub( dir.clone().scale( rayLength ) ), dir);
                        rayLength += Cinemachine.CinemachineCollider.PrecisionSlush;
                        if (rayLength > Cinemachine.CinemachineExtension.Epsilon) {
                            if (this.RaycastIgnoreTag(ray.$clone(), hitInfo, rayLength, layerMask)) {
                                // Pull camera forward in front of obstacle
                                var adjustment = UnityEngine.Mathf.Max(0, hitInfo.v.distance - Cinemachine.CinemachineCollider.PrecisionSlush);
                                displacement = ray.GetPoint(adjustment).sub( cameraPos );
                            }
                        }
                    }
                }

                return displacement.$clone();
            },
            /*Cinemachine.CinemachineCollider.PullCameraInFrontOfNearestObstacle end.*/

            /*Cinemachine.CinemachineCollider.RaycastIgnoreTag start.*/
            RaycastIgnoreTag: function (ray, hitInfo, rayLength, layerMask) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#RaycastIgnoreTag", this ); }

                var extraDistance = 0;
                while (UnityEngine.Physics.Raycast$1(ray, hitInfo, rayLength, layerMask, UnityEngine.QueryTriggerInteraction.Ignore)) {
                    if (this.m_IgnoreTag.length === 0 || !hitInfo.v.collider.CompareTag(this.m_IgnoreTag)) {
                        hitInfo.v.distance += extraDistance;
                        return true;
                    }

                    // Ignore the hit.  Pull ray origin forward in front of obstacle
                    var inverseRay = new UnityEngine.Ray.$ctor1(ray.GetPoint(rayLength), ray.direction.$clone().scale( -1 ));
                    if (!hitInfo.v.collider.Raycast(inverseRay.$clone(), hitInfo, rayLength)) {
                        break;
                    }

                    var deltaExtraDistance = rayLength - (hitInfo.v.distance - Cinemachine.CinemachineCollider.PrecisionSlush);
                    if (deltaExtraDistance < Cinemachine.CinemachineExtension.Epsilon) {
                        break;
                    }

                    extraDistance += deltaExtraDistance;
                    rayLength = hitInfo.v.distance - Cinemachine.CinemachineCollider.PrecisionSlush;
                    if (rayLength < Cinemachine.CinemachineExtension.Epsilon) {
                        break;
                    }

                    ray.origin = inverseRay.GetPoint(rayLength);
                }

                return false;
            },
            /*Cinemachine.CinemachineCollider.RaycastIgnoreTag end.*/

            /*Cinemachine.CinemachineCollider.PushCameraBack start.*/
            PushCameraBack: function (currentPos, pushDir, obstacle, lookAtPos, startPlane, targetDistance, iterations, extra) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#PushCameraBack", this ); }

                // Take a step along the wall.
                var pos = currentPos.$clone();
                var dir = { v : pc.Vec3.ZERO.clone() };
                if (!this.GetWalkingDirection(pos.$clone(), pushDir.$clone(), obstacle.$clone(), dir)) {
                    return pos.$clone();
                }

                var ray = new UnityEngine.Ray.$ctor1(pos, dir.v);
                var distance = this.GetPushBackDistance(ray.$clone(), startPlane.$clone(), targetDistance, lookAtPos.$clone());
                if (distance <= Cinemachine.CinemachineExtension.Epsilon) {
                    return pos.$clone();
                }

                // Check only as far as the obstacle bounds
                var clampedDistance = this.ClampRayToBounds(ray.$clone(), distance, obstacle.collider.bounds);
                distance = UnityEngine.Mathf.Min(distance, clampedDistance + Cinemachine.CinemachineCollider.PrecisionSlush);

                var hitInfo = { v : new UnityEngine.RaycastHit() };
                if (this.RaycastIgnoreTag(ray.$clone(), hitInfo, distance, UnityEngine.LayerMask.op_Implicit(UnityEngine.LayerMask.op_BitwiseAnd(this.m_CollideAgainst.$clone(), UnityEngine.LayerMask.op_Implicit$1(~UnityEngine.LayerMask.op_Implicit(this.m_TransparentLayers)))))) {
                    // We hit something.  Stop there and take a step along that wall.
                    var adjustment = hitInfo.v.distance - Cinemachine.CinemachineCollider.PrecisionSlush;
                    pos = ray.GetPoint(adjustment);
                    extra.v.AddPointToDebugPath(pos.$clone());
                    if (iterations > 1) {
                        pos = this.PushCameraBack(pos.$clone(), dir.v.$clone(), hitInfo.v.$clone(), lookAtPos.$clone(), startPlane.$clone(), targetDistance, iterations - 1, extra);
                    }

                    return pos.$clone();
                }

                // Didn't hit anything.  Can we push back all the way now?
                pos = ray.GetPoint(distance);

                // First check if we can still see the target.  If not, abort
                dir.v = pos.$clone().sub( lookAtPos );
                var d = dir.v.length();
                var hitInfo2 = { v : new UnityEngine.RaycastHit() };
                if (d < Cinemachine.CinemachineExtension.Epsilon || this.RaycastIgnoreTag(new UnityEngine.Ray.$ctor1(lookAtPos, dir.v), hitInfo2, d - Cinemachine.CinemachineCollider.PrecisionSlush, UnityEngine.LayerMask.op_Implicit(UnityEngine.LayerMask.op_BitwiseAnd(this.m_CollideAgainst.$clone(), UnityEngine.LayerMask.op_Implicit$1(~UnityEngine.LayerMask.op_Implicit(this.m_TransparentLayers)))))) {
                    return currentPos.$clone();
                }

                // All clear
                ray = new UnityEngine.Ray.$ctor1(pos, dir.v);
                extra.v.AddPointToDebugPath(pos.$clone());
                distance = this.GetPushBackDistance(ray.$clone(), startPlane.$clone(), targetDistance, lookAtPos.$clone());
                if (distance > Cinemachine.CinemachineExtension.Epsilon) {
                    if (!this.RaycastIgnoreTag(ray.$clone(), hitInfo, distance, UnityEngine.LayerMask.op_Implicit(UnityEngine.LayerMask.op_BitwiseAnd(this.m_CollideAgainst.$clone(), UnityEngine.LayerMask.op_Implicit$1(~UnityEngine.LayerMask.op_Implicit(this.m_TransparentLayers)))))) {
                        pos = ray.GetPoint(distance); // no obstacles - all good
                        extra.v.AddPointToDebugPath(pos.$clone());
                    } else {
                        // We hit something.  Stop there and maybe take a step along that wall
                        var adjustment1 = hitInfo.v.distance - Cinemachine.CinemachineCollider.PrecisionSlush;
                        pos = ray.GetPoint(adjustment1);
                        extra.v.AddPointToDebugPath(pos.$clone());
                        if (iterations > 1) {
                            pos = this.PushCameraBack(pos.$clone(), dir.v.$clone(), hitInfo.v.$clone(), lookAtPos.$clone(), startPlane.$clone(), targetDistance, iterations - 1, extra);
                        }
                    }
                }

                return pos.$clone();
            },
            /*Cinemachine.CinemachineCollider.PushCameraBack end.*/

            /*Cinemachine.CinemachineCollider.GetWalkingDirection start.*/
            GetWalkingDirection: function (pos, pushDir, obstacle, outDir) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#GetWalkingDirection", this ); }

                var normal2 = obstacle.normal.$clone();

                // Check for nearby obstacles.  Are we in a corner?
                var nearbyDistance = 0.00500000035;
                var numFound = UnityEngine.Physics.SphereCastNonAlloc$1(pos, nearbyDistance, pushDir.clone().normalize(), this.m_CornerBuffer, 0, UnityEngine.LayerMask.op_Implicit(UnityEngine.LayerMask.op_BitwiseAnd(this.m_CollideAgainst.$clone(), UnityEngine.LayerMask.op_Implicit$1(~UnityEngine.LayerMask.op_Implicit(this.m_TransparentLayers)))), UnityEngine.QueryTriggerInteraction.Ignore);
                if (numFound > 1) {
                    // Calculate the second normal
                    for (var i = 0; i < numFound; ++i) {
                        if (UnityEngine.Component.op_Equality(this.m_CornerBuffer[i].collider, null)) {
                            continue;
                        }

                        if (this.m_IgnoreTag.length > 0 && this.m_CornerBuffer[i].collider.CompareTag(this.m_IgnoreTag)) {
                            continue;
                        }

                        var type = Bridge.getType(this.m_CornerBuffer[i].collider);
                        if (Bridge.referenceEquals(type, UnityEngine.BoxCollider) || Bridge.referenceEquals(type, UnityEngine.SphereCollider) || Bridge.referenceEquals(type, UnityEngine.CapsuleCollider)) {
                            var p = this.m_CornerBuffer[i].collider.ClosestPoint(pos);
                            var d = p.$clone().sub( pos );
                            if (d.length() > pc.Vec3.kEpsilon) {
                                if (this.m_CornerBuffer[i].collider.Raycast(new UnityEngine.Ray.$ctor1(pos, d), Bridge.ref(this.m_CornerBuffer, i), nearbyDistance)) {
                                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero((this.m_CornerBuffer[i].normal.$clone().sub( obstacle.normal )))) {
                                        normal2 = this.m_CornerBuffer[i].normal.$clone();
                                    }

                                    break;
                                }
                            }
                        }
                    }
                }

                // Walk along the wall.  If we're in a corner, walk their intersecting line
                var dir = new pc.Vec3().cross( obstacle.normal, normal2 );
                if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(dir)) {
                    dir = pc.Vec3.projectOnPlane( pushDir, obstacle.normal );
                } else {
                    var dot = dir.dot( pushDir );
                    if (Math.abs(dot) < Cinemachine.CinemachineExtension.Epsilon) {
                        return false;
                    }

                    if (dot < 0) {
                        dir = dir.$clone().scale( -1 );
                    }
                }

                if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(dir)) {
                    return false;
                }

                outDir.v = dir.clone().normalize().$clone();
                return true;
            },
            /*Cinemachine.CinemachineCollider.GetWalkingDirection end.*/

            /*Cinemachine.CinemachineCollider.GetPushBackDistance start.*/
            GetPushBackDistance: function (ray, startPlane, targetDistance, lookAtPos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#GetPushBackDistance", this ); }

                var maxDistance = targetDistance - (ray.origin.$clone().sub( lookAtPos )).length();
                if (maxDistance < Cinemachine.CinemachineExtension.Epsilon) {
                    return 0;
                }

                if (this.m_Strategy === Cinemachine.CinemachineCollider.ResolutionStrategy.PreserveCameraDistance) {
                    return maxDistance;
                }

                var distance = { };
                if (!startPlane.Raycast(ray, distance)) {
                    distance.v = 0;
                }

                distance.v = UnityEngine.Mathf.Min(maxDistance, distance.v);
                if (distance.v < Cinemachine.CinemachineExtension.Epsilon) {
                    return 0;
                }

                // If we are close to parallel to the plane, we have to take special action
                var angle = Math.abs(Cinemachine.Utility.UnityVectorExtensions.Angle(startPlane.normal.$clone(), ray.direction.$clone()) - 90);
                if (angle < Cinemachine.CinemachineCollider.AngleThreshold) {
                    distance.v = pc.math.lerp(0, distance.v, angle / Cinemachine.CinemachineCollider.AngleThreshold);
                }

                return distance.v;
            },
            /*Cinemachine.CinemachineCollider.GetPushBackDistance end.*/

            /*Cinemachine.CinemachineCollider.ClampRayToBounds start.*/
            ClampRayToBounds: function (ray, distance, bounds) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#ClampRayToBounds", this ); }

                var d = { };
                if (ray.direction.dot( pc.Vec3.UP.clone() ) > 0) {
                    if (new UnityEngine.Plane.$ctor2(pc.Vec3.DOWN.clone(), bounds.max).Raycast(ray, d) && d.v > Cinemachine.CinemachineExtension.Epsilon) {
                        distance = UnityEngine.Mathf.Min(distance, d.v);
                    }
                } else if (ray.direction.dot( pc.Vec3.DOWN.clone() ) > 0) {
                    if (new UnityEngine.Plane.$ctor2(pc.Vec3.UP.clone(), bounds.min).Raycast(ray, d) && d.v > Cinemachine.CinemachineExtension.Epsilon) {
                        distance = UnityEngine.Mathf.Min(distance, d.v);
                    }
                }

                if (ray.direction.dot( pc.Vec3.RIGHT.clone() ) > 0) {
                    if (new UnityEngine.Plane.$ctor2(pc.Vec3.LEFT.clone(), bounds.max).Raycast(ray, d) && d.v > Cinemachine.CinemachineExtension.Epsilon) {
                        distance = UnityEngine.Mathf.Min(distance, d.v);
                    }
                } else if (ray.direction.dot( pc.Vec3.LEFT.clone() ) > 0) {
                    if (new UnityEngine.Plane.$ctor2(pc.Vec3.RIGHT.clone(), bounds.min).Raycast(ray, d) && d.v > Cinemachine.CinemachineExtension.Epsilon) {
                        distance = UnityEngine.Mathf.Min(distance, d.v);
                    }
                }

                if (ray.direction.dot( new pc.Vec3( 0, 0, 1 ) ) > 0) {
                    if (new UnityEngine.Plane.$ctor2(new pc.Vec3( 0, 0, -1 ), bounds.max).Raycast(ray, d) && d.v > Cinemachine.CinemachineExtension.Epsilon) {
                        distance = UnityEngine.Mathf.Min(distance, d.v);
                    }
                } else if (ray.direction.dot( new pc.Vec3( 0, 0, -1 ) ) > 0) {
                    if (new UnityEngine.Plane.$ctor2(new pc.Vec3( 0, 0, 1 ), bounds.min).Raycast(ray, d) && d.v > Cinemachine.CinemachineExtension.Epsilon) {
                        distance = UnityEngine.Mathf.Min(distance, d.v);
                    }
                }

                return distance;
            },
            /*Cinemachine.CinemachineCollider.ClampRayToBounds end.*/

            /*Cinemachine.CinemachineCollider.RespectCameraRadius start.*/
            RespectCameraRadius: function (cameraPos, state) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#RespectCameraRadius", this ); }

                var result = pc.Vec3.ZERO.clone();
                if (this.m_CameraRadius < Cinemachine.CinemachineExtension.Epsilon || UnityEngine.LayerMask.op_Implicit(this.m_CollideAgainst) === 0) {
                    return result.$clone();
                }

                var dir = state.v.HasLookAt ? cameraPos.$clone().sub( state.v.ReferenceLookAt ) : pc.Vec3.ZERO.clone();
                var ray = new UnityEngine.Ray.ctor();
                var distance = dir.length();
                if (distance > Cinemachine.CinemachineExtension.Epsilon) {
                    dir = dir.$clone().scale( 1.0 / ( distance ) );
                    ray = new UnityEngine.Ray.$ctor1(state.v.ReferenceLookAt, dir);
                }

                // Pull it out of any intersecting obstacles
                var hitInfo = { v : new UnityEngine.RaycastHit() };
                var numObstacles = UnityEngine.Physics.OverlapSphereNonAlloc(cameraPos, this.m_CameraRadius, this.mColliderBuffer, UnityEngine.LayerMask.op_Implicit(this.m_CollideAgainst.$clone()), UnityEngine.QueryTriggerInteraction.Ignore);
                if (numObstacles === 0 && UnityEngine.LayerMask.op_Implicit(this.m_TransparentLayers) !== 0 && distance > this.m_MinimumDistanceFromTarget + Cinemachine.CinemachineExtension.Epsilon) {
                    // Make sure the camera position isn't completely inside an obstacle.
                    // OverlapSphereNonAlloc won't catch those.
                    var d = distance - this.m_MinimumDistanceFromTarget;
                    var targetPos = state.v.ReferenceLookAt.$clone().add( dir.$clone().clone().scale( this.m_MinimumDistanceFromTarget ) );
                    if (this.RaycastIgnoreTag(new UnityEngine.Ray.$ctor1(targetPos, dir), hitInfo, d, UnityEngine.LayerMask.op_Implicit(this.m_CollideAgainst.$clone()))) {
                        // Only count it if there's an incoming collision but not an outgoing one
                        var c = hitInfo.v.collider;
                        if (!c.Raycast(new UnityEngine.Ray.$ctor1(cameraPos, dir.$clone().scale( -1 )), hitInfo, d)) {
                            this.mColliderBuffer[numObstacles++] = c;
                        }
                    }
                }

                if (numObstacles > 0 && distance === 0 || distance > this.m_MinimumDistanceFromTarget) {
                    if (UnityEngine.GameObject.op_Equality(Cinemachine.CinemachineCollider.mCameraColliderGameObject, null)) {
                        Cinemachine.CinemachineCollider.mCameraColliderGameObject = new UnityEngine.GameObject.$ctor2("CinemachineCollider Collider");
                        Cinemachine.CinemachineCollider.mCameraColliderGameObject.hideFlags = UnityEngine.HideFlags.HideAndDontSave;
                        Cinemachine.CinemachineCollider.mCameraColliderGameObject.transform.position = pc.Vec3.ZERO.clone();
                        Cinemachine.CinemachineCollider.mCameraColliderGameObject.SetActive(true);
                        Cinemachine.CinemachineCollider.mCameraCollider = Cinemachine.CinemachineCollider.mCameraColliderGameObject.AddComponent(UnityEngine.SphereCollider);
                        Cinemachine.CinemachineCollider.mCameraCollider.isTrigger = true;
                        var rb = Cinemachine.CinemachineCollider.mCameraColliderGameObject.AddComponent(UnityEngine.Rigidbody);
                        rb.detectCollisions = false;
                        rb.isKinematic = true;
                    }

                    Cinemachine.CinemachineCollider.mCameraCollider.radius = this.m_CameraRadius;
                    var offsetDir = { v : new UnityEngine.Vector3() };
                    var offsetDistance = { };
                    var newCamPos = cameraPos.$clone();
                    for (var i = 0; i < numObstacles; ++i) {
                        var c1 = this.mColliderBuffer[i];
                        if (this.m_IgnoreTag.length > 0 && c1.CompareTag(this.m_IgnoreTag)) {
                            continue;
                        }

                        // If we have a lookAt target, move the camera to the nearest edge of obstacle
                        if (distance > this.m_MinimumDistanceFromTarget) {
                            dir = newCamPos.$clone().sub( state.v.ReferenceLookAt );
                            var d1 = dir.length();
                            if (d1 > Cinemachine.CinemachineExtension.Epsilon) {
                                dir = dir.$clone().scale( 1.0 / ( d1 ) );
                                ray = new UnityEngine.Ray.$ctor1(state.v.ReferenceLookAt, dir);
                                if (c1.Raycast(ray.$clone(), hitInfo, d1 + this.m_CameraRadius)) {
                                    newCamPos = ray.GetPoint(hitInfo.v.distance).sub( dir.$clone().clone().scale( Cinemachine.CinemachineCollider.PrecisionSlush ) );
                                }
                            }
                        }

                        if (UnityEngine.Physics.ComputePenetration(Cinemachine.CinemachineCollider.mCameraCollider, newCamPos, pc.Quat.IDENTITY.clone(), c1, c1.transform.position, c1.transform.rotation, offsetDir, offsetDistance)) {
                            newCamPos = newCamPos.$clone().add( offsetDir.v.$clone().clone().scale( offsetDistance.v ) );
                        }
                    }

                    result = newCamPos.$clone().sub( cameraPos );
                }

                // Respect the minimum distance from target - push camera back if we have to
                if (distance > Cinemachine.CinemachineExtension.Epsilon) {
                    var minDistance = UnityEngine.Mathf.Max(this.m_MinimumDistanceFromTarget, this.m_CameraRadius) + Cinemachine.CinemachineCollider.PrecisionSlush;
                    var newOffset = cameraPos.$clone().add( result ).sub( state.v.ReferenceLookAt );
                    if (newOffset.length() < minDistance) {
                        result = state.v.ReferenceLookAt.$clone().sub( cameraPos ).add( dir.$clone().clone().scale( minDistance ) );
                    }
                }

                return result.$clone();
            },
            /*Cinemachine.CinemachineCollider.RespectCameraRadius end.*/

            /*Cinemachine.CinemachineCollider.CheckForTargetObstructions start.*/
            CheckForTargetObstructions: function (state) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#CheckForTargetObstructions", this ); }

                if (state.HasLookAt) {
                    var lookAtPos = state.ReferenceLookAt.$clone();
                    var pos = state.CorrectedPosition.$clone();
                    var dir = lookAtPos.$clone().sub( pos );
                    var distance = dir.length();
                    if (distance < UnityEngine.Mathf.Max(this.m_MinimumDistanceFromTarget, Cinemachine.CinemachineExtension.Epsilon)) {
                        return true;
                    }

                    var ray = new UnityEngine.Ray.$ctor1(pos, dir.clone().normalize());
                    var hitInfo = { v : new UnityEngine.RaycastHit() };
                    if (this.RaycastIgnoreTag(ray.$clone(), hitInfo, distance - this.m_MinimumDistanceFromTarget, UnityEngine.LayerMask.op_Implicit(UnityEngine.LayerMask.op_BitwiseAnd(this.m_CollideAgainst.$clone(), UnityEngine.LayerMask.op_Implicit$1(~UnityEngine.LayerMask.op_Implicit(this.m_TransparentLayers)))))) {
                        return true;
                    }
                }

                return false;
            },
            /*Cinemachine.CinemachineCollider.CheckForTargetObstructions end.*/

            /*Cinemachine.CinemachineCollider.IsTargetOffscreen start.*/
            IsTargetOffscreen: function (state) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollider#IsTargetOffscreen", this ); }

                if (state.HasLookAt) {
                    var dir = state.ReferenceLookAt.$clone().sub( state.CorrectedPosition );
                    dir = state.CorrectedOrientation.clone().invert().transformVector( dir );
                    if (state.Lens.Orthographic) {
                        if (Math.abs(dir.y) > state.Lens.OrthographicSize) {
                            return true;
                        }

                        if (Math.abs(dir.x) > state.Lens.OrthographicSize * state.Lens.Aspect) {
                            return true;
                        }
                    } else {
                        var fov = state.Lens.FieldOfView / 2;
                        var angle = Cinemachine.Utility.UnityVectorExtensions.Angle(Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(dir, pc.Vec3.RIGHT.clone()), new pc.Vec3( 0, 0, 1 ));
                        if (angle > fov) {
                            return true;
                        }

                        fov = UnityEngine.Mathf.Rad2Deg * Math.atan(Math.tan(fov * UnityEngine.Mathf.Deg2Rad) * state.Lens.Aspect);
                        angle = Cinemachine.Utility.UnityVectorExtensions.Angle(Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(dir, pc.Vec3.UP.clone()), new pc.Vec3( 0, 0, 1 ));
                        if (angle > fov) {
                            return true;
                        }
                    }
                }

                return false;
            },
            /*Cinemachine.CinemachineCollider.IsTargetOffscreen end.*/


        }
    });
    /*Cinemachine.CinemachineCollider end.*/

    /*Cinemachine.CinemachineCollisionImpulseSource start.*/
    /**
     * Generate an Impulse Event this object's Collider collides with something
         or its trigger zone is entered.
         This component should be attached to a GameObject with a Collider or a Collider2D.
         Objects colliding with this (or entering its trigger zone if it's a trigger) will be
         filtered according to the layer and tag settings defined here, and if they
         pass the filter, they will cause an impulse event to be generated.
     *
     * @public
     * @class Cinemachine.CinemachineCollisionImpulseSource
     * @augments Cinemachine.CinemachineImpulseSource
     */
    Bridge.define("Cinemachine.CinemachineCollisionImpulseSource", {
        inherits: [Cinemachine.CinemachineImpulseSource],
        fields: {
            /**
             * No Impulse evemts will be generated for collisions with objects having these tags
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollisionImpulseSource
             * @default ""
             * @type string
             */
            m_IgnoreTag: null,
            /**
             * Only collisions with objects on these layers will generate Impulse events.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollisionImpulseSource
             * @default 1
             * @type UnityEngine.LayerMask
             */
            m_LayerMask: null,
            /**
             * If checked, signal amplitude will be multiplied by the mass of the impacting object
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollisionImpulseSource
             * @default false
             * @type boolean
             */
            m_ScaleImpactWithMass: false,
            /**
             * If checked, signal amplitude will be multiplied by the speed of the impacting object
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollisionImpulseSource
             * @default false
             * @type boolean
             */
            m_ScaleImpactWithSpeed: false,
            /**
             * If checked, signal direction will be affected by the direction of impact
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineCollisionImpulseSource
             * @default false
             * @type boolean
             */
            m_UseImpactDirection: false,
            mRigidBody: null,
            mRigidBody2D: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#init", this ); }

                this.m_LayerMask = new UnityEngine.LayerMask();
                this.m_IgnoreTag = "";
                this.m_LayerMask = UnityEngine.LayerMask.op_Implicit$1(1);
                this.m_ScaleImpactWithMass = false;
                this.m_ScaleImpactWithSpeed = false;
                this.m_UseImpactDirection = false;
            }
        },
        methods: {
            /*Cinemachine.CinemachineCollisionImpulseSource.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#Start", this ); }

                this.mRigidBody = this.GetComponent(UnityEngine.Rigidbody);
                this.mRigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.Start end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#OnEnable", this ); }
 },
            /*Cinemachine.CinemachineCollisionImpulseSource.OnEnable end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.OnCollisionEnter start.*/
            OnCollisionEnter: function (c) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#OnCollisionEnter", this ); }

                this.GenerateImpactEvent(c.collider, c.relativeVelocity.$clone());
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.OnCollisionEnter end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.OnTriggerEnter start.*/
            OnTriggerEnter: function (c) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#OnTriggerEnter", this ); }

                this.GenerateImpactEvent(c, pc.Vec3.ZERO.clone());
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.OnTriggerEnter end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.GetMassAndVelocity start.*/
            GetMassAndVelocity: function (other, vel) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#GetMassAndVelocity", this ); }

                var getVelocity = pc.Vec3.equals( vel.v, pc.Vec3.ZERO.clone() );
                var mass = 1;
                if (this.m_ScaleImpactWithMass || this.m_ScaleImpactWithSpeed || this.m_UseImpactDirection) {
                    if (UnityEngine.Component.op_Inequality(this.mRigidBody, null)) {
                        if (this.m_ScaleImpactWithMass) {
                            mass *= this.mRigidBody.mass;
                        }

                        if (getVelocity) {
                            vel.v = this.mRigidBody.velocity.$clone().scale( -1 );
                        }
                    }

                    var rb = UnityEngine.Component.op_Inequality(other, null) ? other.attachedRigidbody : null;
                    if (UnityEngine.Component.op_Inequality(rb, null)) {
                        if (this.m_ScaleImpactWithMass) {
                            mass *= rb.mass;
                        }

                        if (getVelocity) {
                            vel.v = vel.v.$clone().add( rb.velocity.$clone() );
                        }
                    }
                }

                return mass;
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.GetMassAndVelocity end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.GenerateImpactEvent start.*/
            GenerateImpactEvent: function (other, vel) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#GenerateImpactEvent", this ); }

                vel = {v:vel};
                // Check the filters
                if (!this.enabled) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(other, null)) {
                    var layer = other.gameObject.layer;
                    if (UnityEngine.LayerMask.op_Implicit((UnityEngine.LayerMask.op_BitwiseAnd(UnityEngine.LayerMask.op_Implicit$1((1 << layer)), this.m_LayerMask.$clone()))) === 0) {
                        return;
                    }

                    if (this.m_IgnoreTag.length !== 0 && other.CompareTag(this.m_IgnoreTag)) {
                        return;
                    }
                }

                // Calculate the signal direction and magnitude
                var mass = this.GetMassAndVelocity(other, vel);
                if (this.m_ScaleImpactWithSpeed) {
                    mass *= vel.v.length();
                }

                var dir = pc.Vec3.DOWN.clone();
                if (this.m_UseImpactDirection && !Cinemachine.Utility.UnityVectorExtensions.AlmostZero(vel.v)) {
                    dir = vel.v.clone().normalize().$clone().scale( -1 );
                }

                // Fire it off!
                this.GenerateImpulse$1(dir.$clone().clone().scale( mass ));
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.GenerateImpactEvent end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (c) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#OnCollisionEnter2D", this ); }

                this.GenerateImpactEvent2D(c.collider, c.relativeVelocity.$clone());
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.OnCollisionEnter2D end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (c) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#OnTriggerEnter2D", this ); }

                this.GenerateImpactEvent2D(c, pc.Vec3.ZERO.clone());
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.OnTriggerEnter2D end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.GetMassAndVelocity2D start.*/
            GetMassAndVelocity2D: function (other2d, vel) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#GetMassAndVelocity2D", this ); }

                var getVelocity = pc.Vec3.equals( vel.v, pc.Vec3.ZERO.clone() );
                var mass = 1;
                if (this.m_ScaleImpactWithMass || this.m_ScaleImpactWithSpeed || this.m_UseImpactDirection) {
                    if (UnityEngine.Component.op_Inequality(this.mRigidBody2D, null)) {
                        if (this.m_ScaleImpactWithMass) {
                            mass *= this.mRigidBody2D.mass;
                        }

                        if (getVelocity) {
                            vel.v = UnityEngine.Vector3.FromVector2(this.mRigidBody2D.velocity.$clone().scale( -1 ));
                        }
                    }

                    var rb2d = UnityEngine.Component.op_Inequality(other2d, null) ? other2d.attachedRigidbody : null;
                    if (UnityEngine.Component.op_Inequality(rb2d, null)) {
                        if (this.m_ScaleImpactWithMass) {
                            mass *= rb2d.mass;
                        }

                        if (getVelocity) {
                            var v = UnityEngine.Vector3.FromVector2(rb2d.velocity.$clone());
                            vel.v = vel.v.$clone().add( v.$clone() );
                        }
                    }
                }

                return mass;
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.GetMassAndVelocity2D end.*/

            /*Cinemachine.CinemachineCollisionImpulseSource.GenerateImpactEvent2D start.*/
            GenerateImpactEvent2D: function (other2d, vel) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineCollisionImpulseSource#GenerateImpactEvent2D", this ); }

                vel = {v:vel};
                // Check the filters
                if (!this.enabled) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(other2d, null)) {
                    var layer = other2d.gameObject.layer;
                    if (UnityEngine.LayerMask.op_Implicit((UnityEngine.LayerMask.op_BitwiseAnd(UnityEngine.LayerMask.op_Implicit$1((1 << layer)), this.m_LayerMask.$clone()))) === 0) {
                        return;
                    }

                    if (this.m_IgnoreTag.length !== 0 && other2d.CompareTag(this.m_IgnoreTag)) {
                        return;
                    }
                }

                // Calculate the signal direction and magnitude
                var mass = this.GetMassAndVelocity2D(other2d, vel);
                if (this.m_ScaleImpactWithSpeed) {
                    mass *= vel.v.length();
                }

                var dir = pc.Vec3.DOWN.clone();
                if (this.m_UseImpactDirection && !Cinemachine.Utility.UnityVectorExtensions.AlmostZero(vel.v)) {
                    dir = vel.v.clone().normalize().$clone().scale( -1 );
                }

                // Fire it off!
                this.GenerateImpulse$1(dir.$clone().clone().scale( mass ));
            },
            /*Cinemachine.CinemachineCollisionImpulseSource.GenerateImpactEvent2D end.*/


        }
    });
    /*Cinemachine.CinemachineCollisionImpulseSource end.*/

    /*Cinemachine.CinemachineComposer start.*/
    /**
     * This is a CinemachineComponent in the Aim section of the component pipeline.
         Its job is to aim the camera at the vcam's LookAt target object, with
         configurable offsets, damping, and composition rules.
         The composer does not change the camera's position.  It will only pan and tilt the
         camera where it is, in order to get the desired framing.  To move the camera, you have
         to use the virtual camera's Body section.
     *
     * @public
     * @class Cinemachine.CinemachineComposer
     * @augments Cinemachine.CinemachineComponentBase
     */
    Bridge.define("Cinemachine.CinemachineComposer", {
        inherits: [Cinemachine.CinemachineComponentBase],
        fields: {
            /**
             * A non-zero bias will move the targt position away from the center of the soft zone
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @type number
             */
            m_BiasX: 0,
            /**
             * A non-zero bias will move the targt position away from the center of the soft zone
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @type number
             */
            m_BiasY: 0,
            m_CameraOrientationPrevFrame: null,
            /**
             * State information for damping
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineComposer
             * @type UnityEngine.Vector3
             */
            m_CameraPosPrevFrame: null,
            /**
             * Force target to center of screen when this camera activates.  If false, will clamp target to the edges of the
                 dead zone
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default true
             * @type boolean
             */
            m_CenterOnActivate: false,
            /**
             * Camera will not rotate vertically if the target is within this range of the position
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @type number
             */
            m_DeadZoneHeight: 0,
            /**
             * Camera will not rotate horizontally if the target is within this range of the position
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @type number
             */
            m_DeadZoneWidth: 0,
            /**
             * How aggressively the camera tries to follow the target in the screen-horizontal direction.
                 Small numbers are more responsive, rapidly orienting the camera to keep the target in
                 the dead zone. Larger numbers give a more heavy slowly responding camera.
                 Using different vertical and horizontal settings can yield a wide range of camera behaviors.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default 0.5
             * @type number
             */
            m_HorizontalDamping: 0,
            /**
             * If checked, movement along the Y axis will be ignored for lookahead calculations
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @type boolean
             */
            m_LookaheadIgnoreY: false,
            /**
             * Controls the smoothness of the lookahead algorithm.  Larger values smooth out
                 jittery predictions and also increase prediction lag
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default 10
             * @type number
             */
            m_LookaheadSmoothing: 0,
            /**
             * This setting will instruct the composer to adjust its target offset based
                 on the motion of the target.  The composer will look at a point where it estimates
                 the target will be this many seconds into the future.  Note that this setting is sensitive
                 to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.
                 If the camera jitters unacceptably when the target is in motion, turn down this setting,
                 or animate the target more smoothly.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default 0
             * @type number
             */
            m_LookaheadTime: 0,
            m_LookAtPrevFrame: null,
            m_Predictor: null,
            m_ScreenOffsetPrevFrame: null,
            /**
             * Horizontal screen position for target. The camera will rotate to the position the tracked object here
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default 0.5
             * @type number
             */
            m_ScreenX: 0,
            /**
             * Vertical screen position for target, The camera will rotate to to position the tracked object here
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default 0.5
             * @type number
             */
            m_ScreenY: 0,
            /**
             * When target is within this region, camera will gradually move to re-align
                 towards the desired position, depending onm the damping speed
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default 0.8
             * @type number
             */
            m_SoftZoneHeight: 0,
            /**
             * When target is within this region, camera will gradually move to re-align
                 towards the desired position, depending onm the damping speed
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default 0.8
             * @type number
             */
            m_SoftZoneWidth: 0,
            /**
             * Target offset from the object's center in LOCAL space which
                 the Composer tracks. Use this to fine-tune the tracking target position
                 when the desired area is not in the tracked object's center
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @type UnityEngine.Vector3
             */
            m_TrackedObjectOffset: null,
            /**
             * How aggressively the camera tries to follow the target in the screen-vertical direction.
                 Small numbers are more responsive, rapidly orienting the camera to keep the target in
                 the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical
                 and horizontal settings can yield a wide range of camera behaviors.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @default 0.5
             * @type number
             */
            m_VerticalDamping: 0,
            mCache: null,
            /**
             * Internal API for inspector
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineComposer
             * @function TrackedPoint
             * @type UnityEngine.Vector3
             */
            TrackedPoint: null
        },
        props: {
            /**
             * True if component is enabled and has a LookAt defined
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineComposer
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#IsValid#get", this ); }

                    return this.enabled && UnityEngine.Component.op_Inequality(this.LookAtTarget, null);
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Aim stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineComposer
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Aim;
                }
            },
            /**
             * Internal API for the inspector editor
             *
             * @instance
             * @memberof Cinemachine.CinemachineComposer
             * @function SoftGuideRect
             * @type UnityEngine.Rect
             */
            SoftGuideRect: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#SoftGuideRect#get", this ); }

                    return new UnityEngine.Rect.$ctor1(this.m_ScreenX - this.m_DeadZoneWidth / 2, this.m_ScreenY - this.m_DeadZoneHeight / 2, this.m_DeadZoneWidth, this.m_DeadZoneHeight);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#SoftGuideRect#set", this ); }

                    this.m_DeadZoneWidth = Math.max(0, Math.min(value.width, 2));
                    this.m_DeadZoneHeight = Math.max(0, Math.min(value.height, 2));
                    this.m_ScreenX = Math.max(-0.5, Math.min(value.x + this.m_DeadZoneWidth / 2, 1.5));
                    this.m_ScreenY = Math.max(-0.5, Math.min(value.y + this.m_DeadZoneHeight / 2, 1.5));
                    this.m_SoftZoneWidth = UnityEngine.Mathf.Max(this.m_SoftZoneWidth, this.m_DeadZoneWidth);
                    this.m_SoftZoneHeight = UnityEngine.Mathf.Max(this.m_SoftZoneHeight, this.m_DeadZoneHeight);
                }
            },
            /**
             * Internal API for the inspector editor
             *
             * @instance
             * @memberof Cinemachine.CinemachineComposer
             * @function HardGuideRect
             * @type UnityEngine.Rect
             */
            HardGuideRect: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#HardGuideRect#get", this ); }

                    var r = new UnityEngine.Rect.$ctor1(this.m_ScreenX - this.m_SoftZoneWidth / 2, this.m_ScreenY - this.m_SoftZoneHeight / 2, this.m_SoftZoneWidth, this.m_SoftZoneHeight);
                    r.position = r.position.$clone().add( new pc.Vec2( this.m_BiasX * (this.m_SoftZoneWidth - this.m_DeadZoneWidth), this.m_BiasY * (this.m_SoftZoneHeight - this.m_DeadZoneHeight) ) );
                    return r.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#HardGuideRect#set", this ); }

                    this.m_SoftZoneWidth = Math.max(0, Math.min(value.width, 2.0));
                    this.m_SoftZoneHeight = Math.max(0, Math.min(value.height, 2.0));
                    this.m_DeadZoneWidth = UnityEngine.Mathf.Min(this.m_DeadZoneWidth, this.m_SoftZoneWidth);
                    this.m_DeadZoneHeight = UnityEngine.Mathf.Min(this.m_DeadZoneHeight, this.m_SoftZoneHeight);

                    var center = value.center.$clone();
                    var bias = center.$clone().sub( new pc.Vec2( this.m_ScreenX, this.m_ScreenY ) );
                    var biasWidth = UnityEngine.Mathf.Max(0, this.m_SoftZoneWidth - this.m_DeadZoneWidth);
                    var biasHeight = UnityEngine.Mathf.Max(0, this.m_SoftZoneHeight - this.m_DeadZoneHeight);
                    this.m_BiasX = biasWidth < Cinemachine.CinemachineComponentBase.Epsilon ? 0 : Math.max(-0.5, Math.min(bias.x / biasWidth, 0.5));
                    this.m_BiasY = biasHeight < Cinemachine.CinemachineComponentBase.Epsilon ? 0 : Math.max(-0.5, Math.min(bias.y / biasHeight, 0.5));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#init", this ); }

                this.m_CameraOrientationPrevFrame = new UnityEngine.Quaternion();
                this.m_CameraPosPrevFrame = new UnityEngine.Vector3();
                this.m_LookAtPrevFrame = new UnityEngine.Vector3();
                this.m_ScreenOffsetPrevFrame = new UnityEngine.Vector2();
                this.m_TrackedObjectOffset = new UnityEngine.Vector3();
                this.mCache = new Cinemachine.CinemachineComposer.FovCache();
                this.TrackedPoint = new UnityEngine.Vector3();
                this.m_CameraOrientationPrevFrame = pc.Quat.IDENTITY.clone();
                this.m_CameraPosPrevFrame = pc.Vec3.ZERO.clone();
                this.m_CenterOnActivate = true;
                this.m_HorizontalDamping = 0.5;
                this.m_LookaheadSmoothing = 10;
                this.m_LookaheadTime = 0;
                this.m_LookAtPrevFrame = pc.Vec3.ZERO.clone();
                this.m_Predictor = new Cinemachine.Utility.PositionPredictor();
                this.m_ScreenOffsetPrevFrame = pc.Vec2.ZERO.clone();
                this.m_ScreenX = 0.5;
                this.m_ScreenY = 0.5;
                this.m_SoftZoneHeight = 0.8;
                this.m_SoftZoneWidth = 0.8;
                this.m_TrackedObjectOffset = pc.Vec3.ZERO.clone();
                this.m_VerticalDamping = 0.5;
            }
        },
        methods: {
            /*Cinemachine.CinemachineComposer.GetLookAtPointAndSetTrackedPoint start.*/
            /**
             * Apply the target offsets to the target location.
                 Also set the TrackedPoint property, taking lookahead into account.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineComposer
             * @memberof Cinemachine.CinemachineComposer
             * @param   {UnityEngine.Vector3}    lookAt       The unoffset LookAt point
             * @param   {UnityEngine.Vector3}    up           
             * @param   {number}                 deltaTime
             * @return  {UnityEngine.Vector3}                 The LookAt point with the offset applied
             */
            GetLookAtPointAndSetTrackedPoint: function (lookAt, up, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#GetLookAtPointAndSetTrackedPoint", this ); }

                var pos = lookAt.$clone();
                if (UnityEngine.Component.op_Inequality(this.LookAtTarget, null)) {
                    pos = pos.$clone().add( this.LookAtTargetRotation.transformVector( this.m_TrackedObjectOffset ) );
                }

                if (this.m_LookaheadTime < Cinemachine.CinemachineComponentBase.Epsilon) {
                    this.TrackedPoint = pos.$clone();
                } else {
                    this.m_Predictor.Smoothing = this.m_LookaheadSmoothing;
                    this.m_Predictor.AddPosition(pos.$clone(), this.VirtualCamera.PreviousStateIsValid ? deltaTime : -1, this.m_LookaheadTime);
                    var delta = this.m_Predictor.PredictPositionDelta(this.m_LookaheadTime);
                    if (this.m_LookaheadIgnoreY) {
                        delta = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(delta, up.$clone());
                    }

                    this.TrackedPoint = pos.$clone().add( delta );
                }

                return pos.$clone();
            },
            /*Cinemachine.CinemachineComposer.GetLookAtPointAndSetTrackedPoint end.*/

            /*Cinemachine.CinemachineComposer.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the us that a target got warped,
                 so that we can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineComposer
             * @memberof Cinemachine.CinemachineComposer
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#OnTargetObjectWarped", this ); }

                Cinemachine.CinemachineComponentBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
                if (UnityEngine.Component.op_Equality(target, this.LookAtTarget)) {
                    this.m_CameraPosPrevFrame = this.m_CameraPosPrevFrame.$clone().add( positionDelta.$clone() );
                    this.m_LookAtPrevFrame = this.m_LookAtPrevFrame.$clone().add( positionDelta.$clone() );
                    this.m_Predictor.ApplyTransformDelta(positionDelta.$clone());
                }
            },
            /*Cinemachine.CinemachineComposer.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineComposer.PrePipelineMutateCameraState start.*/
            PrePipelineMutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#PrePipelineMutateCameraState", this ); }

                if (this.IsValid && curState.v.HasLookAt) {
                    curState.v.ReferenceLookAt = this.GetLookAtPointAndSetTrackedPoint(curState.v.ReferenceLookAt.$clone(), curState.v.ReferenceUp.$clone(), deltaTime);
                }
            },
            /*Cinemachine.CinemachineComposer.PrePipelineMutateCameraState end.*/

            /*Cinemachine.CinemachineComposer.MutateCameraState start.*/
            /**
             * Applies the composer rules and orients the camera accordingly
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineComposer
             * @memberof Cinemachine.CinemachineComposer
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for calculating damping.  If less than
                 zero, then target will snap to the center of the dead zone.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#MutateCameraState", this ); }

                if (!this.IsValid || !curState.v.HasLookAt) {
                    return;
                }

                // Correct the tracked point in the event that it's behind the camera
                // while the real target is in front
                if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero((this.TrackedPoint.$clone().sub( curState.v.ReferenceLookAt )))) {
                    var mid = new pc.Vec3().lerp( curState.v.CorrectedPosition, curState.v.ReferenceLookAt, 0.5 );
                    var toLookAt = curState.v.ReferenceLookAt.$clone().sub( mid );
                    var toTracked = this.TrackedPoint.$clone().sub( mid );
                    if (toLookAt.dot( toTracked ) < 0) {
                        var t = pc.Vec3.distance( curState.v.ReferenceLookAt, mid ) / pc.Vec3.distance( curState.v.ReferenceLookAt, this.TrackedPoint );
                        this.TrackedPoint = new pc.Vec3().lerp( curState.v.ReferenceLookAt, this.TrackedPoint, t );
                    }
                }

                var targetDistance = (this.TrackedPoint.$clone().sub( curState.v.CorrectedPosition )).length();
                if (targetDistance < Cinemachine.CinemachineComponentBase.Epsilon) {
                    if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                        curState.v.RawOrientation = this.m_CameraOrientationPrevFrame.$clone();
                    }

                    return; // navel-gazing, get outa here
                }

                // Expensive FOV calculations
                this.mCache.UpdateCache(curState.v.Lens.$clone(), this.SoftGuideRect.$clone(), this.HardGuideRect.$clone(), targetDistance);

                var rigOrientation = { v : curState.v.RawOrientation.$clone() };
                if (deltaTime < 0 || !this.VirtualCamera.PreviousStateIsValid) {
                    // No damping, just snap to central bounds, skipping the soft zone
                    var rect = this.mCache.mFovSoftGuideRect.$clone();
                    if (this.m_CenterOnActivate) {
                        rect = new UnityEngine.Rect.$ctor3(rect.center.$clone(), pc.Vec2.ZERO.clone()); // Force to center
                    }

                    this.RotateToScreenBounds(curState, rect.$clone(), curState.v.ReferenceLookAt.$clone(), rigOrientation, this.mCache.mFov, this.mCache.mFovH, -1);
                } else {
                    // Start with previous frame's orientation (but with current up)
                    var dir = this.m_LookAtPrevFrame.$clone().sub( (this.m_CameraPosPrevFrame.$clone().add( curState.v.PositionDampingBypass )) );
                    if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(dir)) {
                        rigOrientation.v = new pc.Quat().setLookAt( this.m_CameraOrientationPrevFrame.transformVector( new pc.Vec3( 0, 0, 1 ) ), curState.v.ReferenceUp );
                    } else {
                        rigOrientation.v = new pc.Quat().setLookAt( dir, curState.v.ReferenceUp );
                        rigOrientation.v = Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation(rigOrientation.v, this.m_ScreenOffsetPrevFrame.$clone().scale( -1 ), curState.v.ReferenceUp.$clone());
                    }

                    // First force the previous rotation into the hard bounds, no damping,
                    // then Now move it through the soft zone, with damping
                    this.RotateToScreenBounds(curState, this.mCache.mFovHardGuideRect.$clone(), this.TrackedPoint.$clone(), rigOrientation, this.mCache.mFov, this.mCache.mFovH, -1);
                    this.RotateToScreenBounds(curState, this.mCache.mFovSoftGuideRect.$clone(), this.TrackedPoint.$clone(), rigOrientation, this.mCache.mFov, this.mCache.mFovH, deltaTime);
                }

                // If we have lookahead, make sure the real target is still in the frame
                if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero((this.TrackedPoint.$clone().sub( curState.v.ReferenceLookAt )))) {
                    this.RotateToScreenBounds(curState, this.mCache.mFovHardGuideRect.$clone(), curState.v.ReferenceLookAt.$clone(), rigOrientation, this.mCache.mFov, this.mCache.mFovH, -1);
                }

                this.m_CameraPosPrevFrame = curState.v.CorrectedPosition.$clone();
                this.m_LookAtPrevFrame = this.TrackedPoint.$clone();
                this.m_CameraOrientationPrevFrame = Cinemachine.Utility.UnityQuaternionExtensions.Normalized(rigOrientation.v);
                this.m_ScreenOffsetPrevFrame = Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget(this.m_CameraOrientationPrevFrame, this.m_LookAtPrevFrame.$clone().sub( curState.v.CorrectedPosition ), curState.v.ReferenceUp.$clone());

                curState.v.RawOrientation = this.m_CameraOrientationPrevFrame.$clone();
            },
            /*Cinemachine.CinemachineComposer.MutateCameraState end.*/

            /*Cinemachine.CinemachineComposer.RotateToScreenBounds start.*/
            /**
             * Adjust the rigOrientation to put the camera within the screen bounds.
                 If deltaTime &gt;= 0 then damping will be applied.
                 Assumes that currentOrientation fwd is such that input rigOrientation's
                 local up is NEVER NEVER NEVER pointing downwards, relative to
                 state.ReferenceUp.  If this condition is violated
                 then you will see crazy spinning.  That's the symptom.
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineComposer
             * @memberof Cinemachine.CinemachineComposer
             * @param   {Cinemachine.CameraState}    state             
             * @param   {UnityEngine.Rect}           screenRect        
             * @param   {UnityEngine.Vector3}        trackedPoint      
             * @param   {UnityEngine.Quaternion}     rigOrientation    
             * @param   {number}                     fov               
             * @param   {number}                     fovH              
             * @param   {number}                     deltaTime
             * @return  {void}
             */
            RotateToScreenBounds: function (state, screenRect, trackedPoint, rigOrientation, fov, fovH, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#RotateToScreenBounds", this ); }

                screenRect = {v:screenRect};
                var targetDir = trackedPoint.$clone().sub( state.v.CorrectedPosition );
                var rotToRect = Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget(rigOrientation.v, targetDir.$clone(), state.v.ReferenceUp.$clone());

                // Bring it to the edge of screenRect, if outside.  Leave it alone if inside.
                this.ClampVerticalBounds(screenRect, targetDir.$clone(), state.v.ReferenceUp.$clone(), fov);
                var min = (screenRect.v.yMin - 0.5) * fov;
                var max = (screenRect.v.yMax - 0.5) * fov;
                if (rotToRect.x < min) {
                    rotToRect.x -= min;
                } else if (rotToRect.x > max) {
                    rotToRect.x -= max;
                } else {
                    rotToRect.x = 0;
                }

                min = (screenRect.v.xMin - 0.5) * fovH;
                max = (screenRect.v.xMax - 0.5) * fovH;
                if (rotToRect.y < min) {
                    rotToRect.y -= min;
                } else if (rotToRect.y > max) {
                    rotToRect.y -= max;
                } else {
                    rotToRect.y = 0;
                }

                // Apply damping
                if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                    rotToRect.x = Cinemachine.Utility.Damper.Damp(rotToRect.x, this.m_VerticalDamping, deltaTime);
                    rotToRect.y = Cinemachine.Utility.Damper.Damp(rotToRect.y, this.m_HorizontalDamping, deltaTime);
                }

                // Rotate
                rigOrientation.v = Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation(rigOrientation.v, rotToRect.$clone(), state.v.ReferenceUp.$clone());
            },
            /*Cinemachine.CinemachineComposer.RotateToScreenBounds end.*/

            /*Cinemachine.CinemachineComposer.ClampVerticalBounds start.*/
            /**
             * Prevent upside-down camera situation.  This can happen if we have a high
                 camera pitch combined with composer settings that cause the camera to tilt
                 beyond the vertical in order to produce the desired framing.  We prevent this by
                 clamping the composer's vertical settings so that this situation can't happen.
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineComposer
             * @memberof Cinemachine.CinemachineComposer
             * @param   {UnityEngine.Rect}       r      
             * @param   {UnityEngine.Vector3}    dir    
             * @param   {UnityEngine.Vector3}    up     
             * @param   {number}                 fov
             * @return  {boolean}
             */
            ClampVerticalBounds: function (r, dir, up, fov) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineComposer#ClampVerticalBounds", this ); }

                var angle = Cinemachine.Utility.UnityVectorExtensions.Angle(dir.$clone(), up.$clone());
                var halfFov = fov / 2.0 + 1; // give it a little extra to accommodate precision errors
                if (angle < halfFov) {
                    // looking up
                    var maxY = 1.0 - (halfFov - angle) / fov;
                    if (r.v.yMax > maxY) {
                        r.v.yMin = UnityEngine.Mathf.Min(r.v.yMin, maxY);
                        r.v.yMax = UnityEngine.Mathf.Min(r.v.yMax, maxY);
                        return true;
                    }
                }

                if (angle > 180 - halfFov) {
                    // looking down
                    var minY = (angle - (180 - halfFov)) / fov;
                    if (minY > r.v.yMin) {
                        r.v.yMin = UnityEngine.Mathf.Max(r.v.yMin, minY);
                        r.v.yMax = UnityEngine.Mathf.Max(r.v.yMax, minY);
                        return true;
                    }
                }

                return false;
            },
            /*Cinemachine.CinemachineComposer.ClampVerticalBounds end.*/


        }
    });
    /*Cinemachine.CinemachineComposer end.*/

    /*Cinemachine.CinemachineConfiner start.*/
    /**
     * An add-on module for Cinemachine Virtual Camera that post-processes
         the final position of the virtual camera. It will confine the virtual
         camera's position to the volume specified in the Bounding Volume field.
     *
     * @public
     * @class Cinemachine.CinemachineConfiner
     * @augments Cinemachine.CinemachineExtension
     */
    Bridge.define("Cinemachine.CinemachineConfiner", {
        inherits: [Cinemachine.CinemachineExtension],
        fields: {
            /**
             * The confiner can operate using a 2D bounding shape or a 3D bounding volume
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineConfiner
             * @type number
             */
            m_ConfineMode: 0,
            /**
             * The volume within which the camera is to be contained.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineConfiner
             * @type UnityEngine.Collider
             */
            m_BoundingVolume: null,
            /**
             * The 2D shape within which the camera is to be contained.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineConfiner
             * @type UnityEngine.Collider2D
             */
            m_BoundingShape2D: null,
            /**
             * If camera is orthographic, screen edges will be confined to the volume.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineConfiner
             * @default true
             * @type boolean
             */
            m_ConfineScreenEdges: false,
            /**
             * How gradually to return the camera to the bounding volume if it goes beyond the borders
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineConfiner
             * @type number
             */
            m_Damping: 0,
            m_pathCache: null,
            m_pathTotalPointCount: 0
        },
        props: {
            /**
             * Check if the bounding volume is defined
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineConfiner
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#IsValid#get", this ); }

                    return this.m_ConfineMode === Cinemachine.CinemachineConfiner.Mode.Confine3D && UnityEngine.Component.op_Inequality(this.m_BoundingVolume, null) || this.m_ConfineMode === Cinemachine.CinemachineConfiner.Mode.Confine2D && UnityEngine.Component.op_Inequality(this.m_BoundingShape2D, null);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#init", this ); }

                this.m_ConfineScreenEdges = true;
            }
        },
        methods: {
            /*Cinemachine.CinemachineConfiner.CameraWasDisplaced start.*/
            /**
             * See whether the virtual camera has been moved by the confiner
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineConfiner
             * @memberof Cinemachine.CinemachineConfiner
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam    The virtual camera in question.  This might be different from the
                 virtual camera that owns the confiner, in the event that the camera has children
             * @return  {boolean}                                             True if the virtual camera has been repositioned
             */
            CameraWasDisplaced: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#CameraWasDisplaced", this ); }

                return this.GetExtraState(Cinemachine.CinemachineConfiner.VcamExtraState, vcam).confinerDisplacement > 0;
            },
            /*Cinemachine.CinemachineConfiner.CameraWasDisplaced end.*/

            /*Cinemachine.CinemachineConfiner.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#OnValidate", this ); }

                this.m_Damping = UnityEngine.Mathf.Max(0, this.m_Damping);
            },
            /*Cinemachine.CinemachineConfiner.OnValidate end.*/

            /*Cinemachine.CinemachineConfiner.PostPipelineStageCallback start.*/
            /**
             * Callback to to the camera confining
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineConfiner
             * @memberof Cinemachine.CinemachineConfiner
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam         
             * @param   {number}                                      stage        
             * @param   {Cinemachine.CameraState}                     state        
             * @param   {number}                                      deltaTime
             * @return  {void}
             */
            PostPipelineStageCallback: function (vcam, stage, state, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#PostPipelineStageCallback", this ); }

                if (this.IsValid) {
                    // Move the body before the Aim is calculated
                    if (stage === Cinemachine.CinemachineCore.Stage.Body) {
                        var displacement = new UnityEngine.Vector3();
                        if (this.m_ConfineScreenEdges && state.v.Lens.Orthographic) {
                            displacement = this.ConfineScreenEdges(vcam, state);
                        } else {
                            displacement = this.ConfinePoint(state.v.CorrectedPosition.$clone());
                        }

                        var extra = this.GetExtraState(Cinemachine.CinemachineConfiner.VcamExtraState, vcam);
                        if (this.m_Damping > 0 && deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                            var delta = displacement.$clone().sub( extra.m_previousDisplacement );
                            delta = Cinemachine.Utility.Damper.Damp$1(delta.$clone(), this.m_Damping, deltaTime);
                            displacement = extra.m_previousDisplacement.$clone().add( delta );
                        }

                        extra.m_previousDisplacement = displacement.$clone();
                        state.v.PositionCorrection = state.v.PositionCorrection.$clone().add( displacement.$clone() );
                        extra.confinerDisplacement = displacement.length();
                    }
                }
            },
            /*Cinemachine.CinemachineConfiner.PostPipelineStageCallback end.*/

            /*Cinemachine.CinemachineConfiner.InvalidatePathCache start.*/
            /**
             * Call this if the bounding shape's points change at runtime
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineConfiner
             * @memberof Cinemachine.CinemachineConfiner
             * @return  {void}
             */
            InvalidatePathCache: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#InvalidatePathCache", this ); }

                this.m_pathCache = null;
            },
            /*Cinemachine.CinemachineConfiner.InvalidatePathCache end.*/

            /*Cinemachine.CinemachineConfiner.ValidatePathCache start.*/
            ValidatePathCache: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#ValidatePathCache", this ); }

                var colliderType = UnityEngine.Component.op_Equality(this.m_BoundingShape2D, null) ? null : Bridge.getType(this.m_BoundingShape2D);
                if (Bridge.referenceEquals(colliderType, UnityEngine.PolygonCollider2D)) {
                    var poly = Bridge.as(this.m_BoundingShape2D, UnityEngine.PolygonCollider2D);
                    if (this.m_pathCache == null || this.m_pathCache.Count !== poly.pathCount || this.m_pathTotalPointCount !== poly.GetTotalPointCount()) {
                        this.m_pathCache = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(UnityEngine.Vector2))).ctor();
                        for (var i = 0; i < poly.pathCount; ++i) {
                            var path = poly.GetPath(i);
                            var dst = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                            for (var j = 0; j < path.length; ++j) {
                                dst.add(path[j].$clone());
                            }

                            this.m_pathCache.add(dst);
                        }

                        this.m_pathTotalPointCount = poly.GetTotalPointCount();
                    }

                    return true;
                }

                if (Bridge.referenceEquals(colliderType, UnityEngine.CompositeCollider2D)) {
                    var poly1 = Bridge.as(this.m_BoundingShape2D, UnityEngine.CompositeCollider2D);
                    if (this.m_pathCache == null || this.m_pathCache.Count !== poly1.pathCount || this.m_pathTotalPointCount !== poly1.pointCount) {
                        this.m_pathCache = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(UnityEngine.Vector2))).ctor();
                        var path1 = System.Array.init(poly1.pointCount, function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                        for (var i1 = 0; i1 < poly1.pathCount; ++i1) {
                            var numPoints = poly1.GetPath(i1, path1);
                            var dst1 = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                            for (var j1 = 0; j1 < numPoints; ++j1) {
                                dst1.add(path1[j1].$clone());
                            }

                            this.m_pathCache.add(dst1);
                        }

                        this.m_pathTotalPointCount = poly1.pointCount;
                    }

                    return true;
                }
                this.InvalidatePathCache();
                return false;
            },
            /*Cinemachine.CinemachineConfiner.ValidatePathCache end.*/

            /*Cinemachine.CinemachineConfiner.ConfinePoint start.*/
            ConfinePoint: function (camPos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#ConfinePoint", this ); }

                // 3D version
                if (this.m_ConfineMode === Cinemachine.CinemachineConfiner.Mode.Confine3D) {
                    return this.m_BoundingVolume.ClosestPoint(camPos).sub( camPos );
                }

                // 2D version
                var p = UnityEngine.Vector2.FromVector3(camPos.$clone());
                var closest = p.$clone();
                if (this.m_BoundingShape2D.OverlapPoint$1(camPos.$clone())) {
                    return pc.Vec3.ZERO.clone();
                }

                // Find the nearest point on the shape's boundary
                if (!this.ValidatePathCache()) {
                    return pc.Vec3.ZERO.clone();
                }

                var bestDistance = 3.40282347E+38;
                for (var i = 0; i < this.m_pathCache.Count; ++i) {
                    var numPoints = this.m_pathCache.getItem(i).Count;
                    if (numPoints > 0) {
                        var v0 = UnityEngine.Vector2.FromVector3(this.m_BoundingShape2D.transform.TransformPoint$1(UnityEngine.Vector3.FromVector2(this.m_pathCache.getItem(i).getItem(numPoints - 1))));
                        for (var j = 0; j < numPoints; ++j) {
                            var v = UnityEngine.Vector2.FromVector3(this.m_BoundingShape2D.transform.TransformPoint$1(UnityEngine.Vector3.FromVector2(this.m_pathCache.getItem(i).getItem(j))));
                            var c = new pc.Vec2().lerp( v0, v, Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment(p, v0.$clone(), v.$clone()) );
                            var d = p.$clone().sub( c ).lengthSq();
                            if (d < bestDistance) {
                                bestDistance = d;
                                closest = c.$clone();
                            }

                            v0 = v.$clone();
                        }
                    }
                }

                return UnityEngine.Vector3.FromVector2(closest.$clone().sub( p ));
            },
            /*Cinemachine.CinemachineConfiner.ConfinePoint end.*/

            /*Cinemachine.CinemachineConfiner.ConfineScreenEdges start.*/
            ConfineScreenEdges: function (vcam, state) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineConfiner#ConfineScreenEdges", this ); }

                var rot = state.v.CorrectedOrientation.clone().invert();
                var dy = state.v.Lens.OrthographicSize;
                var dx = dy * state.v.Lens.Aspect;
                var vx = rot.transformVector( pc.Vec3.RIGHT.clone() ).clone().scale( dx );
                var vy = rot.transformVector( pc.Vec3.UP.clone() ).clone().scale( dy );

                var displacement = pc.Vec3.ZERO.clone();
                var camPos = state.v.CorrectedPosition.$clone();
                var kMaxIter = 12;
                for (var i = 0; i < kMaxIter; ++i) {
                    var d = this.ConfinePoint(camPos.$clone().sub( vy ).sub( vx ));
                    if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(d)) {
                        d = this.ConfinePoint(camPos.$clone().sub( vy ).add( vx ));
                    }

                    if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(d)) {
                        d = this.ConfinePoint(camPos.$clone().add( vy ).sub( vx ));
                    }

                    if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(d)) {
                        d = this.ConfinePoint(camPos.$clone().add( vy ).add( vx ));
                    }

                    if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(d)) {
                        break;
                    }

                    displacement = displacement.$clone().add( d.$clone() );
                    camPos = camPos.$clone().add( d.$clone() );
                }

                return displacement.$clone();
            },
            /*Cinemachine.CinemachineConfiner.ConfineScreenEdges end.*/


        }
    });
    /*Cinemachine.CinemachineConfiner end.*/

    /*Cinemachine.SignalSourceAsset start.*/
    /**
     * This is an asset that defines a 6D signal that can be retrieved in a random-access fashion.
         This is used by the Cinemachine Impulse module.
     *
     * @abstract
     * @public
     * @class Cinemachine.SignalSourceAsset
     * @augments UnityEngine.ScriptableObject
     * @implements  Cinemachine.ISignalSource6D
     */
    Bridge.define("Cinemachine.SignalSourceAsset", {
        inherits: [UnityEngine.ScriptableObject,Cinemachine.ISignalSource6D]
    });
    /*Cinemachine.SignalSourceAsset end.*/

    /*Cinemachine.CinemachineFollowZoom start.*/
    /**
     * An add-on module for Cinemachine Virtual Camera that adjusts
         the FOV of the lens to keep the target object at a constant size on the screen,
         regardless of camera and target position.
     *
     * @public
     * @class Cinemachine.CinemachineFollowZoom
     * @augments Cinemachine.CinemachineExtension
     */
    Bridge.define("Cinemachine.CinemachineFollowZoom", {
        inherits: [Cinemachine.CinemachineExtension],
        fields: {
            /**
             * The shot width to maintain, in world units, at target distance.
                 FOV will be adusted as far as possible to maintain this width at the
                 target distance from the camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFollowZoom
             * @default 2.0
             * @type number
             */
            m_Width: 0,
            /**
             * Increase this value to soften the aggressiveness of the follow-zoom.
                 Small numbers are more responsive, larger numbers give a more heavy slowly responding camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFollowZoom
             * @default 1.0
             * @type number
             */
            m_Damping: 0,
            /**
             * Will not generate an FOV smaller than this.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFollowZoom
             * @default 3.0
             * @type number
             */
            m_MinFOV: 0,
            /**
             * Will not generate an FOV larget than this.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFollowZoom
             * @default 60.0
             * @type number
             */
            m_MaxFOV: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFollowZoom#init", this ); }

                this.m_Width = 2.0;
                this.m_Damping = 1.0;
                this.m_MinFOV = 3.0;
                this.m_MaxFOV = 60.0;
            }
        },
        methods: {
            /*Cinemachine.CinemachineFollowZoom.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFollowZoom#OnValidate", this ); }

                this.m_Width = UnityEngine.Mathf.Max(0, this.m_Width);
                this.m_MaxFOV = Math.max(1, Math.min(this.m_MaxFOV, 179));
                this.m_MinFOV = Math.max(1, Math.min(this.m_MinFOV, this.m_MaxFOV));
            },
            /*Cinemachine.CinemachineFollowZoom.OnValidate end.*/

            /*Cinemachine.CinemachineFollowZoom.PostPipelineStageCallback start.*/
            /**
             * Callback to preform the zoom adjustment
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineFollowZoom
             * @memberof Cinemachine.CinemachineFollowZoom
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam         
             * @param   {number}                                      stage        
             * @param   {Cinemachine.CameraState}                     state        
             * @param   {number}                                      deltaTime
             * @return  {void}
             */
            PostPipelineStageCallback: function (vcam, stage, state, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFollowZoom#PostPipelineStageCallback", this ); }

                var extra = this.GetExtraState(Cinemachine.CinemachineFollowZoom.VcamExtraState, vcam);
                if (deltaTime < 0 || !this.VirtualCamera.PreviousStateIsValid) {
                    extra.m_previousFrameZoom = state.v.Lens.FieldOfView;
                }

                // Set the zoom after the body has been positioned, but before the aim,
                // so that composer can compose using the updated fov.
                if (stage === Cinemachine.CinemachineCore.Stage.Body) {
                    // Try to reproduce the target width
                    var targetWidth = UnityEngine.Mathf.Max(this.m_Width, 0);
                    var fov = 179.0;
                    var d = pc.Vec3.distance( state.v.CorrectedPosition, state.v.ReferenceLookAt );
                    if (d > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        // Clamp targetWidth to FOV min/max
                        var minW = d * 2.0 * Math.tan(this.m_MinFOV * UnityEngine.Mathf.Deg2Rad / 2.0);
                        var maxW = d * 2.0 * Math.tan(this.m_MaxFOV * UnityEngine.Mathf.Deg2Rad / 2.0);
                        targetWidth = Math.max(minW, Math.min(targetWidth, maxW));

                        // Apply damping
                        if (deltaTime >= 0 && this.m_Damping > 0 && this.VirtualCamera.PreviousStateIsValid) {
                            var currentWidth = d * 2.0 * Math.tan(extra.m_previousFrameZoom * UnityEngine.Mathf.Deg2Rad / 2.0);
                            var delta = targetWidth - currentWidth;
                            delta = Cinemachine.Utility.Damper.Damp(delta, this.m_Damping, deltaTime);
                            targetWidth = currentWidth + delta;
                        }

                        fov = 2.0 * Math.atan(targetWidth / (2 * d)) * UnityEngine.Mathf.Rad2Deg;
                    }

                    var lens = state.v.Lens.$clone();
                    lens.FieldOfView = (extra.m_previousFrameZoom = Math.max(this.m_MinFOV, Math.min(fov, this.m_MaxFOV)));
                    state.v.Lens = lens.$clone();
                }
            },
            /*Cinemachine.CinemachineFollowZoom.PostPipelineStageCallback end.*/


        }
    });
    /*Cinemachine.CinemachineFollowZoom end.*/

    /*Cinemachine.CinemachineFramingTransposer start.*/
    /**
     * This is a Cinemachine Component in the Body section of the component pipeline.
         Its job is to position the camera in a fixed screen-space relationship to
         the vcam's Follow target object, with offsets and damping.
         The camera will be first moved along the camera Z axis until the Follow target
         is at the desired distance from the camera's X-Y plane.  The camera will then
         be moved in its XY plane until the Follow target is at the desired point on
         the camera's screen.
         The FramingTansposer will only change the camera's position in space.  It will not
         re-orient or otherwise aim the camera.
         For this component to work properly, the vcam's LookAt target must be null.
         The Follow target will define what the camera is looking at.
         If the Follow target is a ICinemachineTargetGroup, then additional controls will
         be available to dynamically adjust the camera's view in order to frame the entire group.
         Although this component was designed for orthographic cameras, it works equally
         well with persective cameras and can be used in 3D environments.
     *
     * @public
     * @class Cinemachine.CinemachineFramingTransposer
     * @augments Cinemachine.CinemachineComponentBase
     */
    Bridge.define("Cinemachine.CinemachineFramingTransposer", {
        inherits: [Cinemachine.CinemachineComponentBase],
        statics: {
            fields: {
                kMinimumCameraDistance: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#init", this ); }

                    this.kMinimumCameraDistance = 0.01;
                }
            },
            methods: {
                /*Cinemachine.CinemachineFramingTransposer.GetScreenSpaceGroupBoundingBox:static start.*/
                GetScreenSpaceGroupBoundingBox: function (group, pos, orientation) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#GetScreenSpaceGroupBoundingBox", this ); }

                    var $t, $t1;
                    var observer = new pc.Mat4().setTRS( pos.v, orientation, new pc.Vec3( 1, 1, 1 ) );
                    var minAngles = { v : new UnityEngine.Vector2() }, maxAngles = { v : new UnityEngine.Vector2() }, zRange = { v : new UnityEngine.Vector2() };
                    group.Cinemachine$ICinemachineTargetGroup$GetViewSpaceAngularBounds(observer.$clone(), minAngles, maxAngles, zRange);

                    var q = Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation(pc.Quat.IDENTITY.clone(), (minAngles.v.$clone().add( maxAngles.v )).scale( 1.0 / ( 2 ) ), pc.Vec3.UP.clone());
                    var localPosAdustment = q.transformVector( new pc.Vec3( 0, 0, (zRange.v.y + zRange.v.x) / 2 ) );
                    localPosAdustment.z = 0;
                    pos.v = observer.transformPoint( localPosAdustment );
                    observer = new pc.Mat4().setTRS( pos.v, orientation, new pc.Vec3( 1, 1, 1 ) );
                    group.Cinemachine$ICinemachineTargetGroup$GetViewSpaceAngularBounds(observer.$clone(), minAngles, maxAngles, zRange);

                    var zSize = zRange.v.y - zRange.v.x;
                    var z = zRange.v.x + zSize / 2;
                    var angles = new pc.Vec2( 89.5, 89.5 );
                    if (zRange.v.x > 0) {
                        angles = UnityEngine.Vector2.FromVector3(($t = Cinemachine.Utility.UnityVectorExtensions.Abs(UnityEngine.Vector3.FromVector2(minAngles.v.$clone())), new pc.Vec3( Math.max( UnityEngine.Vector3.FromVector2(maxAngles.v).x, $t.x ), Math.max( UnityEngine.Vector3.FromVector2(maxAngles.v).y, $t.y ), Math.max( UnityEngine.Vector3.FromVector2(maxAngles.v).z, $t.z ) )).clone().scale( UnityEngine.Mathf.Deg2Rad ));
                        angles = ($t1 = new pc.Vec2( 89.5, 89.5 ), new pc.Vec2( Math.min( angles.x, $t1.x ), Math.min( angles.y, $t1.y ) ));
                    }

                    return new pc.BoundingBox( new pc.Vec3( 0, 0, z ), new pc.Vec3( Math.tan(angles.y) * z * 2, Math.tan(angles.x) * z * 2, zSize ).scale( 0.5 ) );
                },
                /*Cinemachine.CinemachineFramingTransposer.GetScreenSpaceGroupBoundingBox:static end.*/


            }
        },
        fields: {
            /**
             * How to adjust the camera to get the desired framing
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type number
             */
            m_AdjustmentMode: 0,
            /**
             * A non-zero bias will move the targt position away from the center of the soft zone
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type number
             */
            m_BiasX: 0,
            /**
             * A non-zero bias will move the targt position away from the center of the soft zone
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type number
             */
            m_BiasY: 0,
            /**
             * The distance along the camera axis that will be maintained from the Follow target
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 10.0
             * @type number
             */
            m_CameraDistance: 0,
            /**
             * Force target to center of screen when this camera activates.
                 If false, will clamp target to the edges of the dead zone
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default true
             * @type boolean
             */
            m_CenterOnActivate: false,
            /**
             * The camera will not move along its z-axis if the Follow target is within
                 this distance of the specified camera distance
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type number
             */
            m_DeadZoneDepth: 0,
            /**
             * Camera will not move vertically if the target is within this range of the position
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type number
             */
            m_DeadZoneHeight: 0,
            /**
             * Camera will not move horizontally if the target is within this range of the position
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type number
             */
            m_DeadZoneWidth: 0,
            /**
             * What screen dimensions to consider when framing
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type number
             */
            m_GroupFramingMode: 0,
            /**
             * How much of the screen to fill with the bounding box of the targets.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 0.8
             * @type number
             */
            m_GroupFramingSize: 0,
            /**
             * If checked, movement along the Y axis will be ignored for lookahead calculations
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type boolean
             */
            m_LookaheadIgnoreY: false,
            /**
             * Controls the smoothness of the lookahead algorithm.  Larger values smooth out
                 jittery predictions and also increase prediction lag
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 10
             * @type number
             */
            m_LookaheadSmoothing: 0,
            /**
             * This setting will instruct the composer to adjust its target offset based
                 on the motion of the target.  The composer will look at a point where it estimates
                 the target will be this many seconds into the future.  Note that this setting is sensitive
                 to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.
                 If the camera jitters unacceptably when the target is in motion, turn down this setting,
                 or animate the target more smoothly.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 0
             * @type number
             */
            m_LookaheadTime: 0,
            /**
             * Offset from the Follow Target object (in target-local co-ordinates).  The camera will attempt to
             frame the point which is the target's position plus this offset.  Use it to correct for
             cases when the target's origin is not the point of interest for the camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type UnityEngine.Vector3
             */
            m_TrackedObjectOffset: null,
            /**
             * How much closer to the target can the camera go?
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 5000.0
             * @type number
             */
            m_MaxDollyIn: 0,
            /**
             * How much farther from the target can the camera go?
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 5000.0
             * @type number
             */
            m_MaxDollyOut: 0,
            /**
             * Set this to limit how far from the taregt the camera can get
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 5000.0
             * @type number
             */
            m_MaximumDistance: 0,
            /**
             * If adjusting FOV, will not set the FOV higher than this
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 60
             * @type number
             */
            m_MaximumFOV: 0,
            /**
             * If adjusting Orthographic Size, will not set it higher than this
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 5000
             * @type number
             */
            m_MaximumOrthoSize: 0,
            /**
             * Set this to limit how close to the target the camera can get
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 1
             * @type number
             */
            m_MinimumDistance: 0,
            /**
             * If adjusting FOV, will not set the FOV lower than this
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 3
             * @type number
             */
            m_MinimumFOV: 0,
            /**
             * If adjusting Orthographic Size, will not set it lower than this
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 1
             * @type number
             */
            m_MinimumOrthoSize: 0,
            m_Predictor: null,
            m_prevFOV: 0,
            /**
             * State information for damping
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @type UnityEngine.Vector3
             */
            m_PreviousCameraPosition: null,
            /**
             * Horizontal screen position for target. The camera will move to position the tracked object here
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 0.5
             * @type number
             */
            m_ScreenX: 0,
            /**
             * Vertical screen position for target, The camera will move to to position the tracked object here
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 0.5
             * @type number
             */
            m_ScreenY: 0,
            /**
             * When target is within this region, camera will gradually move to re-align
                 towards the desired position, depending onm the damping speed
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 0.8
             * @type number
             */
            m_SoftZoneHeight: 0,
            /**
             * When target is within this region, camera will gradually move to re-align
                 towards the desired position, depending onm the damping speed
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 0.8
             * @type number
             */
            m_SoftZoneWidth: 0,
            /**
             * If checked, then then soft zone will be unlimited in size
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default false
             * @type boolean
             */
            m_UnlimitedSoftZone: false,
            /**
             * How aggressively the camera tries to maintain the offset in the X-axis.
                 Small numbers are more responsive, rapidly translating the camera to keep the target's
                 x-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 1.0
             * @type number
             */
            m_XDamping: 0,
            /**
             * How aggressively the camera tries to maintain the offset in the Y-axis.
                 Small numbers are more responsive, rapidly translating the camera to keep the target's
                 y-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 1.0
             * @type number
             */
            m_YDamping: 0,
            /**
             * How aggressively the camera tries to maintain the offset in the Z-axis.
                 Small numbers are more responsive, rapidly translating the camera to keep the
                 target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @default 1.0
             * @type number
             */
            m_ZDamping: 0,
            /**
             * Internal API for inspector
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @function TrackedPoint
             * @type UnityEngine.Vector3
             */
            TrackedPoint: null,
            InheritingPosition: false,
            /**
             * For editor visulaization of the calculated bounding box of the group
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @function LastBounds
             * @type UnityEngine.Bounds
             */
            LastBounds: null,
            /**
             * For editor visualization of the calculated bounding box of the group
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @function LastBoundsMatrix
             * @type UnityEngine.Matrix4x4
             */
            LastBoundsMatrix: null
        },
        props: {
            /**
             * Internal API for the inspector editor
             *
             * @instance
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @function SoftGuideRect
             * @type UnityEngine.Rect
             */
            SoftGuideRect: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#SoftGuideRect#get", this ); }

                    return new UnityEngine.Rect.$ctor1(this.m_ScreenX - this.m_DeadZoneWidth / 2, this.m_ScreenY - this.m_DeadZoneHeight / 2, this.m_DeadZoneWidth, this.m_DeadZoneHeight);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#SoftGuideRect#set", this ); }

                    this.m_DeadZoneWidth = Math.max(0, Math.min(value.width, 2));
                    this.m_DeadZoneHeight = Math.max(0, Math.min(value.height, 2));
                    this.m_ScreenX = Math.max(-0.5, Math.min(value.x + this.m_DeadZoneWidth / 2, 1.5));
                    this.m_ScreenY = Math.max(-0.5, Math.min(value.y + this.m_DeadZoneHeight / 2, 1.5));
                    this.m_SoftZoneWidth = UnityEngine.Mathf.Max(this.m_SoftZoneWidth, this.m_DeadZoneWidth);
                    this.m_SoftZoneHeight = UnityEngine.Mathf.Max(this.m_SoftZoneHeight, this.m_DeadZoneHeight);
                }
            },
            /**
             * Internal API for the inspector editor
             *
             * @instance
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @function HardGuideRect
             * @type UnityEngine.Rect
             */
            HardGuideRect: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#HardGuideRect#get", this ); }

                    var r = new UnityEngine.Rect.$ctor1(this.m_ScreenX - this.m_SoftZoneWidth / 2, this.m_ScreenY - this.m_SoftZoneHeight / 2, this.m_SoftZoneWidth, this.m_SoftZoneHeight);
                    r.position = r.position.$clone().add( new pc.Vec2( this.m_BiasX * (this.m_SoftZoneWidth - this.m_DeadZoneWidth), this.m_BiasY * (this.m_SoftZoneHeight - this.m_DeadZoneHeight) ) );
                    return r.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#HardGuideRect#set", this ); }

                    this.m_SoftZoneWidth = Math.max(0, Math.min(value.width, 2.0));
                    this.m_SoftZoneHeight = Math.max(0, Math.min(value.height, 2.0));
                    this.m_DeadZoneWidth = UnityEngine.Mathf.Min(this.m_DeadZoneWidth, this.m_SoftZoneWidth);
                    this.m_DeadZoneHeight = UnityEngine.Mathf.Min(this.m_DeadZoneHeight, this.m_SoftZoneHeight);

                    var center = value.center.$clone();
                    var bias = center.$clone().sub( new pc.Vec2( this.m_ScreenX, this.m_ScreenY ) );
                    var biasWidth = UnityEngine.Mathf.Max(0, this.m_SoftZoneWidth - this.m_DeadZoneWidth);
                    var biasHeight = UnityEngine.Mathf.Max(0, this.m_SoftZoneHeight - this.m_DeadZoneHeight);
                    this.m_BiasX = biasWidth < Cinemachine.CinemachineComponentBase.Epsilon ? 0 : Math.max(-0.5, Math.min(bias.x / biasWidth, 0.5));
                    this.m_BiasY = biasHeight < Cinemachine.CinemachineComponentBase.Epsilon ? 0 : Math.max(-0.5, Math.min(bias.y / biasHeight, 0.5));
                }
            },
            /**
             * True if component is enabled and has a valid Follow target
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#IsValid#get", this ); }

                    return this.enabled && UnityEngine.Component.op_Inequality(this.FollowTarget, null);
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Body stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Body;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#init", this ); }

                this.m_TrackedObjectOffset = new UnityEngine.Vector3();
                this.m_PreviousCameraPosition = new UnityEngine.Vector3();
                this.TrackedPoint = new UnityEngine.Vector3();
                this.LastBounds = new UnityEngine.Bounds();
                this.LastBoundsMatrix = new UnityEngine.Matrix4x4();
                this.m_AdjustmentMode = Cinemachine.CinemachineFramingTransposer.AdjustmentMode.DollyThenZoom;
                this.m_CameraDistance = 10.0;
                this.m_CenterOnActivate = true;
                this.m_GroupFramingMode = Cinemachine.CinemachineFramingTransposer.FramingMode.HorizontalAndVertical;
                this.m_GroupFramingSize = 0.8;
                this.m_LookaheadSmoothing = 10;
                this.m_LookaheadTime = 0;
                this.m_TrackedObjectOffset = pc.Vec3.ZERO.clone();
                this.m_MaxDollyIn = 5000.0;
                this.m_MaxDollyOut = 5000.0;
                this.m_MaximumDistance = 5000.0;
                this.m_MaximumFOV = 60;
                this.m_MaximumOrthoSize = 5000;
                this.m_MinimumDistance = 1;
                this.m_MinimumFOV = 3;
                this.m_MinimumOrthoSize = 1;
                this.m_Predictor = new Cinemachine.Utility.PositionPredictor();
                this.m_PreviousCameraPosition = pc.Vec3.ZERO.clone();
                this.m_ScreenX = 0.5;
                this.m_ScreenY = 0.5;
                this.m_SoftZoneHeight = 0.8;
                this.m_SoftZoneWidth = 0.8;
                this.m_UnlimitedSoftZone = false;
                this.m_XDamping = 1.0;
                this.m_YDamping = 1.0;
                this.m_ZDamping = 1.0;
            }
        },
        methods: {
            /*Cinemachine.CinemachineFramingTransposer.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#OnValidate", this ); }

                this.m_CameraDistance = UnityEngine.Mathf.Max(this.m_CameraDistance, Cinemachine.CinemachineFramingTransposer.kMinimumCameraDistance);
                this.m_DeadZoneDepth = UnityEngine.Mathf.Max(this.m_DeadZoneDepth, 0);

                this.m_GroupFramingSize = UnityEngine.Mathf.Max(0.001, this.m_GroupFramingSize);
                this.m_MaxDollyIn = UnityEngine.Mathf.Max(0, this.m_MaxDollyIn);
                this.m_MaxDollyOut = UnityEngine.Mathf.Max(0, this.m_MaxDollyOut);
                this.m_MinimumDistance = UnityEngine.Mathf.Max(0, this.m_MinimumDistance);
                this.m_MaximumDistance = UnityEngine.Mathf.Max(this.m_MinimumDistance, this.m_MaximumDistance);
                this.m_MinimumFOV = UnityEngine.Mathf.Max(1, this.m_MinimumFOV);
                this.m_MaximumFOV = Math.max(this.m_MinimumFOV, Math.min(this.m_MaximumFOV, 179));
                this.m_MinimumOrthoSize = UnityEngine.Mathf.Max(0.01, this.m_MinimumOrthoSize);
                this.m_MaximumOrthoSize = UnityEngine.Mathf.Max(this.m_MinimumOrthoSize, this.m_MaximumOrthoSize);
            },
            /*Cinemachine.CinemachineFramingTransposer.OnValidate end.*/

            /*Cinemachine.CinemachineFramingTransposer.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the us that a target got warped,
                 so that we can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineFramingTransposer
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#OnTargetObjectWarped", this ); }

                Cinemachine.CinemachineComponentBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
                if (UnityEngine.Component.op_Equality(target, this.FollowTarget)) {
                    this.m_PreviousCameraPosition = this.m_PreviousCameraPosition.$clone().add( positionDelta.$clone() );
                    this.m_Predictor.ApplyTransformDelta(positionDelta.$clone());
                }
            },
            /*Cinemachine.CinemachineFramingTransposer.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineFramingTransposer.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
                 Base class implementation does nothing.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineFramingTransposer
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @param   {Cinemachine.ICinemachineCamera}                               fromCam             The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}                                          worldUp             Default world Up, set by the CinemachineBrain
             * @param   {number}                                                       deltaTime           Delta time for time-based effects (ignore if less than or equal to 0)
             * @param   {Cinemachine.CinemachineVirtualCameraBase.TransitionParams}    transitionParams
             * @return  {boolean}                                                                          True if the vcam should do an internal update as a result of this call
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime, transitionParams) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#OnTransitionFromCamera", this ); }

                if (fromCam != null && transitionParams.v.m_InheritPosition) {
                    this.transform.rotation = fromCam.Cinemachine$ICinemachineCamera$State.RawOrientation.$clone();
                    this.InheritingPosition = true;
                    return true;
                }

                return false;
            },
            /*Cinemachine.CinemachineFramingTransposer.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineFramingTransposer.ScreenToOrtho start.*/
            ScreenToOrtho: function (rScreen, orthoSize, aspect) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#ScreenToOrtho", this ); }

                var r = new UnityEngine.Rect.ctor();
                r.yMax = 2 * orthoSize * (1.0 - rScreen.yMin - 0.5);
                r.yMin = 2 * orthoSize * (1.0 - rScreen.yMax - 0.5);
                r.xMin = 2 * orthoSize * aspect * (rScreen.xMin - 0.5);
                r.xMax = 2 * orthoSize * aspect * (rScreen.xMax - 0.5);
                return r.$clone();
            },
            /*Cinemachine.CinemachineFramingTransposer.ScreenToOrtho end.*/

            /*Cinemachine.CinemachineFramingTransposer.OrthoOffsetToScreenBounds start.*/
            OrthoOffsetToScreenBounds: function (targetPos2D, screenRect) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#OrthoOffsetToScreenBounds", this ); }

                // Bring it to the edge of screenRect, if outside.  Leave it alone if inside.
                var delta = pc.Vec3.ZERO.clone();
                if (targetPos2D.x < screenRect.xMin) {
                    delta.x += targetPos2D.x - screenRect.xMin;
                }

                if (targetPos2D.x > screenRect.xMax) {
                    delta.x += targetPos2D.x - screenRect.xMax;
                }

                if (targetPos2D.y < screenRect.yMin) {
                    delta.y += targetPos2D.y - screenRect.yMin;
                }

                if (targetPos2D.y > screenRect.yMax) {
                    delta.y += targetPos2D.y - screenRect.yMax;
                }

                return delta.$clone();
            },
            /*Cinemachine.CinemachineFramingTransposer.OrthoOffsetToScreenBounds end.*/

            /*Cinemachine.CinemachineFramingTransposer.MutateCameraState start.*/
            /**
             * Positions the virtual camera according to the transposer rules.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineFramingTransposer
             * @memberof Cinemachine.CinemachineFramingTransposer
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for damping.  If less than 0, no damping is done.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#MutateCameraState", this ); }

                var lens = curState.v.Lens.$clone();
                var followTargetPosition = this.FollowTargetPosition.$clone().add( (this.FollowTargetRotation.transformVector( this.m_TrackedObjectOffset )) );
                if (deltaTime < 0 || !this.VirtualCamera.PreviousStateIsValid) {
                    this.m_Predictor.Reset();
                    this.m_PreviousCameraPosition = curState.v.RawPosition.$clone();
                    this.m_prevFOV = lens.Orthographic ? lens.OrthographicSize : lens.FieldOfView;
                    if (!this.InheritingPosition && this.m_CenterOnActivate) {
                        this.m_PreviousCameraPosition = this.FollowTargetPosition.$clone().add( curState.v.RawOrientation.transformVector( new pc.Vec3( 0, 0, -1 ) ).clone().scale( this.m_CameraDistance ) );
                    }
                }

                if (!this.IsValid) {
                    this.InheritingPosition = false;
                    return;
                }

                // Compute group bounds and adjust follow target for group framing
                var group = this.AbstractFollowTargetGroup;
                var isGroupFraming = group != null && this.m_GroupFramingMode !== Cinemachine.CinemachineFramingTransposer.FramingMode.None;
                if (isGroupFraming) {
                    followTargetPosition = this.ComputeGroupBounds(group, curState);
                }

                this.TrackedPoint = followTargetPosition.$clone();
                if (this.m_LookaheadTime > Cinemachine.CinemachineComponentBase.Epsilon) {
                    this.m_Predictor.Smoothing = this.m_LookaheadSmoothing;
                    this.m_Predictor.AddPosition(followTargetPosition.$clone(), deltaTime, this.m_LookaheadTime);
                    var delta = this.m_Predictor.PredictPositionDelta(this.m_LookaheadTime);
                    if (this.m_LookaheadIgnoreY) {
                        delta = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(delta, curState.v.ReferenceUp.$clone());
                    }

                    var p = followTargetPosition.$clone().add( delta );
                    if (isGroupFraming) {
                        var b = this.LastBounds;
                        b.center = b.center.$clone().add( p.$clone().sub( followTargetPosition ) );
                        this.LastBounds = b;
                    }

                    this.TrackedPoint = p.$clone();
                }

                if (!curState.v.HasLookAt) {
                    curState.v.ReferenceLookAt = followTargetPosition.$clone();
                }

                // Adjust the desired depth for group framing
                var targetDistance = this.m_CameraDistance;
                var isOrthographic = lens.Orthographic;
                var targetHeight = isGroupFraming ? this.GetTargetHeight(UnityEngine.Vector2.FromVector3(this.LastBounds.halfExtents.$clone().scale( 2 ).$clone().scale( 1.0 / ( this.m_GroupFramingSize ) ))) : 0;
                if (!isOrthographic && isGroupFraming) {
                    // Adjust height for perspective - we want the height at the near surface
                    var boundsDepth = this.LastBounds.halfExtents.z;
                    var z = this.LastBounds.center.z;
                    if (z > boundsDepth) {
                        targetHeight = pc.math.lerp(0, targetHeight, (z - boundsDepth) / z);
                    }

                    if (this.m_AdjustmentMode !== Cinemachine.CinemachineFramingTransposer.AdjustmentMode.ZoomOnly) {
                        // What distance from near edge would be needed to get the adjusted
                        // target height, at the current FOV
                        targetDistance = targetHeight / (2.0 * Math.tan(lens.FieldOfView * UnityEngine.Mathf.Deg2Rad / 2.0));

                        // Clamp to respect min/max distance settings to the near surface of the bounds
                        targetDistance = Math.max(this.m_MinimumDistance, Math.min(targetDistance, this.m_MaximumDistance));

                        // Clamp to respect min/max camera movement
                        var targetDelta = targetDistance - this.m_CameraDistance;
                        targetDelta = Math.max(-this.m_MaxDollyIn, Math.min(targetDelta, this.m_MaxDollyOut));
                        targetDistance = this.m_CameraDistance + targetDelta;
                    }
                }

                // Work in camera-local space
                var camPosWorld = this.m_PreviousCameraPosition.$clone();
                var localToWorld = curState.v.RawOrientation.$clone();
                var worldToLocal = localToWorld.clone().invert();
                var cameraPos = worldToLocal.transformVector( camPosWorld );
                var targetPos = worldToLocal.transformVector( this.TrackedPoint ).sub( cameraPos );
                var lookAtPos = targetPos.$clone();

                // Move along camera z
                var cameraOffset = pc.Vec3.ZERO.clone();
                var cameraMin = UnityEngine.Mathf.Max(Cinemachine.CinemachineFramingTransposer.kMinimumCameraDistance, targetDistance - this.m_DeadZoneDepth / 2);
                var cameraMax = UnityEngine.Mathf.Max(cameraMin, targetDistance + this.m_DeadZoneDepth / 2);
                var targetZ = UnityEngine.Mathf.Min(targetPos.z, lookAtPos.z);
                if (targetZ < cameraMin) {
                    cameraOffset.z = targetZ - cameraMin;
                }

                if (targetZ > cameraMax) {
                    cameraOffset.z = targetZ - cameraMax;
                }

                // Move along the XY plane
                var screenSize = lens.Orthographic ? lens.OrthographicSize : Math.tan(0.5 * lens.FieldOfView * UnityEngine.Mathf.Deg2Rad) * (targetZ - cameraOffset.z);
                var softGuideOrtho = this.ScreenToOrtho(this.SoftGuideRect.$clone(), screenSize, lens.Aspect);
                if (deltaTime < 0 || !this.VirtualCamera.PreviousStateIsValid) {
                    // No damping or hard bounds, just snap to central bounds, skipping the soft zone
                    var rect = softGuideOrtho.$clone();
                    if (this.m_CenterOnActivate && !this.InheritingPosition) {
                        rect = new UnityEngine.Rect.$ctor3(rect.center.$clone(), pc.Vec2.ZERO.clone()); // Force to center
                    }

                    cameraOffset = cameraOffset.$clone().add( this.OrthoOffsetToScreenBounds(targetPos.$clone(), rect.$clone()) );
                } else {
                    // Move it through the soft zone
                    cameraOffset = cameraOffset.$clone().add( this.OrthoOffsetToScreenBounds(targetPos.$clone(), softGuideOrtho.$clone()) );

                    // Find where it intersects the hard zone
                    var hard = pc.Vec3.ZERO.clone();
                    if (!this.m_UnlimitedSoftZone) {
                        var hardGuideOrtho = this.ScreenToOrtho(this.HardGuideRect.$clone(), screenSize, lens.Aspect);
                        hard = this.OrthoOffsetToScreenBounds(targetPos.$clone(), hardGuideOrtho.$clone());
                        var t = UnityEngine.Mathf.Max(hard.x / (cameraOffset.x + Cinemachine.CinemachineComponentBase.Epsilon), hard.y / (cameraOffset.y + Cinemachine.CinemachineComponentBase.Epsilon));
                        hard = cameraOffset.$clone().clone().scale( t );
                    }

                    // Apply damping, but only to the portion of the move that's inside the hard zone
                    cameraOffset = hard.$clone().add( Cinemachine.Utility.Damper.Damp$2(cameraOffset.$clone().sub( hard ), new pc.Vec3( this.m_XDamping, this.m_YDamping, this.m_ZDamping ), deltaTime) );

                    // If we have lookahead, make sure the real target is still in the frame
                    if (!this.m_UnlimitedSoftZone && !Cinemachine.Utility.UnityVectorExtensions.AlmostZero((this.TrackedPoint.$clone().sub( curState.v.ReferenceLookAt )))) {
                        var hardGuideOrtho1 = this.ScreenToOrtho(this.HardGuideRect.$clone(), screenSize, lens.Aspect);
                        cameraOffset = cameraOffset.$clone().add( this.OrthoOffsetToScreenBounds(lookAtPos.$clone().sub( cameraOffset ), hardGuideOrtho1.$clone()) );
                    }
                }

                curState.v.RawPosition = (this.m_PreviousCameraPosition = localToWorld.transformVector( (cameraPos.$clone().add( cameraOffset )) ));

                // Adjust lens for group framing
                if (isGroupFraming) {
                    if (isOrthographic) {
                        targetHeight = Math.max(this.m_MinimumOrthoSize, Math.min(targetHeight / 2, this.m_MaximumOrthoSize));

                        // Apply Damping
                        if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                            targetHeight = this.m_prevFOV + Cinemachine.Utility.Damper.Damp(targetHeight - this.m_prevFOV, this.m_ZDamping, deltaTime);
                        }

                        this.m_prevFOV = targetHeight;

                        lens.OrthographicSize = Math.max(this.m_MinimumOrthoSize, Math.min(targetHeight, this.m_MaximumOrthoSize));
                        curState.v.Lens = lens.$clone();
                    } else if (this.m_AdjustmentMode !== Cinemachine.CinemachineFramingTransposer.AdjustmentMode.DollyOnly) {
                        var localTarget = curState.v.RawOrientation.clone().invert().transformVector( (followTargetPosition.$clone().sub( curState.v.RawPosition )) );
                        var nearBoundsDistance = localTarget.z;
                        var targetFOV = 179;
                        if (nearBoundsDistance > Cinemachine.CinemachineComponentBase.Epsilon) {
                            targetFOV = 2.0 * Math.atan(targetHeight / (2 * nearBoundsDistance)) * UnityEngine.Mathf.Rad2Deg;
                        }

                        targetFOV = Math.max(this.m_MinimumFOV, Math.min(targetFOV, this.m_MaximumFOV));

                        // ApplyDamping
                        if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                            targetFOV = this.m_prevFOV + Cinemachine.Utility.Damper.Damp(targetFOV - this.m_prevFOV, this.m_ZDamping, deltaTime);
                        }

                        this.m_prevFOV = targetFOV;

                        lens.FieldOfView = targetFOV;
                        curState.v.Lens = lens.$clone();
                    }
                }

                this.InheritingPosition = false;
            },
            /*Cinemachine.CinemachineFramingTransposer.MutateCameraState end.*/

            /*Cinemachine.CinemachineFramingTransposer.GetTargetHeight start.*/
            GetTargetHeight: function (boundsSize) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#GetTargetHeight", this ); }

                switch (this.m_GroupFramingMode) {
                    case Cinemachine.CinemachineFramingTransposer.FramingMode.Horizontal: 
                        return boundsSize.x / this.VcamState.Lens.Aspect;
                    case Cinemachine.CinemachineFramingTransposer.FramingMode.Vertical: 
                        return boundsSize.y;
                    default: 
                    case Cinemachine.CinemachineFramingTransposer.FramingMode.HorizontalAndVertical: 
                        return UnityEngine.Mathf.Max(boundsSize.x / this.VcamState.Lens.Aspect, boundsSize.y);
                }
            },
            /*Cinemachine.CinemachineFramingTransposer.GetTargetHeight end.*/

            /*Cinemachine.CinemachineFramingTransposer.ComputeGroupBounds start.*/
            ComputeGroupBounds: function (group, curState) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFramingTransposer#ComputeGroupBounds", this ); }

                var cameraPos = { v : curState.v.RawPosition.$clone() };
                var fwd = curState.v.RawOrientation.transformVector( new pc.Vec3( 0, 0, 1 ) );

                // Get the bounding box from camera's direction in view space
                this.LastBoundsMatrix = new pc.Mat4().setTRS( cameraPos.v, curState.v.RawOrientation, new pc.Vec3( 1, 1, 1 ) );
                var b = group.Cinemachine$ICinemachineTargetGroup$GetViewSpaceBoundingBox(this.LastBoundsMatrix.$clone());
                var groupCenter = this.LastBoundsMatrix.transformPoint( b.center );
                var boundsDepth = b.halfExtents.z;
                if (!curState.v.Lens.Orthographic) {
                    // Parallax might change bounds - refine
                    var d = (curState.v.RawOrientation.clone().invert().transformVector( (groupCenter.$clone().sub( cameraPos.v )) )).z;
                    cameraPos.v = groupCenter.$clone().sub( fwd.$clone().clone().scale( (UnityEngine.Mathf.Max(d, boundsDepth) + boundsDepth) ) );

                    // Will adjust cameraPos
                    b = Cinemachine.CinemachineFramingTransposer.GetScreenSpaceGroupBoundingBox(group, cameraPos, curState.v.RawOrientation.$clone());
                    this.LastBoundsMatrix = new pc.Mat4().setTRS( cameraPos.v, curState.v.RawOrientation, new pc.Vec3( 1, 1, 1 ) );
                    groupCenter = this.LastBoundsMatrix.transformPoint( b.center );
                }

                this.LastBounds = b;
                return groupCenter.$clone().sub( fwd.$clone().clone().scale( boundsDepth ) );
            },
            /*Cinemachine.CinemachineFramingTransposer.ComputeGroupBounds end.*/


        }
    });
    /*Cinemachine.CinemachineFramingTransposer end.*/

    /*Cinemachine.CinemachineHardLockToTarget start.*/
    /**
     * This is a CinemachineComponent in the Aim section of the component pipeline.
         Its job is to place the camera on the Follow Target.
     *
     * @public
     * @class Cinemachine.CinemachineHardLockToTarget
     * @augments Cinemachine.CinemachineComponentBase
     */
    Bridge.define("Cinemachine.CinemachineHardLockToTarget", {
        inherits: [Cinemachine.CinemachineComponentBase],
        fields: {
            /**
             * How much time it takes for the position to catch up to the target's position
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineHardLockToTarget
             * @default 0
             * @type number
             */
            m_Damping: 0,
            m_PreviousTargetPosition: null
        },
        props: {
            /**
             * True if component is enabled and has a LookAt defined
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineHardLockToTarget
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineHardLockToTarget#IsValid#get", this ); }

                    return this.enabled && UnityEngine.Component.op_Inequality(this.FollowTarget, null);
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Aim stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineHardLockToTarget
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineHardLockToTarget#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Body;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineHardLockToTarget#init", this ); }

                this.m_PreviousTargetPosition = new UnityEngine.Vector3();
                this.m_Damping = 0;
            }
        },
        methods: {
            /*Cinemachine.CinemachineHardLockToTarget.MutateCameraState start.*/
            /**
             * Applies the composer rules and orients the camera accordingly
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineHardLockToTarget
             * @memberof Cinemachine.CinemachineHardLockToTarget
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for calculating damping.  If less than
                 zero, then target will snap to the center of the dead zone.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineHardLockToTarget#MutateCameraState", this ); }

                if (!this.IsValid) {
                    return;
                }

                var dampedPos = this.FollowTargetPosition.$clone();
                if (deltaTime >= 0) {
                    dampedPos = this.m_PreviousTargetPosition.$clone().add( Cinemachine.Utility.Damper.Damp$1(dampedPos.$clone().sub( this.m_PreviousTargetPosition ), this.m_Damping, deltaTime) );
                }

                this.m_PreviousTargetPosition = dampedPos.$clone();
                curState.v.RawPosition = dampedPos.$clone();
            },
            /*Cinemachine.CinemachineHardLockToTarget.MutateCameraState end.*/


        }
    });
    /*Cinemachine.CinemachineHardLockToTarget end.*/

    /*Cinemachine.CinemachineHardLookAt start.*/
    /**
     * This is a CinemachineComponent in the Aim section of the component pipeline.
         Its job is to aim the camera hard at the LookAt target.
     *
     * @public
     * @class Cinemachine.CinemachineHardLookAt
     * @augments Cinemachine.CinemachineComponentBase
     */
    Bridge.define("Cinemachine.CinemachineHardLookAt", {
        inherits: [Cinemachine.CinemachineComponentBase],
        props: {
            /**
             * True if component is enabled and has a LookAt defined
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineHardLookAt
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineHardLookAt#IsValid#get", this ); }

                    return this.enabled && UnityEngine.Component.op_Inequality(this.LookAtTarget, null);
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Aim stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineHardLookAt
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineHardLookAt#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Aim;
                }
            }
        },
        methods: {
            /*Cinemachine.CinemachineHardLookAt.MutateCameraState start.*/
            /**
             * Applies the composer rules and orients the camera accordingly
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineHardLookAt
             * @memberof Cinemachine.CinemachineHardLookAt
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for calculating damping.  If less than
                 zero, then target will snap to the center of the dead zone.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineHardLookAt#MutateCameraState", this ); }

                if (this.IsValid && curState.v.HasLookAt) {
                    var dir = curState.v.ReferenceLookAt.$clone().sub( curState.v.CorrectedPosition );
                    if (dir.length() > Cinemachine.CinemachineComponentBase.Epsilon) {
                        if (new pc.Vec3().cross( dir.clone().normalize(), curState.v.ReferenceUp ).length() < Cinemachine.CinemachineComponentBase.Epsilon) {
                            curState.v.RawOrientation = new pc.Quat().fromTo( new pc.Vec3( 0, 0, 1 ), dir );
                        } else {
                            curState.v.RawOrientation = new pc.Quat().setLookAt( dir, curState.v.ReferenceUp );
                        }
                    }
                }
            },
            /*Cinemachine.CinemachineHardLookAt.MutateCameraState end.*/


        }
    });
    /*Cinemachine.CinemachineHardLookAt end.*/

    /*Cinemachine.CinemachineImpulseDefinition+SignalSource start.*/
    Bridge.define("Cinemachine.CinemachineImpulseDefinition.SignalSource", {
        inherits: [Cinemachine.ISignalSource6D],
        $kind: "nested class",
        fields: {
            m_Def: null,
            m_StartTimeOffset: 0,
            m_Velocity: null
        },
        props: {
            SignalDuration: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseDefinition.SignalSource#SignalDuration#get", this ); }

                    return this.m_Def.m_RawSignal.SignalDuration;
                }
            }
        },
        alias: [
            "SignalDuration", "Cinemachine$ISignalSource6D$SignalDuration",
            "GetSignal", "Cinemachine$ISignalSource6D$GetSignal"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseDefinition.SignalSource#init", this ); }

                this.m_Velocity = new UnityEngine.Vector3();
            },
            ctor: function (def, velocity) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseDefinition.SignalSource#ctor", this ); }

                this.$initialize();
                this.m_Def = def;
                this.m_Velocity = velocity.$clone();
                if (this.m_Def.m_Randomize && this.m_Def.m_RawSignal.SignalDuration <= 0) {
                    this.m_StartTimeOffset = UnityEngine.Random.Range$1(-1000.0, 1000.0);
                }
            }
        },
        methods: {
            /*Cinemachine.CinemachineImpulseDefinition+SignalSource.GetSignal start.*/
            GetSignal: function (timeSinceSignalStart, pos, rot) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseDefinition.SignalSource#GetSignal", this ); }

                var time = this.m_StartTimeOffset + timeSinceSignalStart * this.m_Def.m_FrequencyGain;

                // Do we have to fit the signal into the envelope?
                var signalDuration = this.SignalDuration;
                if (signalDuration > 0) {
                    if (this.m_Def.m_RepeatMode === Cinemachine.CinemachineImpulseDefinition.RepeatMode.Loop) {
                        time %= signalDuration;
                    } else if (this.m_Def.m_TimeEnvelope.Duration > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        time *= this.m_Def.m_TimeEnvelope.Duration / signalDuration; // stretch
                    }
                }

                this.m_Def.m_RawSignal.GetSignal(time, pos, rot);
                var gain = this.m_Velocity.length();
                var dir = this.m_Velocity.clone().normalize().$clone();
                gain *= this.m_Def.m_AmplitudeGain;
                pos.v = pos.v.$clone().clone().scale( gain );
                pos.v = new pc.Quat().fromTo( pc.Vec3.DOWN.clone(), this.m_Velocity ).transformVector( pos.v );
                rot.v = new pc.Quat().slerpUnclamped( pc.Quat.IDENTITY.clone(), rot.v, gain );
            },
            /*Cinemachine.CinemachineImpulseDefinition+SignalSource.GetSignal end.*/


        }
    });
    /*Cinemachine.CinemachineImpulseDefinition+SignalSource end.*/

    /*Cinemachine.CinemachineImpulseListener start.*/
    /**
     * An extension for Cinemachine Virtual Camera which post-processes
         the final position of the virtual camera.  It listens for CinemachineImpulse
         signals on the specified channels, and moves the camera in response to them.
     *
     * @public
     * @class Cinemachine.CinemachineImpulseListener
     * @augments Cinemachine.CinemachineExtension
     */
    Bridge.define("Cinemachine.CinemachineImpulseListener", {
        inherits: [Cinemachine.CinemachineExtension],
        fields: {
            /**
             * Impulse events on channels not included in the mask will be ignored.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseListener
             * @default 1
             * @type number
             */
            m_ChannelMask: 0,
            /**
             * Gain to apply to the Impulse signal.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseListener
             * @default 1
             * @type number
             */
            m_Gain: 0,
            /**
             * Enable this to perform distance calculation in 2D (ignore Z).
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineImpulseListener
             * @default false
             * @type boolean
             */
            m_Use2DDistance: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseListener#init", this ); }

                this.m_ChannelMask = 1;
                this.m_Gain = 1;
                this.m_Use2DDistance = false;
            }
        },
        methods: {
            /*Cinemachine.CinemachineImpulseListener.PostPipelineStageCallback start.*/
            PostPipelineStageCallback: function (vcam, stage, state, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineImpulseListener#PostPipelineStageCallback", this ); }

                if (stage === Cinemachine.CinemachineCore.Stage.Aim) {
                    var impulsePos = { v : pc.Vec3.ZERO.clone() };
                    var impulseRot = { v : pc.Quat.IDENTITY.clone() };
                    if (Cinemachine.CinemachineImpulseManager.Instance.GetImpulseAt(state.v.FinalPosition.$clone(), this.m_Use2DDistance, this.m_ChannelMask, impulsePos, impulseRot)) {
                        state.v.PositionCorrection = state.v.PositionCorrection.$clone().add( impulsePos.v.$clone().clone().scale( -this.m_Gain ) );
                        impulseRot.v = new pc.Quat().slerpUnclamped( pc.Quat.IDENTITY.clone(), impulseRot.v, -this.m_Gain );
                        state.v.OrientationCorrection = state.v.OrientationCorrection.clone().mul( impulseRot.v );
                    }
                }
            },
            /*Cinemachine.CinemachineImpulseListener.PostPipelineStageCallback end.*/


        }
    });
    /*Cinemachine.CinemachineImpulseListener end.*/

    /*Cinemachine.CinemachineTransposer start.*/
    /**
     * This is a CinemachineComponent in the Body section of the component pipeline.
         Its job is to position the camera in a fixed relationship to the vcam's Follow
         target object, with offsets and damping.
         The Tansposer will only change the camera's position in space.  It will not
         re-orient or otherwise aim the camera.  To to that, you need to instruct
         the vcam in the Aim section of its pipeline.
     *
     * @public
     * @class Cinemachine.CinemachineTransposer
     * @augments Cinemachine.CinemachineComponentBase
     */
    Bridge.define("Cinemachine.CinemachineTransposer", {
        inherits: [Cinemachine.CinemachineComponentBase],
        fields: {
            /**
             * How aggressively the camera tries to track the target's orientation.
                 Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @default 0.0
             * @type number
             */
            m_AngularDamping: 0,
            /**
             * How to calculate the angular damping for the target orientation.
                 Use Quaternion if you expect the target to take on very steep pitches, which would
                 be subject to gimbal lock if Eulers are used.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @type number
             */
            m_AngularDampingMode: 0,
            /**
             * The coordinate space to use when interpreting the offset from the target
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @type number
             */
            m_BindingMode: 0,
            /**
             * The distance which the transposer will attempt to maintain from the transposer subject
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @type UnityEngine.Vector3
             */
            m_FollowOffset: null,
            /**
             * How aggressively the camera tries to track the target rotation's X angle.
                 Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @default 0
             * @type number
             */
            m_PitchDamping: 0,
            m_PreviousReferenceOrientation: null,
            m_previousTarget: null,
            /**
             * State information for damping
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineTransposer
             * @type UnityEngine.Vector3
             */
            m_PreviousTargetPosition: null,
            /**
             * How aggressively the camera tries to track the target rotation's Z angle.
                 Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @default 0.0
             * @type number
             */
            m_RollDamping: 0,
            m_targetOrientationOnAssign: null,
            /**
             * How aggressively the camera tries to maintain the offset in the X-axis.
                 Small numbers are more responsive, rapidly translating the camera to keep the target's
                 x-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @default 1.0
             * @type number
             */
            m_XDamping: 0,
            /**
             * How aggressively the camera tries to track the target rotation's Y angle.
                 Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @default 0
             * @type number
             */
            m_YawDamping: 0,
            /**
             * How aggressively the camera tries to maintain the offset in the Y-axis.
                 Small numbers are more responsive, rapidly translating the camera to keep the target's
                 y-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @default 1.0
             * @type number
             */
            m_YDamping: 0,
            /**
             * How aggressively the camera tries to maintain the offset in the Z-axis.
                 Small numbers are more responsive, rapidly translating the camera to keep the
                 target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @default 1.0
             * @type number
             */
            m_ZDamping: 0,
            /**
             * Hide the offset in int inspector.  Used by FreeLook.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTransposer
             * @function HideOffsetInInspector
             * @type boolean
             */
            HideOffsetInInspector: false
        },
        props: {
            /**
             * Get the target offset, with sanitization
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineTransposer
             * @function EffectiveOffset
             * @type UnityEngine.Vector3
             */
            EffectiveOffset: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#EffectiveOffset#get", this ); }

                    var offset = this.m_FollowOffset.$clone();
                    if (this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                        offset.x = 0;
                        offset.z = -Math.abs(offset.z);
                    }

                    return offset.$clone();
                }
            },
            /**
             * True if component is enabled and has a valid Follow target
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineTransposer
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#IsValid#get", this ); }

                    return this.enabled && UnityEngine.Component.op_Inequality(this.FollowTarget, null);
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Body stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineTransposer
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Body;
                }
            },
            /**
             * Damping speeds for each of the 3 axes of the offset from target
             *
             * @instance
             * @protected
             * @readonly
             * @memberof Cinemachine.CinemachineTransposer
             * @function Damping
             * @type UnityEngine.Vector3
             */
            Damping: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#Damping#get", this ); }

                    switch (this.m_BindingMode) {
                        case Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp: 
                            return new pc.Vec3( 0, this.m_YDamping, this.m_ZDamping );
                        default: 
                            return new pc.Vec3( this.m_XDamping, this.m_YDamping, this.m_ZDamping );
                    }
                }
            },
            /**
             * Damping speeds for each of the 3 axes of the target's rotation
             *
             * @instance
             * @protected
             * @readonly
             * @memberof Cinemachine.CinemachineTransposer
             * @function AngularDamping
             * @type UnityEngine.Vector3
             */
            AngularDamping: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#AngularDamping#get", this ); }

                    switch (this.m_BindingMode) {
                        case Cinemachine.CinemachineTransposer.BindingMode.LockToTargetNoRoll: 
                            return new pc.Vec3( this.m_PitchDamping, this.m_YawDamping, 0 );
                        case Cinemachine.CinemachineTransposer.BindingMode.LockToTargetWithWorldUp: 
                            return new pc.Vec3( 0, this.m_YawDamping, 0 );
                        case Cinemachine.CinemachineTransposer.BindingMode.LockToTargetOnAssign: 
                        case Cinemachine.CinemachineTransposer.BindingMode.WorldSpace: 
                        case Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp: 
                            return pc.Vec3.ZERO.clone();
                        default: 
                            return new pc.Vec3( this.m_PitchDamping, this.m_YawDamping, this.m_RollDamping );
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#init", this ); }

                this.m_FollowOffset = new UnityEngine.Vector3();
                this.m_PreviousReferenceOrientation = new UnityEngine.Quaternion();
                this.m_PreviousTargetPosition = new UnityEngine.Vector3();
                this.m_targetOrientationOnAssign = new UnityEngine.Quaternion();
                this.m_AngularDamping = 0.0;
                this.m_AngularDampingMode = Cinemachine.CinemachineTransposer.AngularDampingMode.Euler;
                this.m_BindingMode = Cinemachine.CinemachineTransposer.BindingMode.LockToTargetWithWorldUp;
                this.m_FollowOffset = new pc.Vec3( 0, 0, -1 ).clone().scale( 10.0 );
                this.m_PitchDamping = 0;
                this.m_PreviousReferenceOrientation = pc.Quat.IDENTITY.clone();
                this.m_PreviousTargetPosition = pc.Vec3.ZERO.clone();
                this.m_RollDamping = 0.0;
                this.m_targetOrientationOnAssign = pc.Quat.IDENTITY.clone();
                this.m_XDamping = 1.0;
                this.m_YawDamping = 0;
                this.m_YDamping = 1.0;
                this.m_ZDamping = 1.0;
            }
        },
        methods: {
            /*Cinemachine.CinemachineTransposer.OnValidate start.*/
            /**
             * Derived classes should call this from their OnValidate() implementation
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineTransposer
             * @memberof Cinemachine.CinemachineTransposer
             * @return  {void}
             */
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#OnValidate", this ); }

                this.m_FollowOffset = this.EffectiveOffset.$clone();
            },
            /*Cinemachine.CinemachineTransposer.OnValidate end.*/

            /*Cinemachine.CinemachineTransposer.MutateCameraState start.*/
            /**
             * Positions the virtual camera according to the transposer rules.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineTransposer
             * @memberof Cinemachine.CinemachineTransposer
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for damping.  If less than 0, no damping is done.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#MutateCameraState", this ); }

                this.InitPrevFrameStateInfo(curState, deltaTime);
                if (this.IsValid) {
                    var offset = this.EffectiveOffset.$clone();
                    var pos = { v : new UnityEngine.Vector3() };
                    var orient = { v : new UnityEngine.Quaternion() };
                    this.TrackTarget(deltaTime, curState.v.ReferenceUp.$clone(), offset.$clone(), pos, orient);
                    curState.v.RawPosition = pos.v.$clone().add( orient.v.transformVector( offset ) );
                    curState.v.ReferenceUp = orient.v.transformVector( pc.Vec3.UP.clone() );
                }
            },
            /*Cinemachine.CinemachineTransposer.MutateCameraState end.*/

            /*Cinemachine.CinemachineTransposer.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the us that a target got warped,
                 so that we can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineTransposer
             * @memberof Cinemachine.CinemachineTransposer
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#OnTargetObjectWarped", this ); }

                Cinemachine.CinemachineComponentBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
                if (UnityEngine.Component.op_Equality(target, this.FollowTarget)) {
                    this.m_PreviousTargetPosition = this.m_PreviousTargetPosition.$clone().add( positionDelta.$clone() );
                }
            },
            /*Cinemachine.CinemachineTransposer.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineTransposer.InitPrevFrameStateInfo start.*/
            /**
             * Initializes the state for previous frame if appropriate.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineTransposer
             * @memberof Cinemachine.CinemachineTransposer
             * @param   {Cinemachine.CameraState}    curState     
             * @param   {number}                     deltaTime
             * @return  {void}
             */
            InitPrevFrameStateInfo: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#InitPrevFrameStateInfo", this ); }

                var prevStateValid = deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid;
                if (UnityEngine.Component.op_Inequality(this.m_previousTarget, this.FollowTarget) || !prevStateValid) {
                    this.m_previousTarget = this.FollowTarget;
                    this.m_targetOrientationOnAssign = UnityEngine.Component.op_Equality(this.m_previousTarget, null) ? pc.Quat.IDENTITY.clone() : this.FollowTargetRotation.$clone();
                }

                if (!prevStateValid) {
                    this.m_PreviousTargetPosition = this.FollowTargetPosition.$clone();
                    this.m_PreviousReferenceOrientation = this.GetReferenceOrientation(curState.v.ReferenceUp.$clone());
                }
            },
            /*Cinemachine.CinemachineTransposer.InitPrevFrameStateInfo end.*/

            /*Cinemachine.CinemachineTransposer.TrackTarget start.*/
            /**
             * Positions the virtual camera according to the transposer rules.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineTransposer
             * @memberof Cinemachine.CinemachineTransposer
             * @param   {number}                    deltaTime              Used for damping.  If less than 0, no damping is done.
             * @param   {UnityEngine.Vector3}       up                     Current camera up
             * @param   {UnityEngine.Vector3}       desiredCameraOffset    Where we want to put the camera relative to the follow target
             * @param   {UnityEngine.Vector3}       outTargetPosition      Resulting camera position
             * @param   {UnityEngine.Quaternion}    outTargetOrient        Damped target orientation
             * @return  {void}
             */
            TrackTarget: function (deltaTime, up, desiredCameraOffset, outTargetPosition, outTargetOrient) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#TrackTarget", this ); }

                var targetOrientation = this.GetReferenceOrientation(up.$clone());
                var dampedOrientation = targetOrientation.$clone();
                if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                    if (this.m_AngularDampingMode === Cinemachine.CinemachineTransposer.AngularDampingMode.Quaternion && this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.LockToTarget) {
                        var t = Cinemachine.Utility.Damper.Damp(1, this.m_AngularDamping, deltaTime);
                        dampedOrientation = new pc.Quat().slerp( this.m_PreviousReferenceOrientation, targetOrientation, t );
                    } else {
                        var relative = (this.m_PreviousReferenceOrientation.clone().invert().clone().mul( targetOrientation )).getPositiveEulerAngles().$clone();
                        for (var i = 0; i < 3; ++i) {
                            if (relative.getitem(i) > 180) {
                                relative.setitem(i, relative.getitem(i) -360);
                            }
                        }

                        relative = Cinemachine.Utility.Damper.Damp$2(relative.$clone(), this.AngularDamping.$clone(), deltaTime);
                        dampedOrientation = this.m_PreviousReferenceOrientation.clone().mul( new pc.Quat().setFromEulerAngles_Unity( relative.x, relative.y, relative.z ) );
                    }
                }

                this.m_PreviousReferenceOrientation = dampedOrientation.$clone();

                var targetPosition = this.FollowTargetPosition.$clone();
                var currentPosition = this.m_PreviousTargetPosition.$clone();
                var worldOffset = targetPosition.$clone().sub( currentPosition );

                // Adjust for damping, which is done in camera-offset-local coords
                if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                    var dampingSpace = new UnityEngine.Quaternion();
                    if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(desiredCameraOffset)) {
                        dampingSpace = this.VcamState.RawOrientation.$clone();
                    } else {
                        dampingSpace = new pc.Quat().setLookAt( dampedOrientation.transformVector( desiredCameraOffset.clone().normalize() ), up );
                    }

                    var localOffset = dampingSpace.clone().invert().transformVector( worldOffset );
                    localOffset = Cinemachine.Utility.Damper.Damp$2(localOffset.$clone(), this.Damping.$clone(), deltaTime);
                    worldOffset = dampingSpace.transformVector( localOffset );
                }

                outTargetPosition.v = (this.m_PreviousTargetPosition = currentPosition.$clone().add( worldOffset ));
                outTargetOrient.v = dampedOrientation.$clone();
            },
            /*Cinemachine.CinemachineTransposer.TrackTarget end.*/

            /*Cinemachine.CinemachineTransposer.GetTargetCameraPosition start.*/
            /**
             * Internal API for the Inspector Editor, so it can draw a marker at the target
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTransposer
             * @memberof Cinemachine.CinemachineTransposer
             * @param   {UnityEngine.Vector3}    worldUp
             * @return  {UnityEngine.Vector3}
             */
            GetTargetCameraPosition: function (worldUp) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#GetTargetCameraPosition", this ); }

                if (!this.IsValid) {
                    return pc.Vec3.ZERO.clone();
                }

                return this.FollowTargetPosition.$clone().add( this.GetReferenceOrientation(worldUp.$clone()).transformVector( this.EffectiveOffset ) );
            },
            /*Cinemachine.CinemachineTransposer.GetTargetCameraPosition end.*/

            /*Cinemachine.CinemachineTransposer.GetReferenceOrientation start.*/
            /**
             * Internal API for the Inspector Editor, so it can draw a marker at the target
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTransposer
             * @memberof Cinemachine.CinemachineTransposer
             * @param   {UnityEngine.Vector3}       worldUp
             * @return  {UnityEngine.Quaternion}
             */
            GetReferenceOrientation: function (worldUp) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTransposer#GetReferenceOrientation", this ); }

                if (this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.WorldSpace) {
                    return pc.Quat.IDENTITY.clone();
                }

                if (UnityEngine.Component.op_Inequality(this.FollowTarget, null)) {
                    var targetOrientation = this.FollowTarget.rotation.$clone();
                    switch (this.m_BindingMode) {
                        case Cinemachine.CinemachineTransposer.BindingMode.LockToTargetOnAssign: 
                            return this.m_targetOrientationOnAssign.$clone();
                        case Cinemachine.CinemachineTransposer.BindingMode.LockToTargetWithWorldUp: 
                            {
                                var fwd = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane((targetOrientation.transformVector( new pc.Vec3( 0, 0, 1 ) )), worldUp.$clone());
                                if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(fwd)) {
                                    break;
                                }

                                return new pc.Quat().setLookAt( fwd, worldUp );
                            }
                        case Cinemachine.CinemachineTransposer.BindingMode.LockToTargetNoRoll: 
                            return new pc.Quat().setLookAt( targetOrientation.transformVector( new pc.Vec3( 0, 0, 1 ) ), worldUp );
                        case Cinemachine.CinemachineTransposer.BindingMode.LockToTarget: 
                            return targetOrientation.$clone();
                        case Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp: 
                            {
                                var fwd1 = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane((this.FollowTargetPosition.$clone().sub( this.VcamState.RawPosition )), worldUp.$clone());
                                if (Cinemachine.Utility.UnityVectorExtensions.AlmostZero(fwd1)) {
                                    break;
                                }

                                return new pc.Quat().setLookAt( fwd1, worldUp );
                            }
                    }
                }
                // Gimbal lock situation - use previous orientation if it exists
                return Cinemachine.Utility.UnityQuaternionExtensions.Normalized(this.m_PreviousReferenceOrientation);
            },
            /*Cinemachine.CinemachineTransposer.GetReferenceOrientation end.*/


        }
    });
    /*Cinemachine.CinemachineTransposer end.*/

    /*Cinemachine.CinemachinePath start.*/
    /**
     * Defines a world-space path, consisting of an array of waypoints,
         each of which has position, tangent, and roll settings.  Bezier interpolation
         is performed between the waypoints, to get a smooth and continuous path.
     *
     * @public
     * @class Cinemachine.CinemachinePath
     * @augments Cinemachine.CinemachinePathBase
     */
    Bridge.define("Cinemachine.CinemachinePath", {
        inherits: [Cinemachine.CinemachinePathBase],
        fields: {
            /**
             * If checked, then the path ends are joined to form a continuous loop
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePath
             * @type boolean
             */
            m_Looped: false,
            /**
             * The waypoints that define the path.
                 They will be interpolated using a bezier curve
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePath
             * @type Array.<Cinemachine.CinemachinePath.Waypoint>
             */
            m_Waypoints: null
        },
        props: {
            /**
             * The minimum value for the path position
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachinePath
             * @function MinPos
             * @type number
             */
            MinPos: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#MinPos#get", this ); }

                    return 0;
                }
            },
            /**
             * The maximum value for the path position
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachinePath
             * @function MaxPos
             * @type number
             */
            MaxPos: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#MaxPos#get", this ); }

                    var count = this.m_Waypoints.length - 1;
                    if (count < 1) {
                        return 0;
                    }

                    return this.m_Looped ? count + 1 : count;
                }
            },
            /**
             * True if the path ends are joined to form a continuous loop
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachinePath
             * @function Looped
             * @type boolean
             */
            Looped: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#Looped#get", this ); }

                    return this.m_Looped;
                }
            },
            /**
             * When calculating the distance cache, sample the path this many
                 times between points
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachinePath
             * @function DistanceCacheSampleStepsPerSegment
             * @type number
             */
            DistanceCacheSampleStepsPerSegment: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#DistanceCacheSampleStepsPerSegment#get", this ); }

                    return this.m_Resolution;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#init", this ); }

                this.m_Waypoints = System.Array.init(0, function (){
                    return new Cinemachine.CinemachinePath.Waypoint();
                }, Cinemachine.CinemachinePath.Waypoint);
            }
        },
        methods: {
            /*Cinemachine.CinemachinePath.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#Reset", this ); }

                var $t;
                this.m_Looped = false;
                this.m_Waypoints = System.Array.init([($t = new Cinemachine.CinemachinePath.Waypoint(), $t.position = new pc.Vec3( -3, 0, 0 ), $t.tangent = new pc.Vec3( 1, 0, 0 ), $t), ($t = new Cinemachine.CinemachinePath.Waypoint(), $t.position = new pc.Vec3( 3, 0, 0 ), $t.tangent = new pc.Vec3( 1, 0, 0 ), $t)], Cinemachine.CinemachinePath.Waypoint);
                this.m_Appearance = new Cinemachine.CinemachinePathBase.Appearance();
                this.InvalidateDistanceCache();
            },
            /*Cinemachine.CinemachinePath.Reset end.*/

            /*Cinemachine.CinemachinePath.GetBoundingIndices start.*/
            /**
             * Returns normalized position
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachinePath
             * @memberof Cinemachine.CinemachinePath
             * @param   {number}          pos       
             * @param   {System.Int32}    indexA    
             * @param   {System.Int32}    indexB
             * @return  {number}
             */
            GetBoundingIndices: function (pos, indexA, indexB) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#GetBoundingIndices", this ); }

                pos = this.StandardizePos(pos);
                var rounded = Math.round(pos);
                if (Math.abs(pos - rounded) < Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    indexA.v = (indexB.v = rounded === this.m_Waypoints.length ? 0 : rounded);
                } else {
                    indexA.v = Math.floor(pos);
                    if (indexA.v >= this.m_Waypoints.length) {
                        pos -= this.MaxPos;
                        indexA.v = 0;
                    }

                    indexB.v = Math.ceil(pos);
                    if (indexB.v >= this.m_Waypoints.length) {
                        indexB.v = 0;
                    }
                }

                return pos;
            },
            /*Cinemachine.CinemachinePath.GetBoundingIndices end.*/

            /*Cinemachine.CinemachinePath.EvaluatePosition start.*/
            /**
             * Get a worldspace position of a point along the path
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachinePath
             * @memberof Cinemachine.CinemachinePath
             * @param   {number}                 pos    Postion along the path.  Need not be normalized.
             * @return  {UnityEngine.Vector3}           World-space position of the point along at path at pos
             */
            EvaluatePosition: function (pos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#EvaluatePosition", this ); }

                var result = new pc.Vec3.ctor();
                if (this.m_Waypoints.length === 0) {
                    result = this.transform.position.$clone();
                } else {
                    var indexA = { }, indexB = { };
                    pos = this.GetBoundingIndices(pos, indexA, indexB);
                    if (indexA.v === indexB.v) {
                        result = this.m_Waypoints[indexA.v].position.$clone();
                    } else {
                        // interpolate
                        var wpA = this.m_Waypoints[indexA.v].$clone();
                        var wpB = this.m_Waypoints[indexB.v].$clone();
                        result = Cinemachine.Utility.SplineHelpers.Bezier3(pos - indexA.v, this.m_Waypoints[indexA.v].position.$clone(), wpA.position.$clone().add( wpA.tangent ), wpB.position.$clone().sub( wpB.tangent ), wpB.position.$clone());
                    }
                }

                return this.transform.TransformPoint$1(result);
            },
            /*Cinemachine.CinemachinePath.EvaluatePosition end.*/

            /*Cinemachine.CinemachinePath.EvaluateTangent start.*/
            /**
             * Get the tangent of the curve at a point along the path.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachinePath
             * @memberof Cinemachine.CinemachinePath
             * @param   {number}                 pos    Postion along the path.  Need not be normalized.
             * @return  {UnityEngine.Vector3}           World-space direction of the path tangent.
                 Length of the vector represents the tangent strength
             */
            EvaluateTangent: function (pos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#EvaluateTangent", this ); }

                var result = new pc.Vec3.ctor();
                if (this.m_Waypoints.length === 0) {
                    result = this.transform.rotation.transformVector( new pc.Vec3( 0, 0, 1 ) );
                } else {
                    var indexA = { }, indexB = { };
                    pos = this.GetBoundingIndices(pos, indexA, indexB);
                    if (indexA.v === indexB.v) {
                        result = this.m_Waypoints[indexA.v].tangent.$clone();
                    } else {
                        var wpA = this.m_Waypoints[indexA.v].$clone();
                        var wpB = this.m_Waypoints[indexB.v].$clone();
                        result = Cinemachine.Utility.SplineHelpers.BezierTangent3(pos - indexA.v, this.m_Waypoints[indexA.v].position.$clone(), wpA.position.$clone().add( wpA.tangent ), wpB.position.$clone().sub( wpB.tangent ), wpB.position.$clone());
                    }
                }

                return this.transform.TransformDirection(result.$clone());
            },
            /*Cinemachine.CinemachinePath.EvaluateTangent end.*/

            /*Cinemachine.CinemachinePath.EvaluateOrientation start.*/
            /**
             * Get the orientation the curve at a point along the path.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachinePath
             * @memberof Cinemachine.CinemachinePath
             * @param   {number}                    pos    Postion along the path.  Need not be normalized.
             * @return  {UnityEngine.Quaternion}           World-space orientation of the path, as defined by tangent, up, and roll.
             */
            EvaluateOrientation: function (pos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#EvaluateOrientation", this ); }

                var result = this.transform.rotation.$clone();
                if (this.m_Waypoints.length > 0) {
                    var roll = 0;
                    var indexA = { }, indexB = { };
                    pos = this.GetBoundingIndices(pos, indexA, indexB);
                    if (indexA.v === indexB.v) {
                        roll = this.m_Waypoints[indexA.v].roll;
                    } else {
                        var rollA = this.m_Waypoints[indexA.v].roll;
                        var rollB = this.m_Waypoints[indexB.v].roll;
                        if (indexB.v === 0) {
                            // Special handling at the wraparound - cancel the spins
                            rollA = rollA % 360;
                            rollB = rollB % 360;
                        }

                        roll = pc.math.lerp(rollA, rollB, pos - indexA.v);
                    }

                    var fwd = this.EvaluateTangent(pos);
                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(fwd)) {
                        var up = this.transform.rotation.transformVector( pc.Vec3.UP.clone() );
                        var q = new pc.Quat().setLookAt( fwd, up );
                        result = q.clone().mul( new pc.Quat().setFromAxisAngle( new pc.Vec3( 0, 0, 1 ), roll ) );
                    }
                }

                return result.$clone();
            },
            /*Cinemachine.CinemachinePath.EvaluateOrientation end.*/

            /*Cinemachine.CinemachinePath.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePath#OnValidate", this ); }

                this.InvalidateDistanceCache();
            },
            /*Cinemachine.CinemachinePath.OnValidate end.*/


        }
    });
    /*Cinemachine.CinemachinePath end.*/

    /*Cinemachine.CinemachinePOV start.*/
    /**
     * This is a CinemachineComponent in the Aim section of the component pipeline.
         Its job is to aim the camera in response to the user's mouse or joystick input.
         The composer does not change the camera's position.  It will only pan and tilt the
         camera where it is, in order to get the desired framing.  To move the camera, you have
         to use the virtual camera's Body section.
     *
     * @public
     * @class Cinemachine.CinemachinePOV
     * @augments Cinemachine.CinemachineComponentBase
     */
    Bridge.define("Cinemachine.CinemachinePOV", {
        inherits: [Cinemachine.CinemachineComponentBase],
        fields: {
            /**
             * Set this if the POV should be applied to the camera state before the body
                 position is calculated.  This is useful for body algorithms that use the rotation as input,
                 for example Framing Transposer
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePOV
             * @default false
             * @type boolean
             */
            m_ApplyBeforeBody: false,
            /**
             * The Horizontal axis.  Value is -180..180.  Controls the horizontal orientation
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePOV
             * @type Cinemachine.AxisState
             */
            m_HorizontalAxis: null,
            /**
             * Controls how automatic recentering of the Horizontal axis is accomplished
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePOV
             * @type Cinemachine.AxisState.Recentering
             */
            m_HorizontalRecentering: null,
            /**
             * Defines the recentering target: recentering goes here
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePOV
             * @type number
             */
            m_RecenterTarget: 0,
            /**
             * The Vertical axis.  Value is -90..90. Controls the vertical orientation
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePOV
             * @type Cinemachine.AxisState
             */
            m_VerticalAxis: null,
            /**
             * Controls how automatic recentering of the Vertical axis is accomplished
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachinePOV
             * @type Cinemachine.AxisState.Recentering
             */
            m_VerticalRecentering: null
        },
        props: {
            /**
             * True if component is enabled and has a LookAt defined
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachinePOV
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#IsValid#get", this ); }

                    return this.enabled;
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Aim stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachinePOV
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Aim;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#init", this ); }

                this.m_HorizontalAxis = new Cinemachine.AxisState();
                this.m_HorizontalRecentering = new Cinemachine.AxisState.Recentering();
                this.m_VerticalAxis = new Cinemachine.AxisState();
                this.m_VerticalRecentering = new Cinemachine.AxisState.Recentering();
                this.m_ApplyBeforeBody = false;
                this.m_HorizontalAxis = new Cinemachine.AxisState.$ctor1(-180, 180, true, false, 300.0, 0.1, 0.1, "Mouse X", false);
                this.m_HorizontalRecentering = new Cinemachine.AxisState.Recentering.$ctor1(false, 1, 2);
                this.m_RecenterTarget = Cinemachine.CinemachinePOV.RecenterTargetMode.None;
                this.m_VerticalAxis = new Cinemachine.AxisState.$ctor1(-70, 70, false, false, 300.0, 0.1, 0.1, "Mouse Y", true);
                this.m_VerticalRecentering = new Cinemachine.AxisState.Recentering.$ctor1(false, 1, 2);
            }
        },
        methods: {
            /*Cinemachine.CinemachinePOV.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#OnValidate", this ); }

                this.m_VerticalAxis.Validate();
                this.m_VerticalRecentering.Validate();
                this.m_HorizontalAxis.Validate();
                this.m_HorizontalRecentering.Validate();
            },
            /*Cinemachine.CinemachinePOV.OnValidate end.*/

            /*Cinemachine.CinemachinePOV.PrePipelineMutateCameraState start.*/
            PrePipelineMutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#PrePipelineMutateCameraState", this ); }

                if (this.m_ApplyBeforeBody) {
                    this.ApplyPOV(curState, deltaTime);
                }
            },
            /*Cinemachine.CinemachinePOV.PrePipelineMutateCameraState end.*/

            /*Cinemachine.CinemachinePOV.MutateCameraState start.*/
            /**
             * Applies the axis values and orients the camera accordingly
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachinePOV
             * @memberof Cinemachine.CinemachinePOV
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for calculating damping.  Not used.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#MutateCameraState", this ); }

                if (!this.m_ApplyBeforeBody) {
                    this.ApplyPOV(curState, deltaTime);
                }
            },
            /*Cinemachine.CinemachinePOV.MutateCameraState end.*/

            /*Cinemachine.CinemachinePOV.ApplyPOV start.*/
            /**
             * Applies the axis values and orients the camera accordingly
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachinePOV
             * @memberof Cinemachine.CinemachinePOV
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for calculating damping.  Not used.
             * @return  {void}
             */
            ApplyPOV: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#ApplyPOV", this ); }

                if (!this.IsValid) {
                    return;
                }

                // Only read joystick when game is playing
                if (deltaTime >= 0 && Cinemachine.CinemachineCore.Instance.IsLive(this.VirtualCamera)) {
                    if (this.m_HorizontalAxis.Update(deltaTime)) {
                        this.m_HorizontalRecentering.CancelRecentering();
                    }

                    if (this.m_VerticalAxis.Update(deltaTime)) {
                        this.m_VerticalRecentering.CancelRecentering();
                    }

                    var recenterTarget = this.GetRecenterTarget();
                    this.m_HorizontalRecentering.DoRecentering(Bridge.ref(this, "m_HorizontalAxis"), deltaTime, recenterTarget.x);
                    this.m_VerticalRecentering.DoRecentering(Bridge.ref(this, "m_VerticalAxis"), deltaTime, recenterTarget.y);
                }

                // If we have a transform parent, then apply POV in the local space of the parent
                var rot = new pc.Quat().setFromEulerAngles_Unity( this.m_VerticalAxis.Value, this.m_HorizontalAxis.Value, 0 );
                var parent = this.VirtualCamera.transform.parent;
                if (UnityEngine.Component.op_Inequality(parent, null)) {
                    rot = parent.rotation.clone().mul( rot );
                } else {
                    rot = rot.clone().mul( new pc.Quat().fromTo( pc.Vec3.UP.clone(), curState.v.ReferenceUp ) );
                }

                curState.v.RawOrientation = rot.$clone();
            },
            /*Cinemachine.CinemachinePOV.ApplyPOV end.*/

            /*Cinemachine.CinemachinePOV.GetRecenterTarget start.*/
            /**
             * Get the horizonmtal and vertical angles that correspong to "at rest" position.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachinePOV
             * @memberof Cinemachine.CinemachinePOV
             * @return  {UnityEngine.Vector2}        X is horizontal angle (rot Y) and Y is vertical angle (rot X)
             */
            GetRecenterTarget: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#GetRecenterTarget", this ); }

                var t = null;
                switch (this.m_RecenterTarget) {
                    case Cinemachine.CinemachinePOV.RecenterTargetMode.FollowTargetForward: 
                        t = this.VirtualCamera.Follow;
                        break;
                    case Cinemachine.CinemachinePOV.RecenterTargetMode.LookAtTargetForward: 
                        t = this.VirtualCamera.LookAt;
                        break;
                }

                if (UnityEngine.Component.op_Inequality(t, null)) {
                    var fwd = t.forward.$clone();
                    var parent = this.VirtualCamera.transform.parent;
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        fwd = parent.rotation.transformVector( fwd );
                    }

                    var v = new pc.Quat().fromTo( new pc.Vec3( 0, 0, 1 ), fwd ).getPositiveEulerAngles().$clone();
                    return new pc.Vec2( v.y, v.x );
                }

                return pc.Vec2.ZERO.clone();
            },
            /*Cinemachine.CinemachinePOV.GetRecenterTarget end.*/

            /*Cinemachine.CinemachinePOV.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
                 Base class implementation does nothing.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachinePOV
             * @memberof Cinemachine.CinemachinePOV
             * @param   {Cinemachine.ICinemachineCamera}                               fromCam             The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}                                          worldUp             Default world Up, set by the CinemachineBrain
             * @param   {number}                                                       deltaTime           Delta time for time-based effects (ignore if less than or equal to 0)
             * @param   {Cinemachine.CinemachineVirtualCameraBase.TransitionParams}    transitionParams
             * @return  {boolean}                                                                          True if the vcam should do an internal update as a result of this call
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime, transitionParams) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachinePOV#OnTransitionFromCamera", this ); }

                this.m_HorizontalRecentering.DoRecentering(Bridge.ref(this, "m_HorizontalAxis"), -1, 0);
                this.m_VerticalRecentering.DoRecentering(Bridge.ref(this, "m_VerticalAxis"), -1, 0);
                this.m_HorizontalRecentering.CancelRecentering();
                this.m_VerticalRecentering.CancelRecentering();
                if (fromCam != null && transitionParams.v.m_InheritPosition) {
                    var up = this.VcamState.ReferenceUp.$clone();
                    var targetRot = fromCam.Cinemachine$ICinemachineCamera$State.RawOrientation.$clone();
                    var fwd = new pc.Vec3( 0, 0, 1 );
                    var parent = this.VirtualCamera.transform.parent;
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        fwd = parent.rotation.transformVector( fwd );
                    }

                    this.m_HorizontalAxis.Value = 0;
                    this.m_HorizontalAxis.Reset();
                    var targetFwd = targetRot.transformVector( new pc.Vec3( 0, 0, 1 ) );
                    var a = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(fwd, up.$clone());
                    var b = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(targetFwd, up.$clone());
                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(a) && !Cinemachine.Utility.UnityVectorExtensions.AlmostZero(b)) {
                        this.m_HorizontalAxis.Value = pc.Vec3.signedAngle( a, b, up );
                    }

                    this.m_VerticalAxis.Value = 0;
                    this.m_VerticalAxis.Reset();
                    fwd = new pc.Quat().setFromAxisAngle( up, this.m_HorizontalAxis.Value ).transformVector( fwd );
                    var right = new pc.Vec3().cross( up, fwd );
                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(right)) {
                        this.m_VerticalAxis.Value = pc.Vec3.signedAngle( fwd, targetFwd, right );
                    }

                    return true;
                }

                return false;
            },
            /*Cinemachine.CinemachinePOV.OnTransitionFromCamera end.*/


        }
    });
    /*Cinemachine.CinemachinePOV end.*/

    /*Cinemachine.CinemachineSameAsFollowTarget start.*/
    /**
     * This is a CinemachineComponent in the Aim section of the component pipeline.
         Its job is to match the orientation of the Follow target.
     *
     * @public
     * @class Cinemachine.CinemachineSameAsFollowTarget
     * @augments Cinemachine.CinemachineComponentBase
     */
    Bridge.define("Cinemachine.CinemachineSameAsFollowTarget", {
        inherits: [Cinemachine.CinemachineComponentBase],
        fields: {
            /**
             * How much time it takes for the aim to catch up to the target's rotation
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineSameAsFollowTarget
             * @default 0
             * @type number
             */
            m_Damping: 0,
            m_PreviousReferenceOrientation: null
        },
        props: {
            /**
             * True if component is enabled and has a Follow target defined
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineSameAsFollowTarget
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSameAsFollowTarget#IsValid#get", this ); }

                    return this.enabled && UnityEngine.Component.op_Inequality(this.FollowTarget, null);
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Aim stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineSameAsFollowTarget
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSameAsFollowTarget#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Aim;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSameAsFollowTarget#init", this ); }

                this.m_PreviousReferenceOrientation = new UnityEngine.Quaternion();
                this.m_Damping = 0;
                this.m_PreviousReferenceOrientation = pc.Quat.IDENTITY.clone();
            }
        },
        methods: {
            /*Cinemachine.CinemachineSameAsFollowTarget.MutateCameraState start.*/
            /**
             * Orients the camera to match the Follow target's orientation
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineSameAsFollowTarget
             * @memberof Cinemachine.CinemachineSameAsFollowTarget
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Not used.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSameAsFollowTarget#MutateCameraState", this ); }

                if (!this.IsValid) {
                    return;
                }

                var dampedOrientation = this.FollowTargetRotation.$clone();
                if (deltaTime >= 0) {
                    var t = Cinemachine.Utility.Damper.Damp(1, this.m_Damping, deltaTime);
                    dampedOrientation = new pc.Quat().slerp( this.m_PreviousReferenceOrientation, this.FollowTargetRotation, t );
                }

                this.m_PreviousReferenceOrientation = dampedOrientation.$clone();
                curState.v.RawOrientation = dampedOrientation.$clone();
            },
            /*Cinemachine.CinemachineSameAsFollowTarget.MutateCameraState end.*/


        }
    });
    /*Cinemachine.CinemachineSameAsFollowTarget end.*/

    /*Cinemachine.CinemachineSmoothPath start.*/
    /**
     * Defines a world-space path, consisting of an array of waypoints,
         each of which has position and roll settings.  Bezier interpolation
         is performed between the waypoints, to get a smooth and continuous path.
         The path will pass through all waypoints, and (unlike CinemachinePath) first
         and second order continuity is guaranteed
     *
     * @public
     * @class Cinemachine.CinemachineSmoothPath
     * @augments Cinemachine.CinemachinePathBase
     */
    Bridge.define("Cinemachine.CinemachineSmoothPath", {
        inherits: [Cinemachine.CinemachinePathBase],
        fields: {
            m_ControlPoints1: null,
            m_ControlPoints2: null,
            m_IsLoopedCache: false,
            /**
             * If checked, then the path ends are joined to form a continuous loop
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineSmoothPath
             * @type boolean
             */
            m_Looped: false,
            /**
             * The waypoints that define the path.
                 They will be interpolated using a bezier curve
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineSmoothPath
             * @type Array.<Cinemachine.CinemachineSmoothPath.Waypoint>
             */
            m_Waypoints: null
        },
        props: {
            /**
             * The minimum value for the path position
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineSmoothPath
             * @function MinPos
             * @type number
             */
            MinPos: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#MinPos#get", this ); }

                    return 0;
                }
            },
            /**
             * The maximum value for the path position
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineSmoothPath
             * @function MaxPos
             * @type number
             */
            MaxPos: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#MaxPos#get", this ); }

                    var count = this.m_Waypoints.length - 1;
                    if (count < 1) {
                        return 0;
                    }

                    return this.m_Looped ? count + 1 : count;
                }
            },
            /**
             * True if the path ends are joined to form a continuous loop
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineSmoothPath
             * @function Looped
             * @type boolean
             */
            Looped: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#Looped#get", this ); }

                    return this.m_Looped;
                }
            },
            /**
             * When calculating the distance cache, sample the path this many
                 times between points
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineSmoothPath
             * @function DistanceCacheSampleStepsPerSegment
             * @type number
             */
            DistanceCacheSampleStepsPerSegment: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#DistanceCacheSampleStepsPerSegment#get", this ); }

                    return this.m_Resolution;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#init", this ); }

                this.m_Waypoints = System.Array.init(0, function (){
                    return new Cinemachine.CinemachineSmoothPath.Waypoint();
                }, Cinemachine.CinemachineSmoothPath.Waypoint);
            }
        },
        methods: {
            /*Cinemachine.CinemachineSmoothPath.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#OnValidate", this ); }

                this.InvalidateDistanceCache();
            },
            /*Cinemachine.CinemachineSmoothPath.OnValidate end.*/

            /*Cinemachine.CinemachineSmoothPath.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#Reset", this ); }

                var $t;
                this.m_Looped = false;
                this.m_Waypoints = System.Array.init([($t = new Cinemachine.CinemachineSmoothPath.Waypoint(), $t.position = new pc.Vec3( -3, 0, 0 ), $t), ($t = new Cinemachine.CinemachineSmoothPath.Waypoint(), $t.position = new pc.Vec3( 3, 0, 0 ), $t)], Cinemachine.CinemachineSmoothPath.Waypoint);
                this.m_Appearance = new Cinemachine.CinemachinePathBase.Appearance();
                this.InvalidateDistanceCache();
            },
            /*Cinemachine.CinemachineSmoothPath.Reset end.*/

            /*Cinemachine.CinemachineSmoothPath.InvalidateDistanceCache start.*/
            /**
             * Call this if the path changes in such a way as to affect distances
                 or other cached path elements
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineSmoothPath
             * @memberof Cinemachine.CinemachineSmoothPath
             * @return  {void}
             */
            InvalidateDistanceCache: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#InvalidateDistanceCache", this ); }

                Cinemachine.CinemachinePathBase.prototype.InvalidateDistanceCache.call(this);
                this.m_ControlPoints1 = null;
                this.m_ControlPoints2 = null;
            },
            /*Cinemachine.CinemachineSmoothPath.InvalidateDistanceCache end.*/

            /*Cinemachine.CinemachineSmoothPath.UpdateControlPoints start.*/
            UpdateControlPoints: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#UpdateControlPoints", this ); }

                var numPoints = this.m_Waypoints == null ? 0 : this.m_Waypoints.length;
                if (numPoints > 1 && (this.Looped !== this.m_IsLoopedCache || this.m_ControlPoints1 == null || this.m_ControlPoints1.length !== numPoints || this.m_ControlPoints2 == null || this.m_ControlPoints2.length !== numPoints)) {
                    var p1 = { v : System.Array.init(numPoints, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4) };
                    var p2 = { v : System.Array.init(numPoints, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4) };
                    var K = { v : System.Array.init(numPoints, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4) };
                    for (var i = 0; i < numPoints; ++i) {
                        K.v[i] = this.m_Waypoints[i].AsVector4.$clone();
                    }

                    if (this.Looped) {
                        Cinemachine.Utility.SplineHelpers.ComputeSmoothControlPointsLooped(K, p1, p2);
                    } else {
                        Cinemachine.Utility.SplineHelpers.ComputeSmoothControlPoints(K, p1, p2);
                    }

                    this.m_ControlPoints1 = System.Array.init(numPoints, function (){
                        return new Cinemachine.CinemachineSmoothPath.Waypoint();
                    }, Cinemachine.CinemachineSmoothPath.Waypoint);
                    this.m_ControlPoints2 = System.Array.init(numPoints, function (){
                        return new Cinemachine.CinemachineSmoothPath.Waypoint();
                    }, Cinemachine.CinemachineSmoothPath.Waypoint);
                    for (var i1 = 0; i1 < numPoints; ++i1) {
                        this.m_ControlPoints1[i1] = Cinemachine.CinemachineSmoothPath.Waypoint.FromVector4(p1.v[i1].$clone());
                        this.m_ControlPoints2[i1] = Cinemachine.CinemachineSmoothPath.Waypoint.FromVector4(p2.v[i1].$clone());
                    }

                    this.m_IsLoopedCache = this.Looped;
                }
            },
            /*Cinemachine.CinemachineSmoothPath.UpdateControlPoints end.*/

            /*Cinemachine.CinemachineSmoothPath.GetBoundingIndices start.*/
            /**
             * Returns standardized position
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineSmoothPath
             * @memberof Cinemachine.CinemachineSmoothPath
             * @param   {number}          pos       
             * @param   {System.Int32}    indexA    
             * @param   {System.Int32}    indexB
             * @return  {number}
             */
            GetBoundingIndices: function (pos, indexA, indexB) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#GetBoundingIndices", this ); }

                pos = this.StandardizePos(pos);
                var numWaypoints = this.m_Waypoints.length;
                if (numWaypoints < 2) {
                    indexA.v = (indexB.v = 0);
                } else {
                    indexA.v = Math.floor(pos);
                    if (indexA.v >= numWaypoints) {
                        // Only true if looped
                        pos -= this.MaxPos;
                        indexA.v = 0;
                    }

                    indexB.v = indexA.v + 1;
                    if (indexB.v === numWaypoints) {
                        if (this.Looped) {
                            indexB.v = 0;
                        } else {
                            --indexB.v;
                            --indexA.v;
                        }
                    }
                }

                return pos;
            },
            /*Cinemachine.CinemachineSmoothPath.GetBoundingIndices end.*/

            /*Cinemachine.CinemachineSmoothPath.EvaluatePosition start.*/
            /**
             * Get a worldspace position of a point along the path
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineSmoothPath
             * @memberof Cinemachine.CinemachineSmoothPath
             * @param   {number}                 pos    Postion along the path.  Need not be normalized.
             * @return  {UnityEngine.Vector3}           World-space position of the point along at path at pos
             */
            EvaluatePosition: function (pos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#EvaluatePosition", this ); }

                var result = pc.Vec3.ZERO.clone();
                if (this.m_Waypoints.length > 0) {
                    this.UpdateControlPoints();
                    var indexA = { }, indexB = { };
                    pos = this.GetBoundingIndices(pos, indexA, indexB);
                    if (indexA.v === indexB.v) {
                        result = this.m_Waypoints[indexA.v].position.$clone();
                    } else {
                        result = Cinemachine.Utility.SplineHelpers.Bezier3(pos - indexA.v, this.m_Waypoints[indexA.v].position.$clone(), this.m_ControlPoints1[indexA.v].position.$clone(), this.m_ControlPoints2[indexA.v].position.$clone(), this.m_Waypoints[indexB.v].position.$clone());
                    }
                }

                return this.transform.TransformPoint$1(result);
            },
            /*Cinemachine.CinemachineSmoothPath.EvaluatePosition end.*/

            /*Cinemachine.CinemachineSmoothPath.EvaluateTangent start.*/
            /**
             * Get the tangent of the curve at a point along the path.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineSmoothPath
             * @memberof Cinemachine.CinemachineSmoothPath
             * @param   {number}                 pos    Postion along the path.  Need not be normalized.
             * @return  {UnityEngine.Vector3}           World-space direction of the path tangent.
                 Length of the vector represents the tangent strength
             */
            EvaluateTangent: function (pos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#EvaluateTangent", this ); }

                var result = this.transform.rotation.transformVector( new pc.Vec3( 0, 0, 1 ) );
                if (this.m_Waypoints.length > 1) {
                    this.UpdateControlPoints();
                    var indexA = { }, indexB = { };
                    pos = this.GetBoundingIndices(pos, indexA, indexB);
                    if (!this.Looped && indexA.v === this.m_Waypoints.length - 1) {
                        --indexA.v;
                    }

                    result = Cinemachine.Utility.SplineHelpers.BezierTangent3(pos - indexA.v, this.m_Waypoints[indexA.v].position.$clone(), this.m_ControlPoints1[indexA.v].position.$clone(), this.m_ControlPoints2[indexA.v].position.$clone(), this.m_Waypoints[indexB.v].position.$clone());
                }

                return this.transform.TransformDirection(result.$clone());
            },
            /*Cinemachine.CinemachineSmoothPath.EvaluateTangent end.*/

            /*Cinemachine.CinemachineSmoothPath.EvaluateOrientation start.*/
            /**
             * Get the orientation the curve at a point along the path.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineSmoothPath
             * @memberof Cinemachine.CinemachineSmoothPath
             * @param   {number}                    pos    Postion along the path.  Need not be normalized.
             * @return  {UnityEngine.Quaternion}           World-space orientation of the path, as defined by tangent, up, and roll.
             */
            EvaluateOrientation: function (pos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineSmoothPath#EvaluateOrientation", this ); }

                var result = this.transform.rotation.$clone();
                if (this.m_Waypoints.length > 0) {
                    var roll = 0;
                    var indexA = { }, indexB = { };
                    pos = this.GetBoundingIndices(pos, indexA, indexB);
                    if (indexA.v === indexB.v) {
                        roll = this.m_Waypoints[indexA.v].roll;
                    } else {
                        this.UpdateControlPoints();
                        roll = Cinemachine.Utility.SplineHelpers.Bezier1(pos - indexA.v, this.m_Waypoints[indexA.v].roll, this.m_ControlPoints1[indexA.v].roll, this.m_ControlPoints2[indexA.v].roll, this.m_Waypoints[indexB.v].roll);
                    }

                    var fwd = this.EvaluateTangent(pos);
                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(fwd)) {
                        var up = this.transform.rotation.transformVector( pc.Vec3.UP.clone() );
                        var q = new pc.Quat().setLookAt( fwd, up );
                        result = q.clone().mul( new pc.Quat().setFromAxisAngle( new pc.Vec3( 0, 0, 1 ), roll ) );
                    }
                }

                return result.$clone();
            },
            /*Cinemachine.CinemachineSmoothPath.EvaluateOrientation end.*/


        }
    });
    /*Cinemachine.CinemachineSmoothPath end.*/

    /*Cinemachine.CinemachineStoryboard start.*/
    /**
     * An add-on module for Cinemachine Virtual Camera that places an image in screen space
         over the camera's output.
     *
     * @public
     * @class Cinemachine.CinemachineStoryboard
     * @augments Cinemachine.CinemachineExtension
     */
    Bridge.define("Cinemachine.CinemachineStoryboard", {
        inherits: [Cinemachine.CinemachineExtension],
        statics: {
            fields: {
                s_StoryboardGlobalMute: false
            },
            methods: {
                /*Cinemachine.CinemachineStoryboard.StaticBlendingHandler:static start.*/
                StaticBlendingHandler: function (brain) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#StaticBlendingHandler", this ); }

                    var state = brain.CurrentCameraState.$clone();
                    var numBlendables = state.NumCustomBlendables;
                    for (var i = 0; i < numBlendables; ++i) {
                        var b = state.GetCustomBlendable(i);
                        var src = Bridge.as(b.m_Custom, Cinemachine.CinemachineStoryboard);
                        if (!(UnityEngine.MonoBehaviour.op_Equality(src, null))) {
                            var showIt = true;
                            var layer = 1 << src.gameObject.layer;
                            if (UnityEngine.Component.op_Equality(brain.OutputCamera, null) || (brain.OutputCamera.cullingMask & layer) === 0) {
                                showIt = false;
                            }

                            if (Cinemachine.CinemachineStoryboard.s_StoryboardGlobalMute) {
                                showIt = false;
                            }

                            var ci = src.LocateMyCanvas(brain, showIt);
                            if (ci != null) {
                                src.PlaceImage(ci, b.m_Weight);
                            }
                        }
                    }
                },
                /*Cinemachine.CinemachineStoryboard.StaticBlendingHandler:static end.*/

                /*Cinemachine.CinemachineStoryboard.InitializeModule:static start.*/
                InitializeModule: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#InitializeModule", this ); }

                    Cinemachine.CinemachineCore.CameraUpdatedEvent.RemoveListener(Cinemachine.CinemachineStoryboard.StaticBlendingHandler);
                    Cinemachine.CinemachineCore.CameraUpdatedEvent.AddListener(Cinemachine.CinemachineStoryboard.StaticBlendingHandler);
                },
                /*Cinemachine.CinemachineStoryboard.InitializeModule:static end.*/


            }
        },
        fields: {
            m_ShowImage: false,
            m_Image: null,
            m_Aspect: 0,
            m_Alpha: 0,
            m_Center: null,
            m_Rotation: null,
            m_Scale: null,
            m_SyncScale: false,
            m_MuteCamera: false,
            m_SplitView: 0,
            mCanvasInfo: null
        },
        props: {
            CanvasName: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#CanvasName#get", this ); }

                    return "_CM_canvas" + this.gameObject.GetInstanceID();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#init", this ); }

                this.m_Center = new UnityEngine.Vector2();
                this.m_Rotation = new UnityEngine.Vector3();
                this.m_Scale = new UnityEngine.Vector2();
                this.m_ShowImage = true;
                this.m_Aspect = Cinemachine.CinemachineStoryboard.FillStrategy.BestFit;
                this.m_Alpha = 1;
                this.m_Center = pc.Vec2.ZERO.clone();
                this.m_Rotation = pc.Vec3.ZERO.clone();
                this.m_Scale = UnityEngine.Vector2.FromVector3(new pc.Vec3( 1, 1, 1 ));
                this.m_SyncScale = true;
                this.m_SplitView = 0.0;
                this.mCanvasInfo = new (System.Collections.Generic.List$1(Cinemachine.CinemachineStoryboard.CanvasInfo)).ctor();
            }
        },
        methods: {
            /*Cinemachine.CinemachineStoryboard.PostPipelineStageCallback start.*/
            /**
             * Standard CinemachineExtension callback
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineStoryboard
             * @memberof Cinemachine.CinemachineStoryboard
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam              
             * @param   {number}                                      stage             
             * @param   {Cinemachine.CameraState}                     state             
             * @param   {number}                                      wipeAmountTime
             * @return  {void}
             */
            PostPipelineStageCallback: function (vcam, stage, state, wipeAmountTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#PostPipelineStageCallback", this ); }

                // Apply to this vcam only, not the children
                if (UnityEngine.MonoBehaviour.op_Inequality(vcam, this.VirtualCamera) || stage !== Cinemachine.CinemachineCore.Stage.Finalize) {
                    return;
                }

                if (this.m_ShowImage) {
                    state.v.AddCustomBlendable(new Cinemachine.CameraState.CustomBlendable.$ctor1(this, 1));
                }

                if (this.m_MuteCamera) {
                    state.v.BlendHint |= 67;
                }
            },
            /*Cinemachine.CinemachineStoryboard.PostPipelineStageCallback end.*/

            /*Cinemachine.CinemachineStoryboard.ConnectToVcam start.*/
            ConnectToVcam: function (connect) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#ConnectToVcam", this ); }

                Cinemachine.CinemachineExtension.prototype.ConnectToVcam.call(this, connect);
                Cinemachine.CinemachineCore.CameraUpdatedEvent.RemoveListener(Bridge.fn.cacheBind(this, this.CameraUpdatedCallback));
                if (connect) {
                    Cinemachine.CinemachineCore.CameraUpdatedEvent.AddListener(Bridge.fn.cacheBind(this, this.CameraUpdatedCallback));
                } else {
                    this.DestroyCanvas();
                }
            },
            /*Cinemachine.CinemachineStoryboard.ConnectToVcam end.*/

            /*Cinemachine.CinemachineStoryboard.CameraUpdatedCallback start.*/
            CameraUpdatedCallback: function (brain) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#CameraUpdatedCallback", this ); }

                var showIt = this.enabled && this.m_ShowImage && Cinemachine.CinemachineCore.Instance.IsLive(this.VirtualCamera);
                var layer = 1 << this.gameObject.layer;
                if (UnityEngine.Component.op_Equality(brain.OutputCamera, null) || (brain.OutputCamera.cullingMask & layer) === 0) {
                    showIt = false;
                }

                if (Cinemachine.CinemachineStoryboard.s_StoryboardGlobalMute) {
                    showIt = false;
                }

                var ci = this.LocateMyCanvas(brain, showIt);
                if (ci != null && UnityEngine.GameObject.op_Inequality(ci.mCanvas, null)) {
                    ci.mCanvas.SetActive(showIt);
                }
            },
            /*Cinemachine.CinemachineStoryboard.CameraUpdatedCallback end.*/

            /*Cinemachine.CinemachineStoryboard.LocateMyCanvas start.*/
            LocateMyCanvas: function (parent, createIfNotFound) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#LocateMyCanvas", this ); }

                var $t;
                var ci = null;
                for (var i = 0; ci == null && i < this.mCanvasInfo.Count; ++i) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this.mCanvasInfo.getItem(i).mCanvasParent, parent)) {
                        ci = this.mCanvasInfo.getItem(i);
                    }
                }

                if (createIfNotFound) {
                    if (ci == null) {
                        ci = ($t = new Cinemachine.CinemachineStoryboard.CanvasInfo(), $t.mCanvasParent = parent, $t);
                        var numChildren = parent.transform.childCount;
                        for (var i1 = 0; UnityEngine.GameObject.op_Equality(ci.mCanvas, null) && i1 < numChildren; ++i1) {
                            var child = Bridge.as(parent.transform.GetChild(i1), UnityEngine.RectTransform);
                            if (UnityEngine.Component.op_Inequality(child, null) && Bridge.referenceEquals(child.name, this.CanvasName)) {
                                ci.mCanvas = child.gameObject;
                                ci.mViewport = ci.mCanvas.GetComponentInChildren(UnityEngine.RectTransform);
                                ci.mRawImage = ci.mCanvas.GetComponentInChildren(UnityEngine.UI.RawImage);
                            }
                        }

                        this.mCanvasInfo.add(ci);
                    }

                    if (UnityEngine.GameObject.op_Equality(ci.mCanvas, null) || UnityEngine.Component.op_Equality(ci.mViewport, null) || UnityEngine.MonoBehaviour.op_Equality(ci.mRawImage, null)) {
                        this.CreateCanvas(ci);
                    }
                }

                return ci;
            },
            /*Cinemachine.CinemachineStoryboard.LocateMyCanvas end.*/

            /*Cinemachine.CinemachineStoryboard.CreateCanvas start.*/
            CreateCanvas: function (ci) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#CreateCanvas", this ); }

                ci.mCanvas = new UnityEngine.GameObject.$ctor3(this.CanvasName, UnityEngine.RectTransform);
                ci.mCanvas.layer = this.gameObject.layer;
                ci.mCanvas.hideFlags = UnityEngine.HideFlags.HideAndDontSave;
                ci.mCanvas.transform.SetParent(ci.mCanvasParent.transform);

                var c = ci.mCanvas.AddComponent(UnityEngine.Canvas);
                c.renderMode = UnityEngine.RenderMode.ScreenSpaceOverlay;

                var go = new UnityEngine.GameObject.$ctor3("Viewport", UnityEngine.RectTransform);
                go.transform.SetParent(ci.mCanvas.transform);
                ci.mViewport = Bridge.cast(go.transform, UnityEngine.RectTransform);
                go.AddComponent(UnityEngine.UI.RectMask2D);

                go = new UnityEngine.GameObject.$ctor3("RawImage", UnityEngine.RectTransform);
                go.transform.SetParent(ci.mViewport.transform);
                ci.mRawImage = go.AddComponent(UnityEngine.UI.RawImage);
            },
            /*Cinemachine.CinemachineStoryboard.CreateCanvas end.*/

            /*Cinemachine.CinemachineStoryboard.DestroyCanvas start.*/
            DestroyCanvas: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#DestroyCanvas", this ); }

                var numBrains = Cinemachine.CinemachineCore.Instance.BrainCount;
                for (var i = 0; i < numBrains; ++i) {
                    var parent = Cinemachine.CinemachineCore.Instance.GetActiveBrain(i);
                    var numChildren = parent.transform.childCount;
                    for (var j = numChildren - 1; j >= 0; --j) {
                        var child = Bridge.as(parent.transform.GetChild(j), UnityEngine.RectTransform);
                        if (UnityEngine.Component.op_Inequality(child, null) && Bridge.referenceEquals(child.name, this.CanvasName)) {
                            var canvas = child.gameObject;
                            Cinemachine.RuntimeUtility.DestroyObject(canvas);
                        }
                    }
                }

                this.mCanvasInfo.clear();
            },
            /*Cinemachine.CinemachineStoryboard.DestroyCanvas end.*/

            /*Cinemachine.CinemachineStoryboard.PlaceImage start.*/
            PlaceImage: function (ci, alpha) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStoryboard#PlaceImage", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(ci.mRawImage, null) && UnityEngine.Component.op_Inequality(ci.mViewport, null)) {
                    var screen = new UnityEngine.Rect.$ctor1(0, 0, UnityEngine.Screen.width, UnityEngine.Screen.height);
                    if (UnityEngine.Component.op_Inequality(ci.mCanvasParent.OutputCamera, null)) {
                        screen = ci.mCanvasParent.OutputCamera.pixelRect.$clone();
                    }

                    screen.x -= UnityEngine.Screen.width / 2;
                    screen.y -= UnityEngine.Screen.height / 2;

                    // Apply Split View
                    var wipeAmount = -Math.max(-1, Math.min(this.m_SplitView, 1)) * screen.width;

                    var pos = UnityEngine.Vector3.FromVector2(screen.center.$clone());
                    pos.x -= wipeAmount / 2;
                    ci.mViewport.localPosition = pos.$clone();
                    ci.mViewport.localRotation = pc.Quat.IDENTITY.clone();
                    ci.mViewport.localScale = new pc.Vec3( 1, 1, 1 );
                    ci.mViewport.ForceUpdateRectTransforms();
                    ci.mViewport.sizeDelta = new pc.Vec2( screen.width - Math.abs(wipeAmount), screen.height );

                    var scale = pc.Vec2.ONE.clone();
                    if (this.m_Image != null && this.m_Image.width > 0 && this.m_Image.width > 0 && screen.width > 0 && screen.height > 0) {
                        var f = screen.height * this.m_Image.width / (screen.width * this.m_Image.height);
                        switch (this.m_Aspect) {
                            case Cinemachine.CinemachineStoryboard.FillStrategy.BestFit: 
                                if (f >= 1) {
                                    scale.y /= f;
                                } else {
                                    scale.x *= f;
                                }
                                break;
                            case Cinemachine.CinemachineStoryboard.FillStrategy.CropImageToFit: 
                                if (f >= 1) {
                                    scale.x *= f;
                                } else {
                                    scale.y /= f;
                                }
                                break;
                            case Cinemachine.CinemachineStoryboard.FillStrategy.StretchToFit: 
                                break;
                        }
                    }

                    scale.x *= this.m_Scale.x;
                    scale.y *= this.m_SyncScale ? this.m_Scale.x : this.m_Scale.y;

                    ci.mRawImage.texture = this.m_Image;
                    var tintColor = new pc.Color( 1, 1, 1, 1 );
                    tintColor.a = this.m_Alpha * alpha;
                    ci.mRawImage.color = tintColor.$clone();

                    pos = UnityEngine.Vector3.FromVector2(new pc.Vec2( screen.width * this.m_Center.x, screen.height * this.m_Center.y ));
                    pos.x += wipeAmount / 2;
                    ci.mRawImage.rectTransform.localPosition = pos.$clone();
                    ci.mRawImage.rectTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( this.m_Rotation.x, this.m_Rotation.y, this.m_Rotation.z );
                    ci.mRawImage.rectTransform.localScale = UnityEngine.Vector3.FromVector2(scale.$clone());
                    ci.mRawImage.rectTransform.ForceUpdateRectTransforms();
                    ci.mRawImage.rectTransform.sizeDelta = screen.size.$clone();
                }
            },
            /*Cinemachine.CinemachineStoryboard.PlaceImage end.*/


        }
    });
    /*Cinemachine.CinemachineStoryboard end.*/

    /*Cinemachine.CinemachineTargetGroup start.*/
    /**
     * Defines a group of target objects, each with a radius and a weight.
         The weight is used when calculating the average position of the target group.
         Higher-weighted members of the group will count more.
         The bounding box is calculated by taking the member positions, weight,
         and radii into account.
     *
     * @public
     * @class Cinemachine.CinemachineTargetGroup
     * @augments UnityEngine.MonoBehaviour
     * @implements  Cinemachine.ICinemachineTargetGroup
     */
    Bridge.define("Cinemachine.CinemachineTargetGroup", {
        inherits: [UnityEngine.MonoBehaviour,Cinemachine.ICinemachineTargetGroup],
        statics: {
            methods: {
                /*Cinemachine.CinemachineTargetGroup.WeightedMemberBounds:static start.*/
                WeightedMemberBounds: function (t, avgPos, maxWeight) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#WeightedMemberBounds", this ); }

                    var w = 0;
                    var pos = avgPos.$clone();
                    if (UnityEngine.Component.op_Inequality(t.target, null)) {
                        pos = t.target.position.$clone();
                        w = UnityEngine.Mathf.Max(0, t.weight);
                        if (maxWeight > Cinemachine.Utility.UnityVectorExtensions.Epsilon && w < maxWeight) {
                            w /= maxWeight;
                        } else {
                            w = 1;
                        }
                    }

                    return new UnityEngine.BoundingSphere.$ctor1(new pc.Vec3().lerp( avgPos, pos, w ), t.radius * w);
                },
                /*Cinemachine.CinemachineTargetGroup.WeightedMemberBounds:static end.*/


            }
        },
        fields: {
            /**
             * How the group's position is calculated
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTargetGroup
             * @type number
             */
            m_PositionMode: 0,
            /**
             * How the group's orientation is calculated
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTargetGroup
             * @type number
             */
            m_RotationMode: 0,
            /**
             * When to update the group's transform based on the position of the group members
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTargetGroup
             * @type number
             */
            m_UpdateMethod: 0,
            /**
             * The target objects, together with their weights and radii, that will
                 contribute to the group's average position, orientation, and size
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTargetGroup
             * @type Array.<Cinemachine.CinemachineTargetGroup.Target>
             */
            m_Targets: null,
            /**
             * The axis-aligned bounding box of the group, computed using the
                 targets positions and radii
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTargetGroup
             * @function BoundingBox
             * @type UnityEngine.Bounds
             */
            BoundingBox: null,
            mMaxWeight: 0,
            mAveragePos: null
        },
        props: {
            /**
             * Get the MonoBehaviour's Transform
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineTargetGroup
             * @function Transform
             * @type UnityEngine.Transform
             */
            Transform: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#Transform#get", this ); }

                    return this.transform;
                }
            },
            /**
             * The bounding sphere of the group, computed using the
                 targets positions and radii
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineTargetGroup
             * @function Sphere
             * @type UnityEngine.BoundingSphere
             */
            Sphere: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#Sphere#get", this ); }

                    var b = this.BoundingBox;
                    return new UnityEngine.BoundingSphere.$ctor1(b.center.$clone(), ((b.max.$clone().sub( b.min )).scale( 1.0 / ( 2 ) )).length());
                }
            },
            /**
             * Return true if there are no members with weight &gt; 0
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineTargetGroup
             * @function IsEmpty
             * @type boolean
             */
            IsEmpty: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#IsEmpty#get", this ); }

                    for (var i = 0; i < this.m_Targets.length; ++i) {
                        if (UnityEngine.Component.op_Inequality(this.m_Targets[i].target, null) && this.m_Targets[i].weight > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                            return false;
                        }
                    }

                    return true;
                }
            }
        },
        alias: [
            "Transform", "Cinemachine$ICinemachineTargetGroup$Transform",
            "BoundingBox", "Cinemachine$ICinemachineTargetGroup$BoundingBox",
            "Sphere", "Cinemachine$ICinemachineTargetGroup$Sphere",
            "IsEmpty", "Cinemachine$ICinemachineTargetGroup$IsEmpty",
            "GetViewSpaceBoundingBox", "Cinemachine$ICinemachineTargetGroup$GetViewSpaceBoundingBox",
            "GetViewSpaceAngularBounds", "Cinemachine$ICinemachineTargetGroup$GetViewSpaceAngularBounds"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#init", this ); }

                this.BoundingBox = new UnityEngine.Bounds();
                this.mAveragePos = new UnityEngine.Vector3();
                this.m_PositionMode = Cinemachine.CinemachineTargetGroup.PositionMode.GroupCenter;
                this.m_RotationMode = Cinemachine.CinemachineTargetGroup.RotationMode.Manual;
                this.m_UpdateMethod = Cinemachine.CinemachineTargetGroup.UpdateMethod.LateUpdate;
                this.m_Targets = System.Array.init(0, function (){
                    return new Cinemachine.CinemachineTargetGroup.Target();
                }, Cinemachine.CinemachineTargetGroup.Target);
            }
        },
        methods: {
            /*Cinemachine.CinemachineTargetGroup.AddMember start.*/
            /**
             * Add a member to the group
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTargetGroup
             * @memberof Cinemachine.CinemachineTargetGroup
             * @param   {UnityEngine.Transform}    t         
             * @param   {number}                   weight    
             * @param   {number}                   radius
             * @return  {void}
             */
            AddMember: function (t, weight, radius) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#AddMember", this ); }

                var index = 0;
                if (this.m_Targets == null) {
                    this.m_Targets = System.Array.init(1, function (){
                        return new Cinemachine.CinemachineTargetGroup.Target();
                    }, Cinemachine.CinemachineTargetGroup.Target);
                } else {
                    index = this.m_Targets.length;
                    var oldTargets = this.m_Targets;
                    this.m_Targets = System.Array.init(index + 1, function (){
                        return new Cinemachine.CinemachineTargetGroup.Target();
                    }, Cinemachine.CinemachineTargetGroup.Target);
                    System.Array.copy(oldTargets, 0, this.m_Targets, 0, index);
                }

                this.m_Targets[index].target = t;
                this.m_Targets[index].weight = weight;
                this.m_Targets[index].radius = radius;
            },
            /*Cinemachine.CinemachineTargetGroup.AddMember end.*/

            /*Cinemachine.CinemachineTargetGroup.RemoveMember start.*/
            /**
             * Remove a member from the group
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTargetGroup
             * @memberof Cinemachine.CinemachineTargetGroup
             * @param   {UnityEngine.Transform}    t
             * @return  {void}
             */
            RemoveMember: function (t) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#RemoveMember", this ); }

                var index = this.FindMember(t);
                if (index >= 0) {
                    var oldTargets = this.m_Targets;
                    this.m_Targets = System.Array.init(this.m_Targets.length - 1, function (){
                        return new Cinemachine.CinemachineTargetGroup.Target();
                    }, Cinemachine.CinemachineTargetGroup.Target);
                    if (index > 0) {
                        System.Array.copy(oldTargets, 0, this.m_Targets, 0, index);
                    }

                    if (index < oldTargets.length - 1) {
                        System.Array.copy(oldTargets, index + 1, this.m_Targets, index, oldTargets.length - index - 1);
                    }
                }
            },
            /*Cinemachine.CinemachineTargetGroup.RemoveMember end.*/

            /*Cinemachine.CinemachineTargetGroup.FindMember start.*/
            /**
             * Locate a member's index in the group. Returns -1 if not a member
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTargetGroup
             * @memberof Cinemachine.CinemachineTargetGroup
             * @param   {UnityEngine.Transform}    t
             * @return  {number}
             */
            FindMember: function (t) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#FindMember", this ); }

                if (this.m_Targets != null) {
                    for (var i = this.m_Targets.length - 1; i >= 0; --i) {
                        if (UnityEngine.Component.op_Equality(this.m_Targets[i].target, t)) {
                            return i;
                        }
                    }
                }

                return -1;
            },
            /*Cinemachine.CinemachineTargetGroup.FindMember end.*/

            /*Cinemachine.CinemachineTargetGroup.GetWeightedBoundsForMember start.*/
            /**
             * Get the bounding sphere of a group memebr, with the weight taken into account.
                 As the member's weight goes to 0, the position lerps to the group average position.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTargetGroup
             * @memberof Cinemachine.CinemachineTargetGroup
             * @param   {number}                        index    Member index
             * @return  {UnityEngine.BoundingSphere}
             */
            GetWeightedBoundsForMember: function (index) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#GetWeightedBoundsForMember", this ); }

                if (index < 0 || index >= this.m_Targets.length) {
                    return this.Sphere.$clone();
                }

                return Cinemachine.CinemachineTargetGroup.WeightedMemberBounds(this.m_Targets[index].$clone(), this.mAveragePos.$clone(), this.mMaxWeight);
            },
            /*Cinemachine.CinemachineTargetGroup.GetWeightedBoundsForMember end.*/

            /*Cinemachine.CinemachineTargetGroup.GetViewSpaceBoundingBox start.*/
            /**
             * The axis-aligned bounding box of the group, in a specific reference frame
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTargetGroup
             * @memberof Cinemachine.CinemachineTargetGroup
             * @param   {UnityEngine.Matrix4x4}    observer    The frame of reference in which to compute the bounding box
             * @return  {UnityEngine.Bounds}                   The axis-aligned bounding box of the group, in the desired frame of reference
             */
            GetViewSpaceBoundingBox: function (observer) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#GetViewSpaceBoundingBox", this ); }

                var inverseView = observer.clone().invert().$clone();
                var b = new pc.BoundingBox( inverseView.transformPoint( this.mAveragePos ), pc.Vec3.ZERO.clone().scale( 0.5 ) );
                for (var i = 0; i < this.m_Targets.length; ++i) {
                    var s = this.GetWeightedBoundsForMember(i);
                    s.position = inverseView.transformPoint( s.position );
                    b.add( new pc.BoundingBox( s.position.$clone(), new pc.Vec3( 1, 1, 1 ).clone().scale( s.radius * 2 ).scale( 0.5 ) ) );
                }

                return b;
            },
            /*Cinemachine.CinemachineTargetGroup.GetViewSpaceBoundingBox end.*/

            /*Cinemachine.CinemachineTargetGroup.DoUpdate start.*/
            /**
             * Update the group's transform right now, depending on the transforms of the members.
                 Normally this is called automatically by Update() or LateUpdate().
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTargetGroup
             * @memberof Cinemachine.CinemachineTargetGroup
             * @return  {void}
             */
            DoUpdate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#DoUpdate", this ); }

                if (this.IsEmpty) {
                    return;
                }

                this.mAveragePos = this.CalculateAveragePosition(Bridge.ref(this, "mMaxWeight"));
                this.BoundingBox = this.CalculateBoundingBox(this.mAveragePos.$clone(), this.mMaxWeight);

                switch (this.m_PositionMode) {
                    case Cinemachine.CinemachineTargetGroup.PositionMode.GroupCenter: 
                        this.transform.position = this.BoundingBox.center.$clone();
                        break;
                    case Cinemachine.CinemachineTargetGroup.PositionMode.GroupAverage: 
                        this.transform.position = this.mAveragePos.$clone();
                        break;
                }

                switch (this.m_RotationMode) {
                    case Cinemachine.CinemachineTargetGroup.RotationMode.Manual: 
                        break;
                    case Cinemachine.CinemachineTargetGroup.RotationMode.GroupAverage: 
                        this.transform.rotation = this.CalculateAverageOrientation();
                        break;
                }
            },
            /*Cinemachine.CinemachineTargetGroup.DoUpdate end.*/

            /*Cinemachine.CinemachineTargetGroup.CalculateAveragePosition start.*/
            CalculateAveragePosition: function (maxWeight) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#CalculateAveragePosition", this ); }

                var pos = pc.Vec3.ZERO.clone();
                var weight = 0;
                maxWeight.v = 0;
                for (var i = 0; i < this.m_Targets.length; ++i) {
                    if (UnityEngine.Component.op_Inequality(this.m_Targets[i].target, null)) {
                        weight += this.m_Targets[i].weight;
                        pos = pos.$clone().add( this.m_Targets[i].target.position.$clone().clone().scale( this.m_Targets[i].weight ) );
                        maxWeight.v = UnityEngine.Mathf.Max(maxWeight.v, this.m_Targets[i].weight);
                    }
                }

                if (weight > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    pos = pos.$clone().scale( 1.0 / ( weight ) );
                } else {
                    pos = this.transform.position.$clone();
                }

                return pos.$clone();
            },
            /*Cinemachine.CinemachineTargetGroup.CalculateAveragePosition end.*/

            /*Cinemachine.CinemachineTargetGroup.CalculateAverageOrientation start.*/
            CalculateAverageOrientation: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#CalculateAverageOrientation", this ); }

                var r = pc.Quat.IDENTITY.clone();
                for (var i = 0; i < this.m_Targets.length; ++i) {
                    if (UnityEngine.Component.op_Inequality(this.m_Targets[i].target, null)) {
                        var w = this.m_Targets[i].weight;
                        var q = this.m_Targets[i].target.rotation.$clone();
                        // This is probably bogus
                        r = new pc.Quat( r.x + q.x * w, r.y + q.y * w, r.z + q.z * w, r.w + q.w * w );
                    }
                }

                return Cinemachine.Utility.UnityQuaternionExtensions.Normalized(r);
            },
            /*Cinemachine.CinemachineTargetGroup.CalculateAverageOrientation end.*/

            /*Cinemachine.CinemachineTargetGroup.CalculateBoundingBox start.*/
            CalculateBoundingBox: function (avgPos, maxWeight) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#CalculateBoundingBox", this ); }

                var b = new pc.BoundingBox( avgPos.$clone(), pc.Vec3.ZERO.clone().scale( 0.5 ) );
                if (maxWeight > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                    for (var i = 0; i < this.m_Targets.length; ++i) {
                        if (UnityEngine.Component.op_Inequality(this.m_Targets[i].target, null)) {
                            var s = Cinemachine.CinemachineTargetGroup.WeightedMemberBounds(this.m_Targets[i].$clone(), this.mAveragePos.$clone(), maxWeight);
                            b.add( new pc.BoundingBox( s.position.$clone(), new pc.Vec3( 1, 1, 1 ).clone().scale( s.radius * 2 ).scale( 0.5 ) ) );
                        }
                    }
                }

                return b;
            },
            /*Cinemachine.CinemachineTargetGroup.CalculateBoundingBox end.*/

            /*Cinemachine.CinemachineTargetGroup.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#OnValidate", this ); }

                for (var i = 0; i < this.m_Targets.length; ++i) {
                    this.m_Targets[i].weight = UnityEngine.Mathf.Max(0, this.m_Targets[i].weight);
                    this.m_Targets[i].radius = UnityEngine.Mathf.Max(0, this.m_Targets[i].radius);
                }
            },
            /*Cinemachine.CinemachineTargetGroup.OnValidate end.*/

            /*Cinemachine.CinemachineTargetGroup.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#FixedUpdate", this ); }

                if (this.m_UpdateMethod === Cinemachine.CinemachineTargetGroup.UpdateMethod.FixedUpdate) {
                    this.DoUpdate();
                }
            },
            /*Cinemachine.CinemachineTargetGroup.FixedUpdate end.*/

            /*Cinemachine.CinemachineTargetGroup.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#Update", this ); }

                if (!UnityEngine.Application.isPlaying || this.m_UpdateMethod === Cinemachine.CinemachineTargetGroup.UpdateMethod.Update) {
                    this.DoUpdate();
                }
            },
            /*Cinemachine.CinemachineTargetGroup.Update end.*/

            /*Cinemachine.CinemachineTargetGroup.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#LateUpdate", this ); }

                if (this.m_UpdateMethod === Cinemachine.CinemachineTargetGroup.UpdateMethod.LateUpdate) {
                    this.DoUpdate();
                }
            },
            /*Cinemachine.CinemachineTargetGroup.LateUpdate end.*/

            /*Cinemachine.CinemachineTargetGroup.GetViewSpaceAngularBounds start.*/
            /**
             * Get the local-space angular bounds of the group, from a spoecific point of view.
                 Also returns the z depth range of the members.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineTargetGroup
             * @memberof Cinemachine.CinemachineTargetGroup
             * @param   {UnityEngine.Matrix4x4}    observer     Point of view from which to calculate, and in whose
                 space the return values are
             * @param   {UnityEngine.Vector2}      minAngles    The lower bound of the screen angles of the members (degrees)
             * @param   {UnityEngine.Vector2}      maxAngles    The upper bound of the screen angles of the members (degrees)
             * @param   {UnityEngine.Vector2}      zRange       The min and max depth values of the members, relative to the observer
             * @return  {void}
             */
            GetViewSpaceAngularBounds: function (observer, minAngles, maxAngles, zRange) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTargetGroup#GetViewSpaceAngularBounds", this ); }

                var $t, $t1;
                var inverseView = observer.clone().invert().$clone();
                minAngles.v = pc.Vec2.ZERO.clone();
                maxAngles.v = pc.Vec2.ZERO.clone();
                zRange.v = UnityEngine.Vector2.FromVector3(pc.Vec3.ZERO.clone());
                for (var i = 0; i < this.m_Targets.length; ++i) {
                    var s = this.GetWeightedBoundsForMember(i);
                    var p = inverseView.transformPoint( s.position );

                    // Add the radius
                    var r = p.length();
                    var extraA = pc.Vec2.ZERO.clone();
                    if (r > Cinemachine.Utility.UnityVectorExtensions.Epsilon && s.radius > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        extraA = pc.Vec2.ONE.clone().scale( Math.atan2(s.radius, r) * UnityEngine.Mathf.Rad2Deg );
                    }

                    var a = Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget(pc.Quat.IDENTITY.clone(), p.$clone(), pc.Vec3.UP.clone());
                    if (i === 0) {
                        minAngles.v = a.$clone().sub( extraA );
                        maxAngles.v = a.$clone().add( extraA );
                        zRange.v = new pc.Vec2( p.z - s.radius, p.z + s.radius );
                    } else {
                        minAngles.v = UnityEngine.Vector2.FromVector3(($t = UnityEngine.Vector3.FromVector2(a.$clone().sub( extraA )), new pc.Vec3( Math.min( UnityEngine.Vector3.FromVector2(minAngles.v).x, $t.x ), Math.min( UnityEngine.Vector3.FromVector2(minAngles.v).y, $t.y ), Math.min( UnityEngine.Vector3.FromVector2(minAngles.v).z, $t.z) )));
                        maxAngles.v = UnityEngine.Vector2.FromVector3(($t1 = UnityEngine.Vector3.FromVector2(a.$clone().add( extraA )), new pc.Vec3( Math.max( UnityEngine.Vector3.FromVector2(maxAngles.v).x, $t1.x ), Math.max( UnityEngine.Vector3.FromVector2(maxAngles.v).y, $t1.y ), Math.max( UnityEngine.Vector3.FromVector2(maxAngles.v).z, $t1.z ) )));
                        zRange.v.x = UnityEngine.Mathf.Min(zRange.v.x, p.z - s.radius);
                        zRange.v.y = UnityEngine.Mathf.Max(zRange.v.y, p.z + s.radius);
                    }
                }
            },
            /*Cinemachine.CinemachineTargetGroup.GetViewSpaceAngularBounds end.*/


        }
    });
    /*Cinemachine.CinemachineTargetGroup end.*/

    /*Cinemachine.CinemachineTrackedDolly start.*/
    /**
     * A Cinemachine Virtual Camera Body component that constrains camera motion
         to a CinemachinePath.  The camera can move along the path.
         This behaviour can operate in two modes: manual positioning, and Auto-Dolly positioning.
         In Manual mode, the camera's position is specified by animating the Path Position field.
         In Auto-Dolly mode, the Path Position field is animated automatically every frame by finding
         the position on the path that's closest to the virtual camera's Follow target.
     *
     * @public
     * @class Cinemachine.CinemachineTrackedDolly
     * @augments Cinemachine.CinemachineComponentBase
     */
    Bridge.define("Cinemachine.CinemachineTrackedDolly", {
        inherits: [Cinemachine.CinemachineComponentBase],
        fields: {
            /**
             * Controls how automatic dollying occurs
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @type Cinemachine.CinemachineTrackedDolly.AutoDolly
             */
            m_AutoDolly: null,
            /**
             * How to set the virtual camera's Up vector.  This will affect the screen composition.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @type number
             */
            m_CameraUp: 0,
            /**
             * The path to which the camera will be constrained.  This must be non-null.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @type Cinemachine.CinemachinePathBase
             */
            m_Path: null,
            /**
             * Where to put the camera realtive to the path postion.  X is perpendicular to the path, Y is up, and Z is
                 parallel to the path.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @type UnityEngine.Vector3
             */
            m_PathOffset: null,
            /**
             * The position along the path at which the camera will be placed.
                 This can be animated directly, or set automatically by the Auto-Dolly feature
                 to get as close as possible to the Follow target.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @type number
             */
            m_PathPosition: 0,
            /**
             * "How aggressively the camera tries to track the target rotation's X angle.
                 Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @default 0
             * @type number
             */
            m_PitchDamping: 0,
            /**
             * How to interpret the Path Position
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @type number
             */
            m_PositionUnits: 0,
            m_PreviousCameraPosition: null,
            m_PreviousOrientation: null,
            m_PreviousPathPosition: 0,
            /**
             * How aggressively the camera tries to track the target rotation's Z angle.
                 Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @default 0.0
             * @type number
             */
            m_RollDamping: 0,
            /**
             * How aggressively the camera tries to maintain the offset perpendicular to the path.
                 Small numbers are more responsive, rapidly translating the camera to keep the target's
                 x-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @default 0.0
             * @type number
             */
            m_XDamping: 0,
            /**
             * How aggressively the camera tries to track the target rotation's Y angle.
                 Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @default 0
             * @type number
             */
            m_YawDamping: 0,
            /**
             * How aggressively the camera tries to maintain the offset in the path-local up direction.
                 Small numbers are more responsive, rapidly translating the camera to keep the target's
                 y-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @default 0.0
             * @type number
             */
            m_YDamping: 0,
            /**
             * How aggressively the camera tries to maintain the offset parallel to the path.
                 Small numbers are more responsive, rapidly translating the camera to keep the
                 target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
                 Using different settings per axis can yield a wide range of camera behaviors
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @default 1.0
             * @type number
             */
            m_ZDamping: 0
        },
        props: {
            /**
             * True if component is enabled and has a path
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @function IsValid
             * @type boolean
             */
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly#IsValid#get", this ); }

                    return this.enabled && UnityEngine.MonoBehaviour.op_Inequality(this.m_Path, null);
                }
            },
            /**
             * Get the Cinemachine Pipeline stage that this component implements.
                 Always returns the Body stage
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @function Stage
             * @type number
             */
            Stage: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly#Stage#get", this ); }

                    return Cinemachine.CinemachineCore.Stage.Body;
                }
            },
            AngularDamping: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly#AngularDamping#get", this ); }

                    switch (this.m_CameraUp) {
                        case Cinemachine.CinemachineTrackedDolly.CameraUpMode.PathNoRoll: 
                        case Cinemachine.CinemachineTrackedDolly.CameraUpMode.FollowTargetNoRoll: 
                            return new pc.Vec3( this.m_PitchDamping, this.m_YawDamping, 0 );
                        case Cinemachine.CinemachineTrackedDolly.CameraUpMode.Default: 
                            return pc.Vec3.ZERO.clone();
                        default: 
                            return new pc.Vec3( this.m_PitchDamping, this.m_YawDamping, this.m_RollDamping );
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly#init", this ); }

                this.m_AutoDolly = new Cinemachine.CinemachineTrackedDolly.AutoDolly();
                this.m_PathOffset = new UnityEngine.Vector3();
                this.m_PreviousCameraPosition = new UnityEngine.Vector3();
                this.m_PreviousOrientation = new UnityEngine.Quaternion();
                this.m_AutoDolly = new Cinemachine.CinemachineTrackedDolly.AutoDolly.$ctor1(false, 0, 2, 5);
                this.m_CameraUp = Cinemachine.CinemachineTrackedDolly.CameraUpMode.Default;
                this.m_PathOffset = pc.Vec3.ZERO.clone();
                this.m_PitchDamping = 0;
                this.m_PositionUnits = Cinemachine.CinemachinePathBase.PositionUnits.PathUnits;
                this.m_PreviousCameraPosition = pc.Vec3.ZERO.clone();
                this.m_PreviousOrientation = pc.Quat.IDENTITY.clone();
                this.m_RollDamping = 0.0;
                this.m_XDamping = 0.0;
                this.m_YawDamping = 0;
                this.m_YDamping = 0.0;
                this.m_ZDamping = 1.0;
            }
        },
        methods: {
            /*Cinemachine.CinemachineTrackedDolly.MutateCameraState start.*/
            /**
             * Positions the virtual camera according to the transposer rules.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineTrackedDolly
             * @memberof Cinemachine.CinemachineTrackedDolly
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for damping.  If less that 0, no damping is done.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly#MutateCameraState", this ); }

                // Init previous frame state info
                if (deltaTime < 0 || !this.VirtualCamera.PreviousStateIsValid) {
                    this.m_PreviousPathPosition = this.m_PathPosition;
                    this.m_PreviousCameraPosition = curState.v.RawPosition.$clone();
                }

                if (!this.IsValid) {
                    return;
                }

                // Get the new ideal path base position
                if (this.m_AutoDolly.m_Enabled && UnityEngine.Component.op_Inequality(this.FollowTarget, null)) {
                    var prevPos = this.m_Path.ToNativePathUnits(this.m_PreviousPathPosition, this.m_PositionUnits);
                    // This works in path units
                    this.m_PathPosition = this.m_Path.FindClosestPoint(this.FollowTargetPosition.$clone(), Math.floor(prevPos), deltaTime < 0 || this.m_AutoDolly.m_SearchRadius <= 0 ? -1 : this.m_AutoDolly.m_SearchRadius, this.m_AutoDolly.m_SearchResolution);
                    this.m_PathPosition = this.m_Path.FromPathNativeUnits(this.m_PathPosition, this.m_PositionUnits);

                    // Apply the path position offset
                    this.m_PathPosition += this.m_AutoDolly.m_PositionOffset;
                }

                var newPathPosition = this.m_PathPosition;

                if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                    // Normalize previous position to find the shortest path
                    var maxUnit = this.m_Path.MaxUnit(this.m_PositionUnits);
                    if (maxUnit > 0) {
                        var prev = this.m_Path.StandardizeUnit(this.m_PreviousPathPosition, this.m_PositionUnits);
                        var next = this.m_Path.StandardizeUnit(newPathPosition, this.m_PositionUnits);
                        if (this.m_Path.Looped && Math.abs(next - prev) > maxUnit / 2) {
                            if (next > prev) {
                                prev += maxUnit;
                            } else {
                                prev -= maxUnit;
                            }
                        }

                        this.m_PreviousPathPosition = prev;
                        newPathPosition = next;
                    }

                    // Apply damping along the path direction
                    var offset = this.m_PreviousPathPosition - newPathPosition;
                    offset = Cinemachine.Utility.Damper.Damp(offset, this.m_ZDamping, deltaTime);
                    newPathPosition = this.m_PreviousPathPosition - offset;
                }

                this.m_PreviousPathPosition = newPathPosition;
                var newPathOrientation = this.m_Path.EvaluateOrientationAtUnit(newPathPosition, this.m_PositionUnits);

                // Apply the offset to get the new camera position
                var newCameraPos = this.m_Path.EvaluatePositionAtUnit(newPathPosition, this.m_PositionUnits);
                var offsetX = newPathOrientation.transformVector( pc.Vec3.RIGHT.clone() );
                var offsetY = newPathOrientation.transformVector( pc.Vec3.UP.clone() );
                var offsetZ = newPathOrientation.transformVector( new pc.Vec3( 0, 0, 1 ) );
                newCameraPos = newCameraPos.$clone().add( offsetX.clone().scale( this.m_PathOffset.x ) );
                newCameraPos = newCameraPos.$clone().add( offsetY.clone().scale( this.m_PathOffset.y ) );
                newCameraPos = newCameraPos.$clone().add( offsetZ.clone().scale( this.m_PathOffset.z ) );

                // Apply damping to the remaining directions
                if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                    var currentCameraPos = this.m_PreviousCameraPosition.$clone();
                    var delta = currentCameraPos.$clone().sub( newCameraPos );
                    var delta1 = offsetY.clone().scale( delta.dot( offsetY ) );
                    var delta0 = delta.$clone().sub( delta1 );
                    delta0 = Cinemachine.Utility.Damper.Damp$1(delta0.$clone(), this.m_XDamping, deltaTime);
                    delta1 = Cinemachine.Utility.Damper.Damp$1(delta1.$clone(), this.m_YDamping, deltaTime);
                    newCameraPos = currentCameraPos.$clone().sub( (delta0.$clone().add( delta1 )) );
                }

                curState.v.RawPosition = (this.m_PreviousCameraPosition = newCameraPos.$clone());

                // Set the orientation and up
                var newOrientation = this.GetCameraOrientationAtPathPoint(newPathOrientation.$clone(), curState.v.ReferenceUp.$clone());
                if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                    var relative = (this.m_PreviousOrientation.clone().invert().clone().mul( newOrientation )).getPositiveEulerAngles().$clone();
                    for (var i = 0; i < 3; ++i) {
                        if (relative.getitem(i) > 180) {
                            relative.setitem(i, relative.getitem(i) -360);
                        }
                    }

                    relative = Cinemachine.Utility.Damper.Damp$2(relative.$clone(), this.AngularDamping.$clone(), deltaTime);
                    newOrientation = this.m_PreviousOrientation.clone().mul( new pc.Quat().setFromEulerAngles_Unity( relative.x, relative.y, relative.z ) );
                }

                this.m_PreviousOrientation = newOrientation.$clone();

                curState.v.RawOrientation = newOrientation.$clone();
                if (this.m_CameraUp !== Cinemachine.CinemachineTrackedDolly.CameraUpMode.Default) {
                    curState.v.ReferenceUp = curState.v.RawOrientation.transformVector( pc.Vec3.UP.clone() );
                }
            },
            /*Cinemachine.CinemachineTrackedDolly.MutateCameraState end.*/

            /*Cinemachine.CinemachineTrackedDolly.GetCameraOrientationAtPathPoint start.*/
            GetCameraOrientationAtPathPoint: function (pathOrientation, up) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineTrackedDolly#GetCameraOrientationAtPathPoint", this ); }

                switch (this.m_CameraUp) {
                    default: 
                    case Cinemachine.CinemachineTrackedDolly.CameraUpMode.Default: 
                        break;
                    case Cinemachine.CinemachineTrackedDolly.CameraUpMode.Path: 
                        return pathOrientation.$clone();
                    case Cinemachine.CinemachineTrackedDolly.CameraUpMode.PathNoRoll: 
                        return new pc.Quat().setLookAt( pathOrientation.transformVector( new pc.Vec3( 0, 0, 1 ) ), up );
                    case Cinemachine.CinemachineTrackedDolly.CameraUpMode.FollowTarget: 
                        if (UnityEngine.Component.op_Inequality(this.FollowTarget, null)) {
                            return this.FollowTargetRotation.$clone();
                        }
                        break;
                    case Cinemachine.CinemachineTrackedDolly.CameraUpMode.FollowTargetNoRoll: 
                        if (UnityEngine.Component.op_Inequality(this.FollowTarget, null)) {
                            return new pc.Quat().setLookAt( this.FollowTargetRotation.transformVector( new pc.Vec3( 0, 0, 1 ) ), up );
                        }
                        break;
                }

                return new pc.Quat().setLookAt( this.transform.rotation.transformVector( new pc.Vec3( 0, 0, 1 ) ), up );
            },
            /*Cinemachine.CinemachineTrackedDolly.GetCameraOrientationAtPathPoint end.*/


        }
    });
    /*Cinemachine.CinemachineTrackedDolly end.*/

    /*Cinemachine.StaticPointVirtualCamera start.*/
    /**
     * Point source for blending. It's not really a virtual camera, but takes
         a CameraState and exposes it as a virtual camera for the purposes of blending.
     *
     * @class Cinemachine.StaticPointVirtualCamera
     * @implements  Cinemachine.ICinemachineCamera
     */
    Bridge.define("Cinemachine.StaticPointVirtualCamera", {
        inherits: [Cinemachine.ICinemachineCamera],
        fields: {
            Name: null,
            Priority: 0,
            LookAt: null,
            Follow: null,
            State: null
        },
        props: {
            Description: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#Description#get", this ); }

                    return "";
                }
            },
            VirtualCameraGameObject: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#VirtualCameraGameObject#get", this ); }

                    return null;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#IsValid#get", this ); }

                    return true;
                }
            },
            ParentCamera: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#ParentCamera#get", this ); }

                    return null;
                }
            }
        },
        alias: [
            "Name", "Cinemachine$ICinemachineCamera$Name",
            "Description", "Cinemachine$ICinemachineCamera$Description",
            "Priority", "Cinemachine$ICinemachineCamera$Priority",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "State", "Cinemachine$ICinemachineCamera$State",
            "VirtualCameraGameObject", "Cinemachine$ICinemachineCamera$VirtualCameraGameObject",
            "IsValid", "Cinemachine$ICinemachineCamera$IsValid",
            "ParentCamera", "Cinemachine$ICinemachineCamera$ParentCamera",
            "IsLiveChild", "Cinemachine$ICinemachineCamera$IsLiveChild",
            "UpdateCameraState", "Cinemachine$ICinemachineCamera$UpdateCameraState",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#init", this ); }

                this.State = new Cinemachine.CameraState();
            },
            ctor: function (state, name) {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#ctor", this ); }

                this.$initialize();
                this.State = state.$clone();
                this.Name = name;
            }
        },
        methods: {
            /*Cinemachine.StaticPointVirtualCamera.IsLiveChild start.*/
            IsLiveChild: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#IsLiveChild", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                return false;
            },
            /*Cinemachine.StaticPointVirtualCamera.IsLiveChild end.*/

            /*Cinemachine.StaticPointVirtualCamera.UpdateCameraState start.*/
            UpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#UpdateCameraState", this ); }
 },
            /*Cinemachine.StaticPointVirtualCamera.UpdateCameraState end.*/

            /*Cinemachine.StaticPointVirtualCamera.InternalUpdateCameraState start.*/
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#InternalUpdateCameraState", this ); }
 },
            /*Cinemachine.StaticPointVirtualCamera.InternalUpdateCameraState end.*/

            /*Cinemachine.StaticPointVirtualCamera.OnTransitionFromCamera start.*/
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#OnTransitionFromCamera", this ); }
 },
            /*Cinemachine.StaticPointVirtualCamera.OnTransitionFromCamera end.*/

            /*Cinemachine.StaticPointVirtualCamera.OnTargetObjectWarped start.*/
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#OnTargetObjectWarped", this ); }
 },
            /*Cinemachine.StaticPointVirtualCamera.OnTargetObjectWarped end.*/

            /*Cinemachine.StaticPointVirtualCamera.SetState start.*/
            SetState: function (state) {
if ( TRACE ) { TRACE( "Cinemachine.StaticPointVirtualCamera#SetState", this ); }

                this.State = state.$clone();
            },
            /*Cinemachine.StaticPointVirtualCamera.SetState end.*/


        }
    });
    /*Cinemachine.StaticPointVirtualCamera end.*/

    /*Cinemachine.Utility.GaussianWindow1D_CameraRotation start.*/
    Bridge.define("Cinemachine.Utility.GaussianWindow1D_CameraRotation", {
        inherits: [Cinemachine.Utility.GaussianWindow1d$1(UnityEngine.Vector2)],
        ctors: {
            ctor: function (sigma, maxKernelRadius) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1D_CameraRotation#ctor", this ); }

                if (maxKernelRadius === void 0) { maxKernelRadius = 10; }

                this.$initialize();
                Cinemachine.Utility.GaussianWindow1d$1(UnityEngine.Vector2).ctor.call(this, sigma, maxKernelRadius);
            }
        },
        methods: {
            /*Cinemachine.Utility.GaussianWindow1D_CameraRotation.Compute start.*/
            Compute: function (windowPos) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1D_CameraRotation#Compute", this ); }

                var sum = pc.Vec2.ZERO.clone();
                var v = this.mData[this.mCurrentPos].$clone();
                for (var i = 0; i < this.KernelSize; ++i) {
                    var v2 = this.mData[windowPos].$clone().sub( v );
                    if (v2.y > 180.0) {
                        v2.y -= 360.0;
                    }

                    if (v2.y < -180.0) {
                        v2.y += 360.0;
                    }

                    sum = sum.$clone().add( v2.$clone().scale( this.mKernel[i] ) );
                    if (++windowPos === this.KernelSize) {
                        windowPos = 0;
                    }
                }

                return v.$clone().add( sum );
            },
            /*Cinemachine.Utility.GaussianWindow1D_CameraRotation.Compute end.*/


        }
    });
    /*Cinemachine.Utility.GaussianWindow1D_CameraRotation end.*/

    /*Cinemachine.Utility.GaussianWindow1D_Quaternion start.*/
    Bridge.define("Cinemachine.Utility.GaussianWindow1D_Quaternion", {
        inherits: [Cinemachine.Utility.GaussianWindow1d$1(UnityEngine.Quaternion)],
        ctors: {
            ctor: function (sigma, maxKernelRadius) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1D_Quaternion#ctor", this ); }

                if (maxKernelRadius === void 0) { maxKernelRadius = 10; }

                this.$initialize();
                Cinemachine.Utility.GaussianWindow1d$1(UnityEngine.Quaternion).ctor.call(this, sigma, maxKernelRadius);
            }
        },
        methods: {
            /*Cinemachine.Utility.GaussianWindow1D_Quaternion.Compute start.*/
            Compute: function (windowPos) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1D_Quaternion#Compute", this ); }

                var sum = new pc.Quat( 0, 0, 0, 0 );
                var q = this.mData[this.mCurrentPos].$clone();
                var qInverse = q.clone().invert();
                for (var i = 0; i < this.KernelSize; ++i) {
                    // Make sure the quaternion is in the same hemisphere, or averaging won't work
                    var scale = this.mKernel[i];
                    var q2 = qInverse.clone().mul( this.mData[windowPos] );
                    if (pc.Quat.IDENTITY.clone().dot( q2 ) < 0) {
                        scale = -scale;
                    }

                    sum.x += q2.x * scale;
                    sum.y += q2.y * scale;
                    sum.z += q2.z * scale;
                    sum.w += q2.w * scale;

                    if (++windowPos === this.KernelSize) {
                        windowPos = 0;
                    }
                }
                return q.clone().mul( Cinemachine.Utility.UnityQuaternionExtensions.Normalized(sum) );
            },
            /*Cinemachine.Utility.GaussianWindow1D_Quaternion.Compute end.*/


        }
    });
    /*Cinemachine.Utility.GaussianWindow1D_Quaternion end.*/

    /*Cinemachine.Utility.GaussianWindow1D_Vector3 start.*/
    Bridge.define("Cinemachine.Utility.GaussianWindow1D_Vector3", {
        inherits: [Cinemachine.Utility.GaussianWindow1d$1(UnityEngine.Vector3)],
        ctors: {
            ctor: function (sigma, maxKernelRadius) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1D_Vector3#ctor", this ); }

                if (maxKernelRadius === void 0) { maxKernelRadius = 10; }

                this.$initialize();
                Cinemachine.Utility.GaussianWindow1d$1(UnityEngine.Vector3).ctor.call(this, sigma, maxKernelRadius);
            }
        },
        methods: {
            /*Cinemachine.Utility.GaussianWindow1D_Vector3.Compute start.*/
            Compute: function (windowPos) {
if ( TRACE ) { TRACE( "Cinemachine.Utility.GaussianWindow1D_Vector3#Compute", this ); }

                var sum = pc.Vec3.ZERO.clone();
                for (var i = 0; i < this.KernelSize; ++i) {
                    sum = sum.$clone().add( this.mData[windowPos].$clone().clone().scale( this.mKernel[i] ) );
                    if (++windowPos === this.KernelSize) {
                        windowPos = 0;
                    }
                }

                return sum.$clone();
            },
            /*Cinemachine.Utility.GaussianWindow1D_Vector3.Compute end.*/


        }
    });
    /*Cinemachine.Utility.GaussianWindow1D_Vector3 end.*/

    /*CinemachineCameraOffset start.*/
    /**
     * An add-on module for Cinemachine Virtual Camera that adds a final offset to the camera
     *
     * @public
     * @class CinemachineCameraOffset
     * @augments Cinemachine.CinemachineExtension
     */
    Bridge.define("CinemachineCameraOffset", {
        inherits: [Cinemachine.CinemachineExtension],
        fields: {
            m_Offset: null,
            m_ApplyAfter: 0,
            m_PreserveComposition: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CinemachineCameraOffset#init", this ); }

                this.m_Offset = new UnityEngine.Vector3();
                this.m_Offset = pc.Vec3.ZERO.clone();
                this.m_ApplyAfter = Cinemachine.CinemachineCore.Stage.Aim;
            }
        },
        methods: {
            /*CinemachineCameraOffset.PostPipelineStageCallback start.*/
            PostPipelineStageCallback: function (vcam, stage, state, deltaTime) {
if ( TRACE ) { TRACE( "CinemachineCameraOffset#PostPipelineStageCallback", this ); }

                if (stage === this.m_ApplyAfter) {
                    var preserveAim = this.m_PreserveComposition && state.v.HasLookAt && stage > Cinemachine.CinemachineCore.Stage.Body;

                    var screenOffset = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                    if (preserveAim) {
                        screenOffset = UnityEngine.Vector3.FromVector2(Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget(state.v.RawOrientation, state.v.ReferenceLookAt.$clone().sub( state.v.CorrectedPosition ), state.v.ReferenceUp.$clone()));
                    }

                    var offset = state.v.RawOrientation.transformVector( this.m_Offset );
                    state.v.PositionCorrection = state.v.PositionCorrection.$clone().add( offset.$clone() );
                    if (!preserveAim) {
                        state.v.ReferenceLookAt = state.v.ReferenceLookAt.$clone().add( offset.$clone() );
                    } else {
                        var q = new pc.Quat().setLookAt( state.v.ReferenceLookAt.$clone().sub( state.v.CorrectedPosition ), state.v.ReferenceUp );
                        q = Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation(q, UnityEngine.Vector2.FromVector3(screenOffset.$clone().scale( -1 )), state.v.ReferenceUp.$clone());
                        state.v.RawOrientation = q.$clone();
                    }
                }
            },
            /*CinemachineCameraOffset.PostPipelineStageCallback end.*/


        }
    });
    /*CinemachineCameraOffset end.*/

    /*Cinemachine.CinemachineBlendListCamera start.*/
    /**
     * This is a virtual camera "manager" that owns and manages a collection
         of child Virtual Cameras.  When the camera goes live, these child vcams
         are enabled, one after another, holding each camera for a designated time.
         Blends between cameras are specified.
         The last camera is held indefinitely.
     *
     * @public
     * @class Cinemachine.CinemachineBlendListCamera
     * @augments Cinemachine.CinemachineVirtualCameraBase
     */
    Bridge.define("Cinemachine.CinemachineBlendListCamera", {
        inherits: [Cinemachine.CinemachineVirtualCameraBase],
        fields: {
            /**
             * Default object for the camera children to look at (the aim target), if not specified in a child rig.  May be
                 empty
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @type UnityEngine.Transform
             */
            m_LookAt: null,
            /**
             * Default object for the camera children wants to move with (the body target), if not specified in a child rig.
                 May be empty
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @type UnityEngine.Transform
             */
            m_Follow: null,
            /**
             * When enabled, the current camera and blend will be indicated in the game window, for debugging
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @default false
             * @type boolean
             */
            m_ShowDebugText: false,
            
            m_Loop: false,
            /**
             * Internal API for the editor.  Do not use this field
             *
             * @instance
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @type Array.<Cinemachine.CinemachineVirtualCameraBase>
             */
            m_ChildCameras: null,
            /**
             * The set of instructions associating virtual cameras with states.
                 The set of instructions for enabling child cameras
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @type Array.<Cinemachine.CinemachineBlendListCamera.Instruction>
             */
            m_Instructions: null,
            /**
             * Get the current "best" child virtual camera, that would be chosen
                 if the State Driven Camera were active.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @function LiveChild
             * @type Cinemachine.ICinemachineCamera
             */
            LiveChild: null,
            TransitioningFrom: null,
            m_State: null,
            /**
             * The time at which the current instruction went live
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @type number
             */
            mActivationTime: 0,
            mCurrentInstruction: 0,
            mActiveBlend: null
        },
        props: {
            /**
             * Gets a brief debug description of this virtual camera, for use when displayiong debug info
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @function Description
             * @type string
             */
            Description: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#Description#get", this ); }

                    // Show the active camera and blend
                    if (this.mActiveBlend != null) {
                        return this.mActiveBlend.Description;
                    }

                    var vcam = this.LiveChild;
                    if (vcam == null) {
                        return "(none)";
                    }

                    var sb = Cinemachine.Utility.CinemachineDebug.SBFromPool();
                    sb.append("[");
                    sb.append(vcam.Cinemachine$ICinemachineCamera$Name);
                    sb.append("]");
                    var text = sb.toString();
                    Cinemachine.Utility.CinemachineDebug.ReturnToPool(sb);
                    return text;
                }
            },
            /**
             * The State of the current live child
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @function State
             * @type Cinemachine.CameraState
             */
            State: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#State#get", this ); }

                    return this.m_State.$clone();
                }
            },
            /**
             * Get the current LookAt target.  Returns parent's LookAt if parent
                 is non-null and no specific LookAt defined for this camera
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @function LookAt
             * @type UnityEngine.Transform
             */
            LookAt: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#LookAt#get", this ); }

                    return this.ResolveLookAt(this.m_LookAt);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#LookAt#set", this ); }

                    this.m_LookAt = value;
                }
            },
            /**
             * Get the current Follow target.  Returns parent's Follow if parent
                 is non-null and no specific Follow defined for this camera
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @function Follow
             * @type UnityEngine.Transform
             */
            Follow: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#Follow#get", this ); }

                    return this.ResolveFollow(this.m_Follow);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#Follow#set", this ); }

                    this.m_Follow = value;
                }
            },
            /**
             * The list of child cameras.  These are just the immediate children in the hierarchy.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @function ChildCameras
             * @type Array.<Cinemachine.CinemachineVirtualCameraBase>
             */
            ChildCameras: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#ChildCameras#get", this ); }

                    this.UpdateListOfChildren();
                    return this.m_ChildCameras;
                }
            },
            /**
             * Is there a blend in progress?
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @function IsBlending
             * @type boolean
             */
            IsBlending: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#IsBlending#get", this ); }

                    return this.mActiveBlend != null;
                }
            }
        },
        alias: [
            "Description", "Cinemachine$ICinemachineCamera$Description",
            "IsLiveChild", "Cinemachine$ICinemachineCamera$IsLiveChild",
            "State", "Cinemachine$ICinemachineCamera$State",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#init", this ); }

                this.m_State = new Cinemachine.CameraState();
                this.m_ShowDebugText = false;
                this.m_Loop = false;
                this.m_State = Cinemachine.CameraState.Default.$clone();
                this.mActivationTime = -1;
            }
        },
        methods: {
            /*Cinemachine.CinemachineBlendListCamera.IsLiveChild start.*/
            /**
             * Check whether the vcam a live child of this camera.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineBlendListCamera
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @param   {Cinemachine.ICinemachineCamera}    vcam                 The Virtual Camera to check
             * @param   {boolean}                           dominantChildOnly    If truw, will only return true if this vcam is the dominat live child
             * @return  {boolean}                                                True if the vcam is currently actively influencing the state of this vcam
             */
            IsLiveChild: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#IsLiveChild", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                return Bridge.referenceEquals(vcam, this.LiveChild) || this.mActiveBlend != null && this.mActiveBlend.Uses(vcam);
            },
            /*Cinemachine.CinemachineBlendListCamera.IsLiveChild end.*/

            /*Cinemachine.CinemachineBlendListCamera.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the vcam that a target got warped,
                 so that the vcam can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineBlendListCamera
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#OnTargetObjectWarped", this ); }

                var $t;
                this.UpdateListOfChildren();
                $t = Bridge.getEnumerator(this.m_ChildCameras);
                try {
                    while ($t.moveNext()) {
                        var vcam = $t.Current;
                        vcam.OnTargetObjectWarped(target, positionDelta.$clone());
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
            },
            /*Cinemachine.CinemachineBlendListCamera.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineBlendListCamera.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineBlendListCamera
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}               worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                            deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#OnTransitionFromCamera", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTransitionFromCamera.call(this, fromCam, worldUp.$clone(), deltaTime);
                this.InvokeOnTransitionInExtensions(fromCam, worldUp.$clone(), deltaTime);
                this.mActivationTime = UnityEngine.Time.time;
                this.mCurrentInstruction = 0;
                this.LiveChild = null;
                this.mActiveBlend = null;
                this.TransitioningFrom = fromCam;
                this.InternalUpdateCameraState(worldUp.$clone(), deltaTime);
            },
            /*Cinemachine.CinemachineBlendListCamera.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineBlendListCamera.InternalUpdateCameraState start.*/
            /**
             * Called by CinemachineCore at designated update time
                 so the vcam can position itself and track its targets.  This implementation
                 updates all the children, chooses the best one, and implements any required blending.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineBlendListCamera
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @param   {UnityEngine.Vector3}    worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                 deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#InternalUpdateCameraState", this ); }

                if (!this.PreviousStateIsValid) {
                    this.mCurrentInstruction = -1;
                    this.mActiveBlend = null;
                }

                this.UpdateListOfChildren();
                this.AdvanceCurrentInstruction(deltaTime);

                var best = null;
                if (this.mCurrentInstruction >= 0 && this.mCurrentInstruction < this.m_Instructions.length) {
                    best = this.m_Instructions[this.mCurrentInstruction].m_VirtualCamera;
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(best, null)) {
                    if (!best.gameObject.activeInHierarchy) {
                        best.gameObject.SetActive(true);
                        best.UpdateCameraState(worldUp.$clone(), deltaTime);
                    }

                    var previousCam = this.LiveChild;
                    this.LiveChild = best;

                    // Are we transitioning cameras?
                    if (!Bridge.referenceEquals(previousCam, this.LiveChild) && this.LiveChild != null) {
                        // Notify incoming camera of transition
                        this.LiveChild.Cinemachine$ICinemachineCamera$OnTransitionFromCamera(previousCam, worldUp.$clone(), deltaTime);

                        // Generate Camera Activation event in the brain if live
                        Cinemachine.CinemachineCore.Instance.GenerateCameraActivationEvent(this.LiveChild, previousCam);

                        if (previousCam != null) {
                            // Create a blend (will be null if a cut)
                            this.mActiveBlend = this.CreateBlend(previousCam, this.LiveChild, this.m_Instructions[this.mCurrentInstruction].m_Blend.$clone(), this.mActiveBlend);

                            // If cutting, generate a camera cut event if live
                            if (this.mActiveBlend == null || !this.mActiveBlend.Uses(previousCam)) {
                                Cinemachine.CinemachineCore.Instance.GenerateCameraCutEvent(this.LiveChild);
                            }
                        }
                    }
                }

                // Advance the current blend (if any)
                if (this.mActiveBlend != null) {
                    this.mActiveBlend.TimeInBlend += deltaTime >= 0 ? deltaTime : this.mActiveBlend.Duration;
                    if (this.mActiveBlend.IsComplete) {
                        this.mActiveBlend = null;
                    }
                }

                if (this.mActiveBlend != null) {
                    this.mActiveBlend.UpdateCameraState(worldUp.$clone(), deltaTime);
                    this.m_State = this.mActiveBlend.State.$clone();
                } else if (this.LiveChild != null) {
                    if (this.TransitioningFrom != null) {
                        this.LiveChild.Cinemachine$ICinemachineCamera$OnTransitionFromCamera(this.TransitioningFrom, worldUp.$clone(), deltaTime);
                    }

                    this.m_State = this.LiveChild.Cinemachine$ICinemachineCamera$State.$clone();
                }

                this.TransitioningFrom = null;
                this.InvokePostPipelineStageCallback(this, Cinemachine.CinemachineCore.Stage.Finalize, Bridge.ref(this, "m_State"), deltaTime);
                this.PreviousStateIsValid = true;
            },
            /*Cinemachine.CinemachineBlendListCamera.InternalUpdateCameraState end.*/

            /*Cinemachine.CinemachineBlendListCamera.OnEnable start.*/
            /**
             * Makes sure the internal child cache is up to date
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineBlendListCamera
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#OnEnable", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnEnable.call(this);
                this.InvalidateListOfChildren();
                this.LiveChild = null;
                this.mActiveBlend = null;
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.remove(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.combine(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
            },
            /*Cinemachine.CinemachineBlendListCamera.OnEnable end.*/

            /*Cinemachine.CinemachineBlendListCamera.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#OnDisable", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnDisable.call(this);
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.remove(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
            },
            /*Cinemachine.CinemachineBlendListCamera.OnDisable end.*/

            /*Cinemachine.CinemachineBlendListCamera.OnTransformChildrenChanged start.*/
            /**
             * Makes sure the internal child cache is up to date
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineBlendListCamera
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @return  {void}
             */
            OnTransformChildrenChanged: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#OnTransformChildrenChanged", this ); }

                this.InvalidateListOfChildren();
            },
            /*Cinemachine.CinemachineBlendListCamera.OnTransformChildrenChanged end.*/

            /*Cinemachine.CinemachineBlendListCamera.OnGuiHandler start.*/
            /**
             * @instance
             * @private
             * @this Cinemachine.CinemachineBlendListCamera
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @return  {void}
             */
            OnGuiHandler: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#OnGuiHandler", this ); }

                if (!this.m_ShowDebugText) {
                    Cinemachine.Utility.CinemachineDebug.ReleaseScreenPos(this);
                } else {
                    var sb = Cinemachine.Utility.CinemachineDebug.SBFromPool();
                    sb.append(this.Name);
                    sb.append(": ");
                    sb.append(this.Description);
                    var text = sb.toString();
                    var r = Cinemachine.Utility.CinemachineDebug.GetScreenPos(this, text, UnityEngine.GUI.skin.box);
                    UnityEngine.GUI.Label$1(r.$clone(), text, UnityEngine.GUI.skin.box);
                    Cinemachine.Utility.CinemachineDebug.ReturnToPool(sb);
                }
            },
            /*Cinemachine.CinemachineBlendListCamera.OnGuiHandler end.*/

            /*Cinemachine.CinemachineBlendListCamera.InvalidateListOfChildren start.*/
            InvalidateListOfChildren: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#InvalidateListOfChildren", this ); }

                this.m_ChildCameras = null;
                this.LiveChild = null;
            },
            /*Cinemachine.CinemachineBlendListCamera.InvalidateListOfChildren end.*/

            /*Cinemachine.CinemachineBlendListCamera.UpdateListOfChildren start.*/
            UpdateListOfChildren: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#UpdateListOfChildren", this ); }

                var $t;
                if (this.m_ChildCameras != null) {
                    return;
                }

                var list = new (System.Collections.Generic.List$1(Cinemachine.CinemachineVirtualCameraBase)).ctor();
                var kids = this.GetComponentsInChildren$1(Cinemachine.CinemachineVirtualCameraBase, true);
                $t = Bridge.getEnumerator(kids);
                try {
                    while ($t.moveNext()) {
                        var k = $t.Current;
                        if (UnityEngine.Component.op_Equality(k.transform.parent, this.transform)) {
                            list.add(k);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.m_ChildCameras = list.ToArray();
                this.ValidateInstructions();
            },
            /*Cinemachine.CinemachineBlendListCamera.UpdateListOfChildren end.*/

            /*Cinemachine.CinemachineBlendListCamera.ValidateInstructions start.*/
            /**
             * Internal API for the inspector editor.
             *
             * @instance
             * @this Cinemachine.CinemachineBlendListCamera
             * @memberof Cinemachine.CinemachineBlendListCamera
             * @return  {void}
             */
            ValidateInstructions: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#ValidateInstructions", this ); }

                if (this.m_Instructions == null) {
                    this.m_Instructions = System.Array.init(0, function (){
                        return new Cinemachine.CinemachineBlendListCamera.Instruction();
                    }, Cinemachine.CinemachineBlendListCamera.Instruction);
                }

                for (var i = 0; i < this.m_Instructions.length; ++i) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Instructions[i].m_VirtualCamera, null) && UnityEngine.Component.op_Inequality(this.m_Instructions[i].m_VirtualCamera.transform.parent, this.transform)) {
                        this.m_Instructions[i].m_VirtualCamera = null;
                    }
                }

                this.mActiveBlend = null;
            },
            /*Cinemachine.CinemachineBlendListCamera.ValidateInstructions end.*/

            /*Cinemachine.CinemachineBlendListCamera.AdvanceCurrentInstruction start.*/
            AdvanceCurrentInstruction: function (deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineBlendListCamera#AdvanceCurrentInstruction", this ); }

                if (this.m_ChildCameras == null || this.m_ChildCameras.length === 0 || this.mActivationTime < 0 || this.m_Instructions.length === 0) {
                    this.mActivationTime = -1;
                    this.mCurrentInstruction = -1;
                    this.mActiveBlend = null;
                    return;
                }

                var now = UnityEngine.Time.time;
                if (this.mCurrentInstruction < 0 || deltaTime < 0) {
                    this.mActivationTime = now;
                    this.mCurrentInstruction = 0;
                }

                if (this.mCurrentInstruction > this.m_Instructions.length - 1) {
                    this.mActivationTime = now;
                    this.mCurrentInstruction = this.m_Instructions.length - 1;
                }

                var minHold = this.mCurrentInstruction < this.m_Instructions.length - 1 || this.m_Loop ? 0 : 3.40282347E+38;
                if (now - this.mActivationTime > UnityEngine.Mathf.Max(minHold, this.m_Instructions[this.mCurrentInstruction].m_Hold)) {
                    this.mActivationTime = now;
                    ++this.mCurrentInstruction;
                    if (this.m_Loop && this.mCurrentInstruction === this.m_Instructions.length) {
                        this.mCurrentInstruction = 0;
                    }
                }
            },
            /*Cinemachine.CinemachineBlendListCamera.AdvanceCurrentInstruction end.*/


        }
    });
    /*Cinemachine.CinemachineBlendListCamera end.*/

    /*Cinemachine.CinemachineClearShot start.*/
    /**
     * Cinemachine ClearShot is a "manager camera" that owns and manages a set of
         Virtual Camera gameObject children.  When Live, the ClearShot will check the
         children, and choose the one with the best quality shot and make it Live.
         This can be a very powerful tool.  If the child cameras have CinemachineCollider
         extensions, they will analyze the scene for target obstructions, optimal target
         distance, and other items, and report their assessment of shot quality back to
         the ClearShot parent, who will then choose the best one.  You can use this to set
         up complex multi-camera coverage of a scene, and be assured that a clear shot of
         the target will always be available.
         If multiple child cameras have the same shot quality, the one with the highest
         priority will be chosen.
         You can also define custom blends between the ClearShot children.
     *
     * @public
     * @class Cinemachine.CinemachineClearShot
     * @augments Cinemachine.CinemachineVirtualCameraBase
     */
    Bridge.define("Cinemachine.CinemachineClearShot", {
        inherits: [Cinemachine.CinemachineVirtualCameraBase],
        fields: {
            /**
             * Default object for the camera children to look at (the aim target), if not specified in a child camera.  May
                 be empty.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @type UnityEngine.Transform
             */
            m_LookAt: null,
            /**
             * Default object for the camera children wants to move with (the body target), if not specified in a child
                 camera.  May be empty.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @type UnityEngine.Transform
             */
            m_Follow: null,
            /**
             * When enabled, the current camera and blend will be indicated in the game window, for debugging
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @default false
             * @type boolean
             */
            m_ShowDebugText: false,
            /**
             * Internal API for the editor.  Do not use this filed.
             *
             * @instance
             * @memberof Cinemachine.CinemachineClearShot
             * @type Array.<Cinemachine.CinemachineVirtualCameraBase>
             */
            m_ChildCameras: null,
            /**
             * Wait this many seconds before activating a new child camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @type number
             */
            m_ActivateAfter: 0,
            /**
             * An active camera must be active for at least this many seconds
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @type number
             */
            m_MinDuration: 0,
            /**
             * If checked, camera choice will be randomized if multiple cameras are equally desirable.  Otherwise, child list
                 order will be used
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @default false
             * @type boolean
             */
            m_RandomizeChoice: false,
            /**
             * The blend which is used if you don't explicitly define a blend between two Virtual Cameras
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @type Cinemachine.CinemachineBlendDefinition
             */
            m_DefaultBlend: null,
            /**
             * This is the asset which contains custom settings for specific blends
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @type Cinemachine.CinemachineBlenderSettings
             */
            m_CustomBlends: null,
            /**
             * Get the current "best" child virtual camera, that would be chosen
                 if the ClearShot camera were active.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineClearShot
             * @function LiveChild
             * @type Cinemachine.ICinemachineCamera
             */
            LiveChild: null,
            m_State: null,
            mActivationTime: 0,
            mPendingActivationTime: 0,
            mPendingCamera: null,
            mActiveBlend: null,
            mRandomizeNow: false,
            m_RandomizedChilden: null,
            TransitioningFrom: null
        },
        props: {
            /**
             * Gets a brief debug description of this virtual camera, for use when displayiong debug info
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineClearShot
             * @function Description
             * @type string
             */
            Description: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#Description#get", this ); }

                    // Show the active camera and blend
                    if (this.mActiveBlend != null) {
                        return this.mActiveBlend.Description;
                    }

                    var vcam = this.LiveChild;
                    if (vcam == null) {
                        return "(none)";
                    }

                    var sb = Cinemachine.Utility.CinemachineDebug.SBFromPool();
                    sb.append("[");
                    sb.append(vcam.Cinemachine$ICinemachineCamera$Name);
                    sb.append("]");
                    var text = sb.toString();
                    Cinemachine.Utility.CinemachineDebug.ReturnToPool(sb);
                    return text;
                }
            },
            /**
             * The CameraState of the currently live child
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineClearShot
             * @function State
             * @type Cinemachine.CameraState
             */
            State: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#State#get", this ); }

                    return this.m_State.$clone();
                }
            },
            /**
             * Get the current LookAt target.  Returns parent's LookAt if parent
                 is non-null and no specific LookAt defined for this camera
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineClearShot
             * @function LookAt
             * @type UnityEngine.Transform
             */
            LookAt: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#LookAt#get", this ); }

                    return this.ResolveLookAt(this.m_LookAt);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#LookAt#set", this ); }

                    this.m_LookAt = value;
                }
            },
            /**
             * Get the current Follow target.  Returns parent's Follow if parent
                 is non-null and no specific Follow defined for this camera
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineClearShot
             * @function Follow
             * @type UnityEngine.Transform
             */
            Follow: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#Follow#get", this ); }

                    return this.ResolveFollow(this.m_Follow);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#Follow#set", this ); }

                    this.m_Follow = value;
                }
            },
            /**
             * Is there a blend in progress?
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineClearShot
             * @function IsBlending
             * @type boolean
             */
            IsBlending: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#IsBlending#get", this ); }

                    return this.mActiveBlend != null;
                }
            },
            /**
             * The list of child cameras.  These are just the immediate children in the hierarchy.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineClearShot
             * @function ChildCameras
             * @type Array.<Cinemachine.CinemachineVirtualCameraBase>
             */
            ChildCameras: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#ChildCameras#get", this ); }

                    this.UpdateListOfChildren();
                    return this.m_ChildCameras;
                }
            }
        },
        alias: [
            "Description", "Cinemachine$ICinemachineCamera$Description",
            "State", "Cinemachine$ICinemachineCamera$State",
            "IsLiveChild", "Cinemachine$ICinemachineCamera$IsLiveChild",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#init", this ); }

                this.m_DefaultBlend = new Cinemachine.CinemachineBlendDefinition();
                this.m_State = new Cinemachine.CameraState();
                this.m_ShowDebugText = false;
                this.m_RandomizeChoice = false;
                this.m_DefaultBlend = new Cinemachine.CinemachineBlendDefinition.$ctor1(Cinemachine.CinemachineBlendDefinition.Style.Cut, 0);
                this.m_State = Cinemachine.CameraState.Default.$clone();
            }
        },
        methods: {
            /*Cinemachine.CinemachineClearShot.IsLiveChild start.*/
            /**
             * Check whether the vcam a live child of this camera.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineClearShot
             * @memberof Cinemachine.CinemachineClearShot
             * @param   {Cinemachine.ICinemachineCamera}    vcam                 The Virtual Camera to check
             * @param   {boolean}                           dominantChildOnly    If truw, will only return true if this vcam is the dominat live child
             * @return  {boolean}                                                True if the vcam is currently actively influencing the state of this vcam
             */
            IsLiveChild: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#IsLiveChild", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                return Bridge.referenceEquals(vcam, this.LiveChild) || this.mActiveBlend != null && this.mActiveBlend.Uses(vcam);
            },
            /*Cinemachine.CinemachineClearShot.IsLiveChild end.*/

            /*Cinemachine.CinemachineClearShot.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the vcam that a target got warped,
                 so that the vcam can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineClearShot
             * @memberof Cinemachine.CinemachineClearShot
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#OnTargetObjectWarped", this ); }

                var $t;
                this.UpdateListOfChildren();
                $t = Bridge.getEnumerator(this.m_ChildCameras);
                try {
                    while ($t.moveNext()) {
                        var vcam = $t.Current;
                        vcam.OnTargetObjectWarped(target, positionDelta.$clone());
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
            },
            /*Cinemachine.CinemachineClearShot.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineClearShot.InternalUpdateCameraState start.*/
            /**
             * Internal use only.  Called by CinemachineCore at designated update time
                 so the vcam can position itself and track its targets.  This implementation
                 updates all the children, chooses the best one, and implements any required blending.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineClearShot
             * @memberof Cinemachine.CinemachineClearShot
             * @param   {UnityEngine.Vector3}    worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                 deltaTime    Delta time for time-based effects (ignore if less than 0)
             * @return  {void}
             */
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#InternalUpdateCameraState", this ); }

                // Choose the best camera
                this.UpdateListOfChildren();
                var previousCam = this.LiveChild;
                this.LiveChild = this.ChooseCurrentCamera(worldUp.$clone());

                // Are we transitioning cameras?
                if (!Bridge.referenceEquals(previousCam, this.LiveChild) && this.LiveChild != null) {
                    // Notify incoming camera of transition
                    this.LiveChild.Cinemachine$ICinemachineCamera$OnTransitionFromCamera(previousCam, worldUp.$clone(), deltaTime);

                    // Generate Camera Activation event in the brain if live
                    Cinemachine.CinemachineCore.Instance.GenerateCameraActivationEvent(this.LiveChild, previousCam);

                    // Are we transitioning cameras?
                    if (previousCam != null) {
                        // Create a blend (will be null if a cut)
                        this.mActiveBlend = this.CreateBlend(previousCam, this.LiveChild, this.LookupBlend(previousCam, this.LiveChild), this.mActiveBlend);

                        // If cutting, generate a camera cut event if live
                        if (this.mActiveBlend == null || !this.mActiveBlend.Uses(previousCam)) {
                            Cinemachine.CinemachineCore.Instance.GenerateCameraCutEvent(this.LiveChild);
                        }
                    }
                }

                // Advance the current blend (if any)
                if (this.mActiveBlend != null) {
                    this.mActiveBlend.TimeInBlend += deltaTime >= 0 ? deltaTime : this.mActiveBlend.Duration;
                    if (this.mActiveBlend.IsComplete) {
                        this.mActiveBlend = null;
                    }
                }

                if (this.mActiveBlend != null) {
                    this.mActiveBlend.UpdateCameraState(worldUp.$clone(), deltaTime);
                    this.m_State = this.mActiveBlend.State.$clone();
                } else if (this.LiveChild != null) {
                    if (this.TransitioningFrom != null) {
                        this.LiveChild.Cinemachine$ICinemachineCamera$OnTransitionFromCamera(this.TransitioningFrom, worldUp.$clone(), deltaTime);
                    }

                    this.m_State = this.LiveChild.Cinemachine$ICinemachineCamera$State.$clone();
                }

                this.TransitioningFrom = null;
                this.InvokePostPipelineStageCallback(this, Cinemachine.CinemachineCore.Stage.Finalize, Bridge.ref(this, "m_State"), deltaTime);
                this.PreviousStateIsValid = true;
            },
            /*Cinemachine.CinemachineClearShot.InternalUpdateCameraState end.*/

            /*Cinemachine.CinemachineClearShot.OnEnable start.*/
            /**
             * Makes sure the internal child cache is up to date
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineClearShot
             * @memberof Cinemachine.CinemachineClearShot
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#OnEnable", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnEnable.call(this);
                this.InvalidateListOfChildren();
                this.mActiveBlend = null;
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.remove(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.combine(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
            },
            /*Cinemachine.CinemachineClearShot.OnEnable end.*/

            /*Cinemachine.CinemachineClearShot.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#OnDisable", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnDisable.call(this);
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.remove(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
            },
            /*Cinemachine.CinemachineClearShot.OnDisable end.*/

            /*Cinemachine.CinemachineClearShot.OnTransformChildrenChanged start.*/
            /**
             * Makes sure the internal child cache is up to date
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineClearShot
             * @memberof Cinemachine.CinemachineClearShot
             * @return  {void}
             */
            OnTransformChildrenChanged: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#OnTransformChildrenChanged", this ); }

                this.InvalidateListOfChildren();
            },
            /*Cinemachine.CinemachineClearShot.OnTransformChildrenChanged end.*/

            /*Cinemachine.CinemachineClearShot.OnGuiHandler start.*/
            /**
             * @instance
             * @private
             * @this Cinemachine.CinemachineClearShot
             * @memberof Cinemachine.CinemachineClearShot
             * @return  {void}
             */
            OnGuiHandler: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#OnGuiHandler", this ); }

                if (!this.m_ShowDebugText) {
                    Cinemachine.Utility.CinemachineDebug.ReleaseScreenPos(this);
                } else {
                    var sb = Cinemachine.Utility.CinemachineDebug.SBFromPool();
                    sb.append(this.Name);
                    sb.append(": ");
                    sb.append(this.Description);
                    var text = sb.toString();
                    var r = Cinemachine.Utility.CinemachineDebug.GetScreenPos(this, text, UnityEngine.GUI.skin.box);
                    UnityEngine.GUI.Label$1(r.$clone(), text, UnityEngine.GUI.skin.box);
                    Cinemachine.Utility.CinemachineDebug.ReturnToPool(sb);
                }
            },
            /*Cinemachine.CinemachineClearShot.OnGuiHandler end.*/

            /*Cinemachine.CinemachineClearShot.InvalidateListOfChildren start.*/
            InvalidateListOfChildren: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#InvalidateListOfChildren", this ); }

                this.m_ChildCameras = null;
                this.m_RandomizedChilden = null;
                this.LiveChild = null;
            },
            /*Cinemachine.CinemachineClearShot.InvalidateListOfChildren end.*/

            /*Cinemachine.CinemachineClearShot.ResetRandomization start.*/
            /**
             * If RandomizeChoice is enabled, call this to re-randomize the children next frame.
                 This is useful if you want to freshen up the shot.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineClearShot
             * @memberof Cinemachine.CinemachineClearShot
             * @return  {void}
             */
            ResetRandomization: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#ResetRandomization", this ); }

                this.m_RandomizedChilden = null;
                this.mRandomizeNow = true;
            },
            /*Cinemachine.CinemachineClearShot.ResetRandomization end.*/

            /*Cinemachine.CinemachineClearShot.UpdateListOfChildren start.*/
            UpdateListOfChildren: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#UpdateListOfChildren", this ); }

                var $t;
                if (this.m_ChildCameras != null) {
                    return;
                }

                var list = new (System.Collections.Generic.List$1(Cinemachine.CinemachineVirtualCameraBase)).ctor();
                var kids = this.GetComponentsInChildren$1(Cinemachine.CinemachineVirtualCameraBase, true);
                $t = Bridge.getEnumerator(kids);
                try {
                    while ($t.moveNext()) {
                        var k = $t.Current;
                        if (UnityEngine.Component.op_Equality(k.transform.parent, this.transform)) {
                            list.add(k);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.m_ChildCameras = list.ToArray();

                // Zap the cached current instructions
                this.mActivationTime = (this.mPendingActivationTime = 0);
                this.mPendingCamera = null;
                this.LiveChild = null;
                this.mActiveBlend = null;
            },
            /*Cinemachine.CinemachineClearShot.UpdateListOfChildren end.*/

            /*Cinemachine.CinemachineClearShot.ChooseCurrentCamera start.*/
            ChooseCurrentCamera: function (worldUp) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#ChooseCurrentCamera", this ); }

                if (this.m_ChildCameras == null || this.m_ChildCameras.length === 0) {
                    this.mActivationTime = 0;
                    return null;
                }

                var childCameras = this.m_ChildCameras;
                if (!this.m_RandomizeChoice) {
                    this.m_RandomizedChilden = null;
                } else if (this.m_ChildCameras.length > 1) {
                    if (this.m_RandomizedChilden == null) {
                        this.m_RandomizedChilden = this.Randomize(this.m_ChildCameras);
                    }

                    childCameras = this.m_RandomizedChilden;
                }

                if (this.LiveChild != null && !this.LiveChild.Cinemachine$ICinemachineCamera$VirtualCameraGameObject.activeSelf) {
                    this.LiveChild = null;
                }

                var best = this.LiveChild;
                for (var i = 0; i < childCameras.length; ++i) {
                    var vcam = childCameras[i];
                    if (UnityEngine.MonoBehaviour.op_Inequality(vcam, null) && vcam.gameObject.activeInHierarchy) {
                        // Choose the first in the list that is better than the current
                        if (best == null || vcam.State.ShotQuality > best.Cinemachine$ICinemachineCamera$State.ShotQuality || vcam.State.ShotQuality === best.Cinemachine$ICinemachineCamera$State.ShotQuality && vcam.Priority > best.Cinemachine$ICinemachineCamera$Priority || this.m_RandomizeChoice && this.mRandomizeNow && !Bridge.referenceEquals(vcam, this.LiveChild) && vcam.State.ShotQuality === best.Cinemachine$ICinemachineCamera$State.ShotQuality && vcam.Priority === best.Cinemachine$ICinemachineCamera$Priority) {
                            best = vcam;
                        }
                    }
                }

                this.mRandomizeNow = false;

                var now = UnityEngine.Time.time;
                if (this.mActivationTime !== 0) {
                    // Is it active now?
                    if (Bridge.referenceEquals(this.LiveChild, best)) {
                        // Yes, cancel any pending
                        this.mPendingActivationTime = 0;
                        this.mPendingCamera = null;
                        return best;
                    }

                    // Is it pending?
                    if (this.PreviousStateIsValid) {
                        if (this.mPendingActivationTime !== 0 && Bridge.referenceEquals(this.mPendingCamera, best)) {
                            // Has it been pending long enough, and are we allowed to switch away
                            // from the active action?
                            if (now - this.mPendingActivationTime > this.m_ActivateAfter && now - this.mActivationTime > this.m_MinDuration) {
                                // Yes, activate it now
                                this.m_RandomizedChilden = null; // reshuffle the children
                                this.mActivationTime = now;
                                this.mPendingActivationTime = 0;
                                this.mPendingCamera = null;
                                return best;
                            }

                            return this.LiveChild;
                        }
                    }
                }

                // Neither active nor pending.
                this.mPendingActivationTime = 0; // cancel the pending, if any
                this.mPendingCamera = null;

                // Can we activate it now?
                if (this.PreviousStateIsValid && this.mActivationTime > 0) {
                    if (this.m_ActivateAfter > 0 || now - this.mActivationTime < this.m_MinDuration) {
                        // Too early - make it pending
                        this.mPendingCamera = best;
                        this.mPendingActivationTime = now;
                        return this.LiveChild;
                    }
                }

                // Activate now
                this.m_RandomizedChilden = null; // reshuffle the children
                this.mActivationTime = now;
                return best;
            },
            /*Cinemachine.CinemachineClearShot.ChooseCurrentCamera end.*/

            /*Cinemachine.CinemachineClearShot.Randomize start.*/
            Randomize: function (src) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#Randomize", this ); }

                var pairs = new (System.Collections.Generic.List$1(Cinemachine.CinemachineClearShot.Pair)).ctor();
                for (var i = 0; i < src.length; ++i) {
                    var p = new Cinemachine.CinemachineClearShot.Pair();
                    p.a = i;
                    p.b = UnityEngine.Random.Range$1(0, 1000.0);
                    pairs.add(p.$clone());
                }

                pairs.Sort$2(function (p1, p2) {
                    return p1.b - p2.b;
                });
                var dst = System.Array.init(src.length, null, Cinemachine.CinemachineVirtualCameraBase);
                var result = pairs.ToArray();
                for (var i1 = 0; i1 < src.length; ++i1) {
                    dst[i1] = src[result[i1].a];
                }

                return dst;
            },
            /*Cinemachine.CinemachineClearShot.Randomize end.*/

            /*Cinemachine.CinemachineClearShot.LookupBlend start.*/
            LookupBlend: function (fromKey, toKey) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#LookupBlend", this ); }

                // Get the blend curve that's most appropriate for these cameras
                var blend = this.m_DefaultBlend.$clone();
                if (this.m_CustomBlends != null) {
                    var fromCameraName = fromKey != null ? fromKey.Cinemachine$ICinemachineCamera$Name : "";
                    var toCameraName = toKey != null ? toKey.Cinemachine$ICinemachineCamera$Name : "";
                    blend = this.m_CustomBlends.GetBlendForVirtualCameras(fromCameraName, toCameraName, blend.$clone());
                }

                if (!Bridge.staticEquals(Cinemachine.CinemachineCore.GetBlendOverride, null)) {
                    blend = Cinemachine.CinemachineCore.GetBlendOverride(fromKey, toKey, blend.$clone(), this);
                }

                return blend.$clone();
            },
            /*Cinemachine.CinemachineClearShot.LookupBlend end.*/

            /*Cinemachine.CinemachineClearShot.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
                 This implementation resets the child randomization.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineClearShot
             * @memberof Cinemachine.CinemachineClearShot
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}               worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                            deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineClearShot#OnTransitionFromCamera", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTransitionFromCamera.call(this, fromCam, worldUp.$clone(), deltaTime);
                this.InvokeOnTransitionInExtensions(fromCam, worldUp.$clone(), deltaTime);
                this.TransitioningFrom = fromCam;
                if (this.m_RandomizeChoice && this.mActiveBlend == null) {
                    this.m_RandomizedChilden = null;
                    this.LiveChild = null;
                }

                this.InternalUpdateCameraState(worldUp.$clone(), deltaTime);
            },
            /*Cinemachine.CinemachineClearShot.OnTransitionFromCamera end.*/


        }
    });
    /*Cinemachine.CinemachineClearShot end.*/

    /*Cinemachine.CinemachineExternalCamera start.*/
    /**
     * This component will expose a non-cinemachine camera to the cinemachine system,
         allowing it to participate in blends.
         Just add it as a component alongside an existing Unity Camera component.
     *
     * @public
     * @class Cinemachine.CinemachineExternalCamera
     * @augments Cinemachine.CinemachineVirtualCameraBase
     */
    Bridge.define("Cinemachine.CinemachineExternalCamera", {
        inherits: [Cinemachine.CinemachineVirtualCameraBase],
        fields: {
            /**
             * The object that the camera is looking at.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineExternalCamera
             * @type UnityEngine.Transform
             */
            m_LookAt: null,
            m_Camera: null,
            m_State: null,
            /**
             * This vcam defines no targets
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineExternalCamera
             * @function Follow
             * @type UnityEngine.Transform
             */
            Follow: null,
            /**
             * Hint for blending positions to and from this virtual camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineExternalCamera
             * @type number
             */
            m_BlendHint: 0
        },
        props: {
            /**
             * Get the CameraState, as we are able to construct one from the Unity Camera
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineExternalCamera
             * @function State
             * @type Cinemachine.CameraState
             */
            State: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExternalCamera#State#get", this ); }

                    return this.m_State.$clone();
                }
            },
            /**
             * The object that the camera is looking at
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineExternalCamera
             * @function LookAt
             * @type UnityEngine.Transform
             */
            LookAt: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExternalCamera#LookAt#get", this ); }

                    return this.m_LookAt;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExternalCamera#LookAt#set", this ); }

                    this.m_LookAt = value;
                }
            }
        },
        alias: [
            "State", "Cinemachine$ICinemachineCamera$State",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExternalCamera#init", this ); }

                this.m_State = new Cinemachine.CameraState();
                this.m_State = Cinemachine.CameraState.Default.$clone();
                this.m_BlendHint = Cinemachine.CinemachineVirtualCameraBase.BlendHint.None;
            }
        },
        methods: {
            /*Cinemachine.CinemachineExternalCamera.InternalUpdateCameraState start.*/
            /**
             * Internal use only.  Do not call this method
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineExternalCamera
             * @memberof Cinemachine.CinemachineExternalCamera
             * @param   {UnityEngine.Vector3}    worldUp      
             * @param   {number}                 deltaTime
             * @return  {void}
             */
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineExternalCamera#InternalUpdateCameraState", this ); }

                // Get the state from the camera
                if (UnityEngine.Component.op_Equality(this.m_Camera, null)) {
                    this.m_Camera = this.GetComponent(UnityEngine.Camera);
                }

                this.m_State = Cinemachine.CameraState.Default.$clone();
                this.m_State.RawPosition = this.transform.position.$clone();
                this.m_State.RawOrientation = this.transform.rotation.$clone();
                this.m_State.ReferenceUp = this.m_State.RawOrientation.transformVector( pc.Vec3.UP.clone() );
                if (UnityEngine.Component.op_Inequality(this.m_Camera, null)) {
                    this.m_State.Lens = Cinemachine.LensSettings.FromCamera(this.m_Camera);
                }

                if (UnityEngine.Component.op_Inequality(this.m_LookAt, null)) {
                    this.m_State.ReferenceLookAt = this.m_LookAt.transform.position.$clone();
                    var dir = this.m_State.ReferenceLookAt.$clone().sub( this.State.RawPosition );
                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(dir)) {
                        this.m_State.ReferenceLookAt = this.m_State.RawPosition.$clone().add( dir.$clone().project( this.State.RawOrientation.transformVector( new pc.Vec3( 0, 0, 1 ) ) ) );
                    }
                }

                this.ApplyPositionBlendMethod(Bridge.ref(this, "m_State"), this.m_BlendHint);
                this.InvokePostPipelineStageCallback(this, Cinemachine.CinemachineCore.Stage.Finalize, Bridge.ref(this, "m_State"), deltaTime);
            },
            /*Cinemachine.CinemachineExternalCamera.InternalUpdateCameraState end.*/


        }
    });
    /*Cinemachine.CinemachineExternalCamera end.*/

    /*Cinemachine.CinemachineFixedSignal start.*/
    /**
     * A definition of an impulse signal that gets propagated to listeners
     *
     * @public
     * @class Cinemachine.CinemachineFixedSignal
     * @augments Cinemachine.SignalSourceAsset
     */
    Bridge.define("Cinemachine.CinemachineFixedSignal", {
        inherits: [Cinemachine.SignalSourceAsset],
        fields: {
            /**
             * The raw signal shape along the X axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFixedSignal
             * @type pc.AnimationCurve
             */
            m_XCurve: null,
            /**
             * The raw signal shape along the Y axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFixedSignal
             * @type pc.AnimationCurve
             */
            m_YCurve: null,
            /**
             * The raw signal shape along the Z axis
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFixedSignal
             * @type pc.AnimationCurve
             */
            m_ZCurve: null
        },
        props: {
            /**
             * Returns the length on seconds of the signal.
                 Returns 0 for signals of indeterminate length.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineFixedSignal
             * @function SignalDuration
             * @type number
             */
            SignalDuration: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFixedSignal#SignalDuration#get", this ); }

                    return UnityEngine.Mathf.Max(this.AxisDuration(this.m_XCurve), UnityEngine.Mathf.Max(this.AxisDuration(this.m_YCurve), this.AxisDuration(this.m_ZCurve)));
                }
            }
        },
        alias: [
            "SignalDuration", "Cinemachine$ISignalSource6D$SignalDuration",
            "GetSignal", "Cinemachine$ISignalSource6D$GetSignal"
        ],
        methods: {
            /*Cinemachine.CinemachineFixedSignal.AxisDuration start.*/
            AxisDuration: function (axis) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFixedSignal#AxisDuration", this ); }

                var duration = 0;
                if (axis != null && axis.keys.length > 1) {
                    var start = axis.keys[0].time;
                    duration = axis.keys[axis.keys.length - 1].time - start;
                }

                return duration;
            },
            /*Cinemachine.CinemachineFixedSignal.AxisDuration end.*/

            /*Cinemachine.CinemachineFixedSignal.GetSignal start.*/
            /**
             * Get the raw signal at this time
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineFixedSignal
             * @memberof Cinemachine.CinemachineFixedSignal
             * @param   {number}                    timeSinceSignalStart    The time since in seconds since the start of the signal
             * @param   {UnityEngine.Vector3}       pos                     The position impulse signal
             * @param   {UnityEngine.Quaternion}    rot                     The rotation impulse signal
             * @return  {void}
             */
            GetSignal: function (timeSinceSignalStart, pos, rot) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFixedSignal#GetSignal", this ); }

                rot.v = pc.Quat.IDENTITY.clone();
                pos.v = new pc.Vec3( this.AxisValue(this.m_XCurve, timeSinceSignalStart), this.AxisValue(this.m_YCurve, timeSinceSignalStart), this.AxisValue(this.m_ZCurve, timeSinceSignalStart) );
            },
            /*Cinemachine.CinemachineFixedSignal.GetSignal end.*/

            /*Cinemachine.CinemachineFixedSignal.AxisValue start.*/
            AxisValue: function (axis, time) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFixedSignal#AxisValue", this ); }

                if (axis == null || axis.keys.length === 0) {
                    return 0;
                }

                return axis.value(time);
            },
            /*Cinemachine.CinemachineFixedSignal.AxisValue end.*/


        }
    });
    /*Cinemachine.CinemachineFixedSignal end.*/
    /**
     * @memberof Cinemachine
     * @callback Cinemachine.CinemachineFreeLook.DestroyRigDelegate
     * @param   {UnityEngine.GameObject}    rig
     * @return  {void}
     */

    /**
     * @memberof Cinemachine
     * @callback Cinemachine.CinemachineFreeLook.CreateRigDelegate
     * @param   {Cinemachine.CinemachineFreeLook}         vcam        
     * @param   {string}                                  name        
     * @param   {Cinemachine.CinemachineVirtualCamera}    copyFrom
     * @return  {Cinemachine.CinemachineVirtualCamera}
     */


    /*Cinemachine.CinemachineFreeLook start.*/
    /**
     * A Cinemachine Camera geared towards a 3rd person camera experience.
         The camera orbits around its subject with three separate camera rigs defining
         rings around the target. Each rig has its own radius, height offset, composer,
         and lens settings.
         Depending on the camera's position along the spline connecting these three rigs,
         these settings are interpolated to give the final camera position and state.
     *
     * @public
     * @class Cinemachine.CinemachineFreeLook
     * @augments Cinemachine.CinemachineVirtualCameraBase
     */
    Bridge.define("Cinemachine.CinemachineFreeLook", {
        inherits: [Cinemachine.CinemachineVirtualCameraBase],
        statics: {
            fields: {
                /**
                 * Override component pipeline creation.
                     This needs to be done by the editor to support Undo.
                     The override must do exactly the same thing as the CreatePipeline method in this class.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineFreeLook
                 * @type Cinemachine.CinemachineFreeLook.CreateRigDelegate
                 */
                CreateRigOverride: null,
                /**
                 * Override component pipeline destruction.
                     This needs to be done by the editor to support Undo.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineFreeLook
                 * @type Cinemachine.CinemachineFreeLook.DestroyRigDelegate
                 */
                DestroyRigOverride: null
            },
            props: {
                /**
                 * Names of the 3 child rigs
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Cinemachine.CinemachineFreeLook
                 * @function RigNames
                 * @type Array.<string>
                 */
                RigNames: {
                    get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#RigNames#get", this ); }

                        return System.Array.init(["TopRig", "MiddleRig", "BottomRig"], System.String);
                    }
                }
            }
        },
        fields: {
            /**
             * Object for the camera children to look at (the aim target)
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type UnityEngine.Transform
             */
            m_LookAt: null,
            /**
             * Object for the camera children wants to move with (the body target)
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type UnityEngine.Transform
             */
            m_Follow: null,
            /**
             * If enabled, this lens setting will apply to all three child rigs, otherwise the child rig lens settings will
                 be used
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @default true
             * @type boolean
             */
            m_CommonLens: false,
            /**
             * Specifies the lens properties of this Virtual Camera.
                 This generally mirrors the Unity Camera's lens settings, and will be used to drive
                 the Unity camera when the vcam is active
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Cinemachine.LensSettings
             */
            m_Lens: null,
            /**
             * Collection of parameters that influence how this virtual camera transitions from
                 other virtual cameras
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Cinemachine.CinemachineVirtualCameraBase.TransitionParams
             */
            m_Transitions: null,
            /**
             * Legacy support
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineFreeLook
             * @type number
             */
            m_LegacyBlendHint: 0,
            /**
             * The Vertical axis.  Value is 0..1.  Chooses how to blend the child rigs
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Cinemachine.AxisState
             */
            m_YAxis: null,
            /**
             * Controls how automatic recentering of the Y axis is accomplished
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Cinemachine.AxisState.Recentering
             */
            m_YAxisRecentering: null,
            /**
             * The Horizontal axis.  Value is -180...180.  This is passed on to the rigs' OrbitalTransposer component
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Cinemachine.AxisState
             */
            m_XAxis: null,
            /**
             * The definition of Forward.  Camera will follow behind
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Cinemachine.CinemachineOrbitalTransposer.Heading
             */
            m_Heading: null,
            /**
             * Controls how automatic recentering of the X axis is accomplished
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Cinemachine.AxisState.Recentering
             */
            m_RecenterToTargetHeading: null,
            /**
             * The coordinate space to use when interpreting the offset from the target
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type number
             */
            m_BindingMode: 0,
            /**
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @default 0.2
             * @type number
             */
            m_SplineCurvature: 0,
            /**
             * The radius and height of the three orbiting rigs
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Array.<Cinemachine.CinemachineFreeLook.Orbit>
             */
            m_Orbits: null,
            m_LegacyHeadingBias: 0,
            mUseLegacyRigDefinitions: false,
            mIsDestroyed: false,
            m_State: null,
            /**
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineFreeLook
             * @type Array.<Cinemachine.CinemachineVirtualCamera>
             */
            m_Rigs: null,
            mOrbitals: null,
            mBlendA: null,
            mBlendB: null,
            CachedXAxisHeading: 0,
            m_CachedOrbits: null,
            m_CachedTension: 0,
            m_CachedKnots: null,
            m_CachedCtrl1: null,
            m_CachedCtrl2: null
        },
        props: {
            PreviousStateIsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#PreviousStateIsValid#get", this ); }

                    return Bridge.ensureBaseProperty(this, "PreviousStateIsValid").$Cinemachine$CinemachineVirtualCameraBase$PreviousStateIsValid;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#PreviousStateIsValid#set", this ); }

                    if (value === false) {
                        for (var i = 0; this.m_Rigs != null && i < this.m_Rigs.length; ++i) {
                            this.m_Rigs[i].PreviousStateIsValid = value;
                        }
                    }

                    Bridge.ensureBaseProperty(this, "PreviousStateIsValid").$Cinemachine$CinemachineVirtualCameraBase$PreviousStateIsValid = value;
                }
            },
            /**
             * The cacmera state, which will be a blend of the child rig states
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineFreeLook
             * @function State
             * @type Cinemachine.CameraState
             */
            State: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#State#get", this ); }

                    return this.m_State.$clone();
                }
            },
            /**
             * Get the current LookAt target.  Returns parent's LookAt if parent
                 is non-null and no specific LookAt defined for this camera
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineFreeLook
             * @function LookAt
             * @type UnityEngine.Transform
             */
            LookAt: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#LookAt#get", this ); }

                    return this.ResolveLookAt(this.m_LookAt);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#LookAt#set", this ); }

                    this.m_LookAt = value;
                }
            },
            /**
             * Get the current Follow target.  Returns parent's Follow if parent
                 is non-null and no specific Follow defined for this camera
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineFreeLook
             * @function Follow
             * @type UnityEngine.Transform
             */
            Follow: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#Follow#get", this ); }

                    return this.ResolveFollow(this.m_Follow);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#Follow#set", this ); }

                    this.m_Follow = value;
                }
            }
        },
        alias: [
            "State", "Cinemachine$ICinemachineCamera$State",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "IsLiveChild", "Cinemachine$ICinemachineCamera$IsLiveChild",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#init", this ); }

                this.m_Lens = new Cinemachine.LensSettings();
                this.m_Transitions = new Cinemachine.CinemachineVirtualCameraBase.TransitionParams();
                this.m_YAxis = new Cinemachine.AxisState();
                this.m_YAxisRecentering = new Cinemachine.AxisState.Recentering();
                this.m_XAxis = new Cinemachine.AxisState();
                this.m_Heading = new Cinemachine.CinemachineOrbitalTransposer.Heading();
                this.m_RecenterToTargetHeading = new Cinemachine.AxisState.Recentering();
                this.m_State = new Cinemachine.CameraState();
                this.m_CommonLens = true;
                this.m_Lens = Cinemachine.LensSettings.Default.$clone();
                this.m_YAxis = new Cinemachine.AxisState.$ctor1(0, 1, false, true, 2.0, 0.2, 0.1, "Mouse Y", false);
                this.m_YAxisRecentering = new Cinemachine.AxisState.Recentering.$ctor1(false, 1, 2);
                this.m_XAxis = new Cinemachine.AxisState.$ctor1(-180, 180, true, false, 300.0, 0.1, 0.1, "Mouse X", true);
                this.m_Heading = new Cinemachine.CinemachineOrbitalTransposer.Heading.$ctor1(Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.TargetForward, 4, 0);
                this.m_RecenterToTargetHeading = new Cinemachine.AxisState.Recentering.$ctor1(false, 1, 2);
                this.m_BindingMode = Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp;
                this.m_SplineCurvature = 0.2;
                this.m_Orbits = System.Array.init([new Cinemachine.CinemachineFreeLook.Orbit.$ctor1(4.5, 1.75), new Cinemachine.CinemachineFreeLook.Orbit.$ctor1(2.5, 3.0), new Cinemachine.CinemachineFreeLook.Orbit.$ctor1(0.4, 1.3)], Cinemachine.CinemachineFreeLook.Orbit);
                this.m_LegacyHeadingBias = 3.40282347E+38;
                this.m_State = Cinemachine.CameraState.Default.$clone();
                this.m_Rigs = System.Array.init(3, null, Cinemachine.CinemachineVirtualCamera);
            }
        },
        methods: {
            /*Cinemachine.CinemachineFreeLook.OnValidate start.*/
            /**
             * Enforce bounds for fields, when changed in inspector.
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @return  {void}
             */
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#OnValidate", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnValidate.call(this);

                // Upgrade after a legacy deserialize
                if (this.m_LegacyHeadingBias !== 3.40282347E+38) {
                    this.m_Heading.m_Bias = this.m_LegacyHeadingBias;
                    this.m_LegacyHeadingBias = 3.40282347E+38;
                    var heading = { v : this.m_Heading.m_Definition };
                    if (this.m_RecenterToTargetHeading.LegacyUpgrade(heading, Bridge.ref(this.m_Heading, "m_VelocityFilterStrength"))) {
                        this.m_Heading.m_Definition = heading.v;
                    }

                    this.mUseLegacyRigDefinitions = true;
                }

                if (this.m_LegacyBlendHint !== Cinemachine.CinemachineVirtualCameraBase.BlendHint.None) {
                    this.m_Transitions.m_BlendHint = this.m_LegacyBlendHint;
                    this.m_LegacyBlendHint = Cinemachine.CinemachineVirtualCameraBase.BlendHint.None;
                }

                this.m_YAxis.Validate();
                this.m_XAxis.Validate();
                this.m_RecenterToTargetHeading.Validate();
                this.m_YAxisRecentering.Validate();
                this.m_Lens.Validate();

                this.InvalidateRigCache();
            },
            /*Cinemachine.CinemachineFreeLook.OnValidate end.*/

            /*Cinemachine.CinemachineFreeLook.GetRig start.*/
            /**
             * Get a child rig
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @param   {number}                                  i    Rig index.  Can be 0, 1, or 2
             * @return  {Cinemachine.CinemachineVirtualCamera}         The rig, or null if index is bad.
             */
            GetRig: function (i) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#GetRig", this ); }

                this.UpdateRigCache();
                return i < 0 || i > 2 ? null : this.m_Rigs[i];
            },
            /*Cinemachine.CinemachineFreeLook.GetRig end.*/

            /*Cinemachine.CinemachineFreeLook.OnEnable start.*/
            /**
             * Updates the child rig cache
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#OnEnable", this ); }

                this.mIsDestroyed = false;
                Cinemachine.CinemachineVirtualCameraBase.prototype.OnEnable.call(this);
                this.InvalidateRigCache();
            },
            /*Cinemachine.CinemachineFreeLook.OnEnable end.*/

            /*Cinemachine.CinemachineFreeLook.OnDestroy start.*/
            /**
             * Makes sure that the child rigs get destroyed in an undo-firndly manner.
                 Invalidates the rig cache.
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @return  {void}
             */
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#OnDestroy", this ); }

                var $t, $t1;
                // Make the rigs visible instead of destroying - this is to keep Undo happy
                if (this.m_Rigs != null) {
                    $t = Bridge.getEnumerator(this.m_Rigs);
                    try {
                        while ($t.moveNext()) {
                            var rig = $t.Current;
                            if (UnityEngine.MonoBehaviour.op_Inequality(rig, null) && UnityEngine.GameObject.op_Inequality(rig.gameObject, null)) {
                                $t1 = rig.gameObject;
                                $t1.hideFlags &= -4;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.mIsDestroyed = true;
                Cinemachine.CinemachineVirtualCameraBase.prototype.OnDestroy.call(this);
            },
            /*Cinemachine.CinemachineFreeLook.OnDestroy end.*/

            /*Cinemachine.CinemachineFreeLook.OnTransformChildrenChanged start.*/
            /**
             * Invalidates the rig cache
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @return  {void}
             */
            OnTransformChildrenChanged: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#OnTransformChildrenChanged", this ); }

                this.InvalidateRigCache();
            },
            /*Cinemachine.CinemachineFreeLook.OnTransformChildrenChanged end.*/

            /*Cinemachine.CinemachineFreeLook.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#Reset", this ); }

                this.DestroyRigs();
            },
            /*Cinemachine.CinemachineFreeLook.Reset end.*/

            /*Cinemachine.CinemachineFreeLook.IsLiveChild start.*/
            /**
             * Check whether the vcam a live child of this camera.
                 Returns true if the child is currently contributing actively to the camera state.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @param   {Cinemachine.ICinemachineCamera}    vcam                 The Virtual Camera to check
             * @param   {boolean}                           dominantChildOnly    If truw, will only return true if this vcam is the dominat live child
             * @return  {boolean}                                                True if the vcam is currently actively influencing the state of this vcam
             */
            IsLiveChild: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#IsLiveChild", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                // Do not update the rig cache here or there will be infinite loop at creation time
                if (this.m_Rigs == null || this.m_Rigs.length !== 3) {
                    return false;
                }

                var y = this.GetYAxisValue();
                if (dominantChildOnly) {
                    if (Bridge.referenceEquals(vcam, this.m_Rigs[0])) {
                        return y > 0.666;
                    }

                    if (Bridge.referenceEquals(vcam, this.m_Rigs[2])) {
                        return y < 0.333;
                    }

                    if (Bridge.referenceEquals(vcam, this.m_Rigs[1])) {
                        return y >= 0.333 && y <= 0.666;
                    }

                    return false;
                }

                if (Bridge.referenceEquals(vcam, this.m_Rigs[1])) {
                    return true;
                }

                if (y < 0.5) {
                    return Bridge.referenceEquals(vcam, this.m_Rigs[2]);
                }

                return Bridge.referenceEquals(vcam, this.m_Rigs[0]);
            },
            /*Cinemachine.CinemachineFreeLook.IsLiveChild end.*/

            /*Cinemachine.CinemachineFreeLook.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the vcam that a target got warped,
                 so that the vcam can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#OnTargetObjectWarped", this ); }

                var $t;
                this.UpdateRigCache();
                if (this.m_Rigs != null) {
                    $t = Bridge.getEnumerator(this.m_Rigs);
                    try {
                        while ($t.moveNext()) {
                            var vcam = $t.Current;
                            vcam.OnTargetObjectWarped(target, positionDelta.$clone());
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
            },
            /*Cinemachine.CinemachineFreeLook.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineFreeLook.InternalUpdateCameraState start.*/
            /**
             * Internal use only.  Called by CinemachineCore at designated update time
                 so the vcam can position itself and track its targets.  All 3 child rigs are updated,
                 and a blend calculated, depending on the value of the Y axis.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @param   {UnityEngine.Vector3}    worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                 deltaTime    Delta time for time-based effects (ignore if less than 0)
             * @return  {void}
             */
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#InternalUpdateCameraState", this ); }

                this.UpdateRigCache();

                // Update the current state by invoking the component pipeline
                this.m_State = this.CalculateNewState(worldUp.$clone(), deltaTime);
                this.ApplyPositionBlendMethod(Bridge.ref(this, "m_State"), this.m_Transitions.m_BlendHint);

                // Push the raw position back to the game object's transform, so it
                // moves along with the camera.  Leave the orientation alone, because it
                // screws up camera dragging when there is a LookAt behaviour.
                if (UnityEngine.Component.op_Inequality(this.Follow, null)) {
                    var delta = this.State.RawPosition.$clone().sub( this.transform.position );
                    this.transform.position = this.State.RawPosition.$clone();
                    this.m_Rigs[0].transform.position = this.m_Rigs[0].transform.position.$clone().sub( delta.$clone() );
                    this.m_Rigs[1].transform.position = this.m_Rigs[1].transform.position.$clone().sub( delta.$clone() );
                    this.m_Rigs[2].transform.position = this.m_Rigs[2].transform.position.$clone().sub( delta.$clone() );
                }

                this.InvokePostPipelineStageCallback(this, Cinemachine.CinemachineCore.Stage.Finalize, Bridge.ref(this, "m_State"), deltaTime);
                this.PreviousStateIsValid = true;

                // Set up for next frame
                var activeCam = this.PreviousStateIsValid && Cinemachine.CinemachineCore.Instance.IsLive(this);
                if (activeCam && deltaTime >= 0) {
                    if (this.m_YAxis.Update(deltaTime)) {
                        this.m_YAxisRecentering.CancelRecentering();
                    }
                }

                this.PushSettingsToRigs();
                if (this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                    this.m_XAxis.Value = 0;
                }
            },
            /*Cinemachine.CinemachineFreeLook.InternalUpdateCameraState end.*/

            /*Cinemachine.CinemachineFreeLook.OnTransitionFromCamera start.*/
            /**
             * If we are transitioning from another FreeLook, grab the axis values from it.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}               worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                            deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#OnTransitionFromCamera", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTransitionFromCamera.call(this, fromCam, worldUp.$clone(), deltaTime);
                this.InvokeOnTransitionInExtensions(fromCam, worldUp.$clone(), deltaTime);
                var forceUpdate = false;
                //            m_RecenterToTargetHeading.DoRecentering(ref m_XAxis, -1, 0);
                //              m_YAxis.m_Recentering.DoRecentering(ref m_YAxis, -1, 0.5f);
                //            m_RecenterToTargetHeading.CancelRecentering();
                //            m_YAxis.m_Recentering.CancelRecentering();
                if (fromCam != null && this.m_Transitions.m_InheritPosition) {
                    var cameraPos = fromCam.Cinemachine$ICinemachineCamera$State.RawPosition.$clone();

                    // Special handling for FreeLook: get an undamped outgoing position
                    if (Bridge.is(fromCam, Cinemachine.CinemachineFreeLook)) {
                        var flFrom = Bridge.as(fromCam, Cinemachine.CinemachineFreeLook);
                        var orbital = flFrom.mOrbitals != null ? flFrom.mOrbitals[1] : null;
                        if (UnityEngine.MonoBehaviour.op_Inequality(orbital, null)) {
                            cameraPos = orbital.GetTargetCameraPosition(worldUp.$clone());
                        }
                    }

                    this.UpdateRigCache();
                    if (this.m_BindingMode !== Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                        this.m_XAxis.Value = this.mOrbitals[1].GetAxisClosestValue(cameraPos.$clone(), worldUp.$clone());
                    }

                    this.m_YAxis.Value = this.GetYAxisClosestValue(cameraPos.$clone(), worldUp.$clone());

                    this.transform.position = cameraPos.$clone();
                    this.transform.rotation = fromCam.Cinemachine$ICinemachineCamera$State.RawOrientation.$clone();
                    this.m_State = this.PullStateFromVirtualCamera(worldUp.$clone(), Bridge.ref(this, "m_Lens"));
                    this.PreviousStateIsValid = false;
                    this.PushSettingsToRigs();
                    forceUpdate = true;
                }

                if (forceUpdate) {
                    for (var i = 0; i < 3; ++i) {
                        this.m_Rigs[i].InternalUpdateCameraState(worldUp.$clone(), deltaTime);
                    }

                    this.InternalUpdateCameraState(worldUp.$clone(), deltaTime);
                } else {
                    this.UpdateCameraState(worldUp.$clone(), deltaTime);
                }

                if (this.m_Transitions.m_OnCameraLive != null) {
                    this.m_Transitions.m_OnCameraLive.Invoke(this, fromCam);
                }
            },
            /*Cinemachine.CinemachineFreeLook.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineFreeLook.GetYAxisClosestValue start.*/
            GetYAxisClosestValue: function (cameraPos, up) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#GetYAxisClosestValue", this ); }

                if (UnityEngine.Component.op_Inequality(this.Follow, null)) {
                    // Rotate the camera pos to the back
                    var q = new pc.Quat().fromTo( up, pc.Vec3.UP.clone() );
                    var dir = q.transformVector( (cameraPos.$clone().sub( this.Follow.position )) );
                    var flatDir = dir.$clone();
                    flatDir.y = 0;
                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(flatDir)) {
                        var angle = pc.Vec3.signedAngle( flatDir, new pc.Vec3( 0, 0, -1 ), pc.Vec3.UP.clone() );
                        dir = new pc.Quat().setFromAxisAngle( pc.Vec3.UP.clone(), angle ).transformVector( dir );
                    }

                    dir.x = 0;

                    // Sample the spline in a few places, find the 2 closest, and lerp
                    var i0 = 0, i1 = 0;
                    var a0 = 0, a1 = 0;
                    var NumSamples = 13;
                    var step = 0.0833333358;
                    for (var i = 0; i < NumSamples; ++i) {
                        var a = pc.Vec3.signedAngle( dir, this.GetLocalPositionForCameraFromInput(i * step), pc.Vec3.RIGHT.clone() );
                        if (i === 0) {
                            a0 = (a1 = a);
                        } else {
                            if (Math.abs(a) < Math.abs(a0)) {
                                a1 = a0;
                                i1 = i0;
                                a0 = a;
                                i0 = i;
                            } else if (Math.abs(a) < Math.abs(a1)) {
                                a1 = a;
                                i1 = i;
                            }
                        }
                    }

                    if ((a0 === 0 ? 1 : Math.sign(a0)) === (a1 === 0 ? 1 : Math.sign(a1))) {
                        return i0 * step;
                    }

                    var t = Math.abs(a0) / (Math.abs(a0) + Math.abs(a1));
                    return pc.math.lerp(i0 * step, i1 * step, t);
                }

                return this.m_YAxis.Value; // stay conservative
            },
            /*Cinemachine.CinemachineFreeLook.GetYAxisClosestValue end.*/

            /*Cinemachine.CinemachineFreeLook.InvalidateRigCache start.*/
            InvalidateRigCache: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#InvalidateRigCache", this ); }

                this.mOrbitals = null;
            },
            /*Cinemachine.CinemachineFreeLook.InvalidateRigCache end.*/

            /*Cinemachine.CinemachineFreeLook.DestroyRigs start.*/
            DestroyRigs: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#DestroyRigs", this ); }

                var $t, $t1;
                var oldRigs = System.Array.init(Cinemachine.CinemachineFreeLook.RigNames.length, null, Cinemachine.CinemachineVirtualCamera);
                for (var i = 0; i < Cinemachine.CinemachineFreeLook.RigNames.length; ++i) {
                    $t = Bridge.getEnumerator(this.transform);
                    try {
                        while ($t.moveNext()) {
                            var child = Bridge.cast($t.Current, UnityEngine.Transform);
                            if (Bridge.referenceEquals(child.gameObject.name, ($t1 = Cinemachine.CinemachineFreeLook.RigNames)[i])) {
                                oldRigs[i] = child.GetComponent(Cinemachine.CinemachineVirtualCamera);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                for (var i1 = 0; i1 < oldRigs.length; ++i1) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(oldRigs[i1], null)) {
                        if (!Bridge.staticEquals(Cinemachine.CinemachineFreeLook.DestroyRigOverride, null)) {
                            Cinemachine.CinemachineFreeLook.DestroyRigOverride(oldRigs[i1].gameObject);
                        } else {
                            UnityEngine.MonoBehaviour.Destroy(oldRigs[i1].gameObject);
                        }
                    }
                }

                this.m_Rigs = null;
                this.mOrbitals = null;
            },
            /*Cinemachine.CinemachineFreeLook.DestroyRigs end.*/

            /*Cinemachine.CinemachineFreeLook.CreateRigs start.*/
            CreateRigs: function (copyFrom) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#CreateRigs", this ); }

                var $t, $t1;
                // Invalidate the cache
                this.mOrbitals = null;
                var softCenterDefaultsV = System.Array.init([
                    0.5, 
                    0.55, 
                    0.6
                ], System.Single);
                var newRigs = System.Array.init(3, null, Cinemachine.CinemachineVirtualCamera);
                for (var i = 0; i < Cinemachine.CinemachineFreeLook.RigNames.length; ++i) {
                    var src = null;
                    if (copyFrom != null && copyFrom.length > i) {
                        src = copyFrom[i];
                    }

                    if (!Bridge.staticEquals(Cinemachine.CinemachineFreeLook.CreateRigOverride, null)) {
                        newRigs[i] = Cinemachine.CinemachineFreeLook.CreateRigOverride(this, ($t = Cinemachine.CinemachineFreeLook.RigNames)[i], src);
                    } else {
                        // Create a new rig with default components
                        // Note: copyFrom only supported in Editor, not build
                        var go = new UnityEngine.GameObject.$ctor2(($t1 = Cinemachine.CinemachineFreeLook.RigNames)[i]);
                        go.transform.parent = this.transform;
                        newRigs[i] = go.AddComponent(Cinemachine.CinemachineVirtualCamera);
                        go = newRigs[i].GetComponentOwner().gameObject;
                        go.AddComponent(Cinemachine.CinemachineOrbitalTransposer);
                        go.AddComponent(Cinemachine.CinemachineComposer);
                    }

                    // Set up the defaults
                    newRigs[i].InvalidateComponentPipeline();
                    var orbital = newRigs[i].GetCinemachineComponent(Cinemachine.CinemachineOrbitalTransposer);
                    if (UnityEngine.MonoBehaviour.op_Equality(orbital, null)) {
                        orbital = newRigs[i].AddCinemachineComponent(Cinemachine.CinemachineOrbitalTransposer); // should not happen
                    }

                    if (UnityEngine.MonoBehaviour.op_Equality(src, null)) {
                        // Only set defaults if not copying
                        orbital.m_YawDamping = 0;
                        var composer = newRigs[i].GetCinemachineComponent(Cinemachine.CinemachineComposer);
                        if (UnityEngine.MonoBehaviour.op_Inequality(composer, null)) {
                            composer.m_HorizontalDamping = (composer.m_VerticalDamping = 0);
                            composer.m_ScreenX = 0.5;
                            composer.m_ScreenY = softCenterDefaultsV[i];
                            composer.m_DeadZoneWidth = (composer.m_DeadZoneHeight = 0.0);
                            composer.m_SoftZoneWidth = (composer.m_SoftZoneHeight = 0.8);
                            composer.m_BiasX = (composer.m_BiasY = 0);
                        }
                    }
                }

                return newRigs;
            },
            /*Cinemachine.CinemachineFreeLook.CreateRigs end.*/

            /*Cinemachine.CinemachineFreeLook.UpdateRigCache start.*/
            UpdateRigCache: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#UpdateRigCache", this ); }

                if (this.mIsDestroyed) {
                    return;
                }

                var isPrefab = false;


                // Early out if we're up to date
                if (this.mOrbitals != null && this.mOrbitals.length === 3) {
                    return;
                }

                // Locate existing rigs, and recreate them if any are missing
                isPrefab = this.gameObject.scene.name == null; // causes a small GC alloc
                if (this.LocateExistingRigs(Cinemachine.CinemachineFreeLook.RigNames, false) !== 3 && !isPrefab) {
                    this.DestroyRigs();
                    this.m_Rigs = this.CreateRigs(null);
                    this.LocateExistingRigs(Cinemachine.CinemachineFreeLook.RigNames, true);
                }


                // Create the blend objects
                this.mBlendA = new Cinemachine.CinemachineBlend(this.m_Rigs[1], this.m_Rigs[0], pc.AnimationCurve.createLinear(0, 0, 1, 1), 1, 0);
                this.mBlendB = new Cinemachine.CinemachineBlend(this.m_Rigs[2], this.m_Rigs[1], pc.AnimationCurve.createLinear(0, 0, 1, 1), 1, 0);
            },
            /*Cinemachine.CinemachineFreeLook.UpdateRigCache end.*/

            /*Cinemachine.CinemachineFreeLook.LocateExistingRigs start.*/
            LocateExistingRigs: function (rigNames, forceOrbital) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#LocateExistingRigs", this ); }

                var $t;
                this.CachedXAxisHeading = 0;
                this.mOrbitals = System.Array.init(rigNames.length, null, Cinemachine.CinemachineOrbitalTransposer);
                this.m_Rigs = System.Array.init(rigNames.length, null, Cinemachine.CinemachineVirtualCamera);
                var rigsFound = 0;
                $t = Bridge.getEnumerator(this.transform);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, UnityEngine.Transform);
                        var vcam = child.GetComponent(Cinemachine.CinemachineVirtualCamera);
                        if (UnityEngine.MonoBehaviour.op_Inequality(vcam, null)) {
                            var go = child.gameObject;
                            for (var i = 0; i < rigNames.length; ++i) {
                                if (UnityEngine.MonoBehaviour.op_Equality(this.mOrbitals[i], null) && Bridge.referenceEquals(go.name, rigNames[i])) {
                                    // Must have an orbital transposer or it's no good
                                    this.mOrbitals[i] = vcam.GetCinemachineComponent(Cinemachine.CinemachineOrbitalTransposer);
                                    if (UnityEngine.MonoBehaviour.op_Equality(this.mOrbitals[i], null) && forceOrbital) {
                                        this.mOrbitals[i] = vcam.AddCinemachineComponent(Cinemachine.CinemachineOrbitalTransposer);
                                    }

                                    if (UnityEngine.MonoBehaviour.op_Inequality(this.mOrbitals[i], null)) {
                                        this.mOrbitals[i].m_HeadingIsSlave = true;
                                        this.mOrbitals[i].m_XAxis.m_InputAxisName = "";
                                        this.mOrbitals[i].HeadingUpdater = Bridge.fn.cacheBind(this, this.UpdateXAxisHeading);
                                        this.mOrbitals[i].m_RecenterToTargetHeading.m_enabled = false;
                                        this.m_Rigs[i] = vcam;
                                        this.m_Rigs[i].m_StandbyUpdate = this.m_StandbyUpdate;
                                        ++rigsFound;
                                    }
                                }
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return rigsFound;
            },
            /*Cinemachine.CinemachineFreeLook.LocateExistingRigs end.*/

            /*Cinemachine.CinemachineFreeLook.UpdateXAxisHeading start.*/
            UpdateXAxisHeading: function (orbital, deltaTime, up) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#UpdateXAxisHeading", this ); }

                if (this.mOrbitals != null && UnityEngine.MonoBehaviour.op_Equality(this.mOrbitals[1], orbital)) {
                    var oldValue = this.m_XAxis.Value;
                    this.CachedXAxisHeading = orbital.UpdateHeading$1(this.PreviousStateIsValid ? deltaTime : -1, up.$clone(), Bridge.ref(this, "m_XAxis"), Bridge.ref(this, "m_RecenterToTargetHeading"), Cinemachine.CinemachineCore.Instance.IsLive(this));
                    // Allow externally-driven values to work in this mode
                    if (this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                        this.m_XAxis.Value = oldValue;
                    }
                }

                return this.CachedXAxisHeading;
            },
            /*Cinemachine.CinemachineFreeLook.UpdateXAxisHeading end.*/

            /*Cinemachine.CinemachineFreeLook.PushSettingsToRigs start.*/
            PushSettingsToRigs: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#PushSettingsToRigs", this ); }

                this.UpdateRigCache();
                for (var i = 0; i < this.m_Rigs.length; ++i) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_Rigs[i], null)) {
                        continue;
                    }

                    if (this.m_CommonLens) {
                        this.m_Rigs[i].m_Lens = this.m_Lens.$clone();
                    }

                    // If we just deserialized from a legacy version,
                    // pull the orbits and targets from the rigs
                    if (this.mUseLegacyRigDefinitions) {
                        this.mUseLegacyRigDefinitions = false;
                        this.m_Orbits[i].m_Height = this.mOrbitals[i].m_FollowOffset.y;
                        this.m_Orbits[i].m_Radius = -this.mOrbitals[i].m_FollowOffset.z;
                        if (UnityEngine.Component.op_Inequality(this.m_Rigs[i].Follow, null)) {
                            this.Follow = this.m_Rigs[i].Follow;
                        }
                    }

                    this.m_Rigs[i].Follow = null;
                    this.m_Rigs[i].m_StandbyUpdate = this.m_StandbyUpdate;
                    if (!this.PreviousStateIsValid) {
                        this.m_Rigs[i].PreviousStateIsValid = false;
                        this.m_Rigs[i].transform.position = this.transform.position.$clone();
                        this.m_Rigs[i].transform.rotation = this.transform.rotation.$clone();
                    }
                    this.mOrbitals[i].m_FollowOffset = this.GetLocalPositionForCameraFromInput(this.GetYAxisValue());
                    this.mOrbitals[i].m_BindingMode = this.m_BindingMode;
                    this.mOrbitals[i].m_Heading = this.m_Heading.$clone();
                    this.mOrbitals[i].m_XAxis.Value = this.m_XAxis.Value;

                    // Hack to get SimpleFollow with heterogeneous dampings to work
                    if (this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                        this.m_Rigs[i].SetStateRawPosition(this.State.RawPosition.$clone());
                    }
                }
            },
            /*Cinemachine.CinemachineFreeLook.PushSettingsToRigs end.*/

            /*Cinemachine.CinemachineFreeLook.GetYAxisValue start.*/
            GetYAxisValue: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#GetYAxisValue", this ); }

                var range = this.m_YAxis.m_MaxValue - this.m_YAxis.m_MinValue;
                return range > Cinemachine.Utility.UnityVectorExtensions.Epsilon ? this.m_YAxis.Value / range : 0.5;
            },
            /*Cinemachine.CinemachineFreeLook.GetYAxisValue end.*/

            /*Cinemachine.CinemachineFreeLook.CalculateNewState start.*/
            CalculateNewState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#CalculateNewState", this ); }

                var state = this.PullStateFromVirtualCamera(worldUp.$clone(), Bridge.ref(this, "m_Lens"));
                this.m_YAxisRecentering.DoRecentering(Bridge.ref(this, "m_YAxis"), deltaTime, 0.5);

                // Blend from the appropriate rigs
                var t = this.GetYAxisValue();
                if (t > 0.5) {
                    if (this.mBlendA != null) {
                        this.mBlendA.TimeInBlend = (t - 0.5) * 2.0;
                        this.mBlendA.UpdateCameraState(worldUp.$clone(), deltaTime);
                        state = this.mBlendA.State.$clone();
                    }
                } else {
                    if (this.mBlendB != null) {
                        this.mBlendB.TimeInBlend = t * 2.0;
                        this.mBlendB.UpdateCameraState(worldUp.$clone(), deltaTime);
                        state = this.mBlendB.State.$clone();
                    }
                }

                return state.$clone();
            },
            /*Cinemachine.CinemachineFreeLook.CalculateNewState end.*/

            /*Cinemachine.CinemachineFreeLook.GetLocalPositionForCameraFromInput start.*/
            /**
             * Returns the local position of the camera along the spline used to connect the
                 three camera rigs. Does not take into account the current heading of the
                 camera (or its target)
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineFreeLook
             * @memberof Cinemachine.CinemachineFreeLook
             * @param   {number}                 t    The t-value for the camera on its spline. Internally clamped to
                 the value [0,1]
             * @return  {UnityEngine.Vector3}         The local offset (back + up) of the camera WRT its target based on the
                 supplied t-value
             */
            GetLocalPositionForCameraFromInput: function (t) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#GetLocalPositionForCameraFromInput", this ); }

                if (this.mOrbitals == null) {
                    return pc.Vec3.ZERO.clone();
                }

                this.UpdateCachedSpline();
                var n = 1;
                if (t > 0.5) {
                    t -= 0.5;
                    n = 2;
                }

                return Cinemachine.Utility.SplineHelpers.Bezier3(t * 2.0, UnityEngine.Vector3.FromVector4(this.m_CachedKnots[n].$clone()), UnityEngine.Vector3.FromVector4(this.m_CachedCtrl1[n].$clone()), UnityEngine.Vector3.FromVector4(this.m_CachedCtrl2[n].$clone()), UnityEngine.Vector3.FromVector4(this.m_CachedKnots[n + 1].$clone()));
            },
            /*Cinemachine.CinemachineFreeLook.GetLocalPositionForCameraFromInput end.*/

            /*Cinemachine.CinemachineFreeLook.UpdateCachedSpline start.*/
            UpdateCachedSpline: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineFreeLook#UpdateCachedSpline", this ); }

                var cacheIsValid = this.m_CachedOrbits != null && this.m_CachedOrbits.length === 3 && this.m_CachedTension === this.m_SplineCurvature;
                for (var i = 0; i < 3 && cacheIsValid; ++i) {
                    cacheIsValid = this.m_CachedOrbits[i].m_Height === this.m_Orbits[i].m_Height && this.m_CachedOrbits[i].m_Radius === this.m_Orbits[i].m_Radius;
                }

                if (!cacheIsValid) {
                    var t = this.m_SplineCurvature;
                    this.m_CachedKnots = System.Array.init(5, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4);
                    this.m_CachedCtrl1 = System.Array.init(5, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4);
                    this.m_CachedCtrl2 = System.Array.init(5, function (){
                        return new UnityEngine.Vector4();
                    }, UnityEngine.Vector4);
                    this.m_CachedKnots[1] = new pc.Vec4( 0, this.m_Orbits[2].m_Height, -this.m_Orbits[2].m_Radius, 0 );
                    this.m_CachedKnots[2] = new pc.Vec4( 0, this.m_Orbits[1].m_Height, -this.m_Orbits[1].m_Radius, 0 );
                    this.m_CachedKnots[3] = new pc.Vec4( 0, this.m_Orbits[0].m_Height, -this.m_Orbits[0].m_Radius, 0 );
                    this.m_CachedKnots[0] = new pc.Vec4().lerp( this.m_CachedKnots[1], pc.Vec4.ZERO.clone(), t );
                    this.m_CachedKnots[4] = new pc.Vec4().lerp( this.m_CachedKnots[3], pc.Vec4.ZERO.clone(), t );
                    Cinemachine.Utility.SplineHelpers.ComputeSmoothControlPoints(Bridge.ref(this, "m_CachedKnots"), Bridge.ref(this, "m_CachedCtrl1"), Bridge.ref(this, "m_CachedCtrl2"));
                    this.m_CachedOrbits = System.Array.init(3, function (){
                        return new Cinemachine.CinemachineFreeLook.Orbit();
                    }, Cinemachine.CinemachineFreeLook.Orbit);
                    for (var i1 = 0; i1 < 3; ++i1) {
                        this.m_CachedOrbits[i1] = this.m_Orbits[i1].$clone();
                    }

                    this.m_CachedTension = this.m_SplineCurvature;
                }
            },
            /*Cinemachine.CinemachineFreeLook.UpdateCachedSpline end.*/


        }
    });
    /*Cinemachine.CinemachineFreeLook end.*/

    /*Cinemachine.CinemachineGroupComposer start.*/
    /**
     * This is a CinemachineComponent in the Aim section of the component pipeline.
         Its job is to aim the camera at a target object, with configurable offsets, damping,
         and composition rules.
         In addition, if the target is a ICinemachineTargetGroup, the behaviour
         will adjust the FOV and the camera distance to ensure that the entire group of targets
         is framed properly.
     *
     * @public
     * @class Cinemachine.CinemachineGroupComposer
     * @augments Cinemachine.CinemachineComposer
     */
    Bridge.define("Cinemachine.CinemachineGroupComposer", {
        inherits: [Cinemachine.CinemachineComposer],
        statics: {
            methods: {
                /*Cinemachine.CinemachineGroupComposer.GetScreenSpaceGroupBoundingBox:static start.*/
                /**
                 * @static
                 * @private
                 * @this Cinemachine.CinemachineGroupComposer
                 * @memberof Cinemachine.CinemachineGroupComposer
                 * @param   {Cinemachine.ICinemachineTargetGroup}    group       
                 * @param   {UnityEngine.Matrix4x4}                  observer    Point of view
                 * @param   {UnityEngine.Vector3}                    newFwd      New forward direction to use when interpreting the return value
                 * @return  {UnityEngine.Bounds}                                 Bounding box in a slightly rotated version of observer, as specified by newFwd
                 */
                GetScreenSpaceGroupBoundingBox: function (group, observer, newFwd) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineGroupComposer#GetScreenSpaceGroupBoundingBox", this ); }

                    var $t;
                    var minAngles = { v : new UnityEngine.Vector2() }, maxAngles = { v : new UnityEngine.Vector2() }, zRange = { v : new UnityEngine.Vector2() };
                    group.Cinemachine$ICinemachineTargetGroup$GetViewSpaceAngularBounds(observer.$clone(), minAngles, maxAngles, zRange);
                    var shift = (minAngles.v.$clone().add( maxAngles.v )).scale( 1.0 / ( 2 ) );

                    newFwd.v = Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation(pc.Quat.IDENTITY.clone(), shift.$clone(), pc.Vec3.UP.clone()).transformVector( new pc.Vec3( 0, 0, 1 ) );
                    newFwd.v = observer.transformVector( newFwd.v );

                    var d = zRange.v.y + zRange.v.x;
                    var angles = (maxAngles.v.$clone().sub( shift )).scale( UnityEngine.Mathf.Deg2Rad );
                    angles = ($t = new pc.Vec2( 89.5, 89.5 ), new pc.Vec2( Math.min( angles.x, $t.x ), Math.min( angles.y, $t.y ) ));
                    return new pc.BoundingBox( new pc.Vec3( 0, 0, d / 2 ), new pc.Vec3( Math.tan(angles.y) * d, Math.tan(angles.x) * d, zRange.v.y - zRange.v.x ).scale( 0.5 ) );
                },
                /*Cinemachine.CinemachineGroupComposer.GetScreenSpaceGroupBoundingBox:static end.*/


            }
        },
        fields: {
            /**
             * How to adjust the camera to get the desired framing
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @type number
             */
            m_AdjustmentMode: 0,
            /**
             * How aggressively the camera tries to frame the group.
                 Small numbers are more responsive
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 2.0
             * @type number
             */
            m_FrameDamping: 0,
            /**
             * What screen dimensions to consider when framing
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @type number
             */
            m_FramingMode: 0,
            /**
             * How much of the screen to fill with the bounding box of the targets.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 0.8
             * @type number
             */
            m_GroupFramingSize: 0,
            /**
             * How much closer to the target can the camera go?
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 5000.0
             * @type number
             */
            m_MaxDollyIn: 0,
            /**
             * How much farther from the target can the camera go?
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 5000.0
             * @type number
             */
            m_MaxDollyOut: 0,
            /**
             * Set this to limit how far from the taregt the camera can get
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 5000.0
             * @type number
             */
            m_MaximumDistance: 0,
            /**
             * If adjusting FOV, will not set the FOV higher than this
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 60
             * @type number
             */
            m_MaximumFOV: 0,
            /**
             * If adjusting Orthographic Size, will not set it higher than this
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 5000
             * @type number
             */
            m_MaximumOrthoSize: 0,
            /**
             * Set this to limit how close to the target the camera can get
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 1
             * @type number
             */
            m_MinimumDistance: 0,
            /**
             * If adjusting FOV, will not set the FOV lower than this
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 3
             * @type number
             */
            m_MinimumFOV: 0,
            /**
             * If adjusting Orthographic Size, will not set it lower than this
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @default 1
             * @type number
             */
            m_MinimumOrthoSize: 0,
            m_prevFOV: 0,
            m_prevFramingDistance: 0,
            /**
             * For editor visulaization of the calculated bounding box of the group
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @function LastBounds
             * @type UnityEngine.Bounds
             */
            LastBounds: null,
            /**
             * For editor visualization of the calculated bounding box of the group
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineGroupComposer
             * @function LastBoundsMatrix
             * @type UnityEngine.Matrix4x4
             */
            LastBoundsMatrix: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineGroupComposer#init", this ); }

                this.LastBounds = new UnityEngine.Bounds();
                this.LastBoundsMatrix = new UnityEngine.Matrix4x4();
                this.m_AdjustmentMode = Cinemachine.CinemachineGroupComposer.AdjustmentMode.DollyThenZoom;
                this.m_FrameDamping = 2.0;
                this.m_FramingMode = Cinemachine.CinemachineGroupComposer.FramingMode.HorizontalAndVertical;
                this.m_GroupFramingSize = 0.8;
                this.m_MaxDollyIn = 5000.0;
                this.m_MaxDollyOut = 5000.0;
                this.m_MaximumDistance = 5000.0;
                this.m_MaximumFOV = 60;
                this.m_MaximumOrthoSize = 5000;
                this.m_MinimumDistance = 1;
                this.m_MinimumFOV = 3;
                this.m_MinimumOrthoSize = 1;
            }
        },
        methods: {
            /*Cinemachine.CinemachineGroupComposer.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineGroupComposer#OnValidate", this ); }

                this.m_GroupFramingSize = UnityEngine.Mathf.Max(0.001, this.m_GroupFramingSize);
                this.m_MaxDollyIn = UnityEngine.Mathf.Max(0, this.m_MaxDollyIn);
                this.m_MaxDollyOut = UnityEngine.Mathf.Max(0, this.m_MaxDollyOut);
                this.m_MinimumDistance = UnityEngine.Mathf.Max(0, this.m_MinimumDistance);
                this.m_MaximumDistance = UnityEngine.Mathf.Max(this.m_MinimumDistance, this.m_MaximumDistance);
                this.m_MinimumFOV = UnityEngine.Mathf.Max(1, this.m_MinimumFOV);
                this.m_MaximumFOV = Math.max(this.m_MinimumFOV, Math.min(this.m_MaximumFOV, 179));
                this.m_MinimumOrthoSize = UnityEngine.Mathf.Max(0.01, this.m_MinimumOrthoSize);
                this.m_MaximumOrthoSize = UnityEngine.Mathf.Max(this.m_MinimumOrthoSize, this.m_MaximumOrthoSize);
            },
            /*Cinemachine.CinemachineGroupComposer.OnValidate end.*/

            /*Cinemachine.CinemachineGroupComposer.MutateCameraState start.*/
            /**
             * Applies the composer rules and orients the camera accordingly
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineGroupComposer
             * @memberof Cinemachine.CinemachineGroupComposer
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for calculating damping.  If less than
                 zero, then target will snap to the center of the dead zone.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineGroupComposer#MutateCameraState", this ); }

                // Can't do anything without a group to look at
                var group = this.AbstractLookAtTargetGroup;
                if (group == null) {
                    Cinemachine.CinemachineComposer.prototype.MutateCameraState.call(this, curState, deltaTime);
                    return;
                }

                if (!this.IsValid || !curState.v.HasLookAt) {
                    this.m_prevFramingDistance = 0;
                    this.m_prevFOV = 0;
                    return;
                }

                var isOrthographic = curState.v.Lens.Orthographic;
                var canMoveCamera = !isOrthographic && this.m_AdjustmentMode !== Cinemachine.CinemachineGroupComposer.AdjustmentMode.ZoomOnly;

                // Get the bounding box from camera's POV in view space
                var up = curState.v.ReferenceUp.$clone();
                var cameraPos = curState.v.RawPosition.$clone();
                var s = group.Cinemachine$ICinemachineTargetGroup$Sphere.$clone();
                var groupCenter = s.position.$clone();
                var fwd = { v : groupCenter.$clone().sub( cameraPos ) };
                var d = fwd.v.length();
                if (d < Cinemachine.CinemachineComponentBase.Epsilon) {
                    return; // navel-gazing, get outa here
                }

                // Approximate looking at the group center
                fwd.v = fwd.v.$clone().scale( 1.0 / ( d ) );
                this.LastBoundsMatrix = new pc.Mat4().setTRS( cameraPos, new pc.Quat().setLookAt( fwd.v, up ), new pc.Vec3( 1, 1, 1 ) );

                // Correction for the actual center
                var b = new UnityEngine.Bounds();
                if (isOrthographic) {
                    b = group.Cinemachine$ICinemachineTargetGroup$GetViewSpaceBoundingBox(this.LastBoundsMatrix.$clone());
                    groupCenter = this.LastBoundsMatrix.transformPoint( b.center );
                    fwd.v = (groupCenter.$clone().sub( cameraPos )).clone().normalize().$clone();
                    this.LastBoundsMatrix = new pc.Mat4().setTRS( cameraPos, new pc.Quat().setLookAt( fwd.v, up ), new pc.Vec3( 1, 1, 1 ) );
                    b = group.Cinemachine$ICinemachineTargetGroup$GetViewSpaceBoundingBox(this.LastBoundsMatrix.$clone());
                    this.LastBounds = b;
                } else {
                    b = Cinemachine.CinemachineGroupComposer.GetScreenSpaceGroupBoundingBox(group, this.LastBoundsMatrix.$clone(), fwd);
                    this.LastBoundsMatrix = new pc.Mat4().setTRS( cameraPos, new pc.Quat().setLookAt( fwd.v, up ), new pc.Vec3( 1, 1, 1 ) );
                    this.LastBounds = b;
                    groupCenter = cameraPos.$clone().add( fwd.v.$clone().clone().scale( b.center.z ) );
                    fwd.v = (groupCenter.$clone().sub( cameraPos )).clone().normalize().$clone();
                }

                // Adjust bounds for framing size, and get target height
                var boundsDepth = b.halfExtents.z;
                var targetHeight = this.GetTargetHeight(UnityEngine.Vector2.FromVector3(b.halfExtents.$clone().scale( 2 ).$clone().scale( 1.0 / ( this.m_GroupFramingSize ) )));

                if (isOrthographic) {
                    targetHeight = Math.max(this.m_MinimumOrthoSize, Math.min(targetHeight / 2, this.m_MaximumOrthoSize));

                    // ApplyDamping
                    if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                        targetHeight = this.m_prevFOV + Cinemachine.Utility.Damper.Damp(targetHeight - this.m_prevFOV, this.m_FrameDamping, deltaTime);
                    }

                    this.m_prevFOV = targetHeight;

                    var lens = curState.v.Lens.$clone();
                    lens.OrthographicSize = Math.max(this.m_MinimumOrthoSize, Math.min(targetHeight, this.m_MaximumOrthoSize));
                    curState.v.Lens = lens.$clone();
                } else {
                    // Adjust height for perspective - we want the height at the near surface
                    var z = b.center.z;
                    if (z > boundsDepth) {
                        targetHeight = pc.math.lerp(0, targetHeight, (z - boundsDepth) / z);
                    }

                    // Move the camera
                    if (canMoveCamera) {
                        // What distance from near edge would be needed to get the adjusted
                        // target height, at the current FOV
                        var targetDistance = boundsDepth + targetHeight / (2.0 * Math.tan(curState.v.Lens.FieldOfView * UnityEngine.Mathf.Deg2Rad / 2.0));

                        // Clamp to respect min/max distance settings to the near surface of the bounds
                        targetDistance = Math.max(boundsDepth + this.m_MinimumDistance, Math.min(targetDistance, boundsDepth + this.m_MaximumDistance));

                        // Clamp to respect min/max camera movement
                        var targetDelta = targetDistance - pc.Vec3.distance( curState.v.RawPosition, groupCenter );
                        targetDelta = Math.max(-this.m_MaxDollyIn, Math.min(targetDelta, this.m_MaxDollyOut));

                        // ApplyDamping
                        if (deltaTime >= 0 && this.VirtualCamera.PreviousStateIsValid) {
                            var delta = targetDelta - this.m_prevFramingDistance;
                            delta = Cinemachine.Utility.Damper.Damp(delta, this.m_FrameDamping, deltaTime);
                            targetDelta = this.m_prevFramingDistance + delta;
                        }

                        this.m_prevFramingDistance = targetDelta;
                        curState.v.PositionCorrection = curState.v.PositionCorrection.$clone().sub( fwd.v.$clone().clone().scale( targetDelta ) );
                        cameraPos = cameraPos.$clone().sub( fwd.v.$clone().clone().scale( targetDelta ) );
                    }

                    // Apply zoom
                    if (this.m_AdjustmentMode !== Cinemachine.CinemachineGroupComposer.AdjustmentMode.DollyOnly) {
                        var nearBoundsDistance = (groupCenter.$clone().sub( cameraPos )).length() - boundsDepth;
                        var targetFOV = 179;
                        if (nearBoundsDistance > Cinemachine.CinemachineComponentBase.Epsilon) {
                            targetFOV = 2.0 * Math.atan(targetHeight / (2 * nearBoundsDistance)) * UnityEngine.Mathf.Rad2Deg;
                        }

                        targetFOV = Math.max(this.m_MinimumFOV, Math.min(targetFOV, this.m_MaximumFOV));

                        // ApplyDamping
                        if (deltaTime >= 0 && this.m_prevFOV !== 0 && this.VirtualCamera.PreviousStateIsValid) {
                            targetFOV = this.m_prevFOV + Cinemachine.Utility.Damper.Damp(targetFOV - this.m_prevFOV, this.m_FrameDamping, deltaTime);
                        }

                        this.m_prevFOV = targetFOV;

                        var lens1 = curState.v.Lens.$clone();
                        lens1.FieldOfView = targetFOV;
                        curState.v.Lens = lens1.$clone();
                    }
                }

                // Now compose normally
                curState.v.ReferenceLookAt = this.GetLookAtPointAndSetTrackedPoint(groupCenter.$clone(), curState.v.ReferenceUp.$clone(), deltaTime);
                Cinemachine.CinemachineComposer.prototype.MutateCameraState.call(this, curState, deltaTime);
            },
            /*Cinemachine.CinemachineGroupComposer.MutateCameraState end.*/

            /*Cinemachine.CinemachineGroupComposer.GetTargetHeight start.*/
            GetTargetHeight: function (boundsSize) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineGroupComposer#GetTargetHeight", this ); }

                switch (this.m_FramingMode) {
                    case Cinemachine.CinemachineGroupComposer.FramingMode.Horizontal: 
                        return UnityEngine.Mathf.Max(Cinemachine.CinemachineComponentBase.Epsilon, boundsSize.x) / this.VcamState.Lens.Aspect;
                    case Cinemachine.CinemachineGroupComposer.FramingMode.Vertical: 
                        return UnityEngine.Mathf.Max(Cinemachine.CinemachineComponentBase.Epsilon, boundsSize.y);
                    default: 
                    case Cinemachine.CinemachineGroupComposer.FramingMode.HorizontalAndVertical: 
                        return UnityEngine.Mathf.Max(UnityEngine.Mathf.Max(Cinemachine.CinemachineComponentBase.Epsilon, boundsSize.x) / this.VcamState.Lens.Aspect, UnityEngine.Mathf.Max(Cinemachine.CinemachineComponentBase.Epsilon, boundsSize.y));
                }
            },
            /*Cinemachine.CinemachineGroupComposer.GetTargetHeight end.*/


        }
    });
    /*Cinemachine.CinemachineGroupComposer end.*/

    /*Cinemachine.CinemachineMixingCamera start.*/
    /**
     * CinemachineMixingCamera is a "manager camera" that takes on the state of
         the weighted average of the states of its child virtual cameras.
         A fixed number of slots are made available for cameras, rather than a dynamic array.
         We do it this way in order to support weight animation from the Timeline.
         Timeline cannot animate array elements.
     *
     * @public
     * @class Cinemachine.CinemachineMixingCamera
     * @augments Cinemachine.CinemachineVirtualCameraBase
     */
    Bridge.define("Cinemachine.CinemachineMixingCamera", {
        inherits: [Cinemachine.CinemachineVirtualCameraBase],
        statics: {
            fields: {
                /**
                 * The maximum number of tracked cameras.  If you want to add
                     more cameras, do it here in the source code, and be sure to add the
                     extra member variables and to make the appropriate changes in
                     GetWeight() and SetWeight().
                     The inspector will figure itself out based on this value.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineMixingCamera
                 * @constant
                 * @default 8
                 * @type number
                 */
                MaxCameras: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#init", this ); }

                    this.MaxCameras = 8;
                }
            }
        },
        fields: {
            /**
             * Weight of the first tracked camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineMixingCamera
             * @default 0.5
             * @type number
             */
            m_Weight0: 0,
            /**
             * Weight of the second tracked camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineMixingCamera
             * @default 0.5
             * @type number
             */
            m_Weight1: 0,
            /**
             * Weight of the third tracked camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineMixingCamera
             * @default 0.5
             * @type number
             */
            m_Weight2: 0,
            /**
             * Weight of the fourth tracked camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineMixingCamera
             * @default 0.5
             * @type number
             */
            m_Weight3: 0,
            /**
             * Weight of the fifth tracked camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineMixingCamera
             * @default 0.5
             * @type number
             */
            m_Weight4: 0,
            /**
             * Weight of the sixth tracked camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineMixingCamera
             * @default 0.5
             * @type number
             */
            m_Weight5: 0,
            /**
             * Weight of the seventh tracked camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineMixingCamera
             * @default 0.5
             * @type number
             */
            m_Weight6: 0,
            /**
             * Weight of the eighth tracked camera
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineMixingCamera
             * @default 0.5
             * @type number
             */
            m_Weight7: 0,
            /**
             * Blended camera state
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineMixingCamera
             * @type Cinemachine.CameraState
             */
            m_State: null,
            /**
             * Get the current "best" child virtual camera, which is nominally
                 the one with the greatest weight.
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineMixingCamera
             * @function LiveChild
             * @type Cinemachine.ICinemachineCamera
             */
            LiveChild: null,
            /**
             * Not used
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineMixingCamera
             * @function LookAt
             * @type UnityEngine.Transform
             */
            LookAt: null,
            /**
             * Not used
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineMixingCamera
             * @function Follow
             * @type UnityEngine.Transform
             */
            Follow: null,
            m_ChildCameras: null,
            m_indexMap: null
        },
        props: {
            /**
             * The blended CameraState
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineMixingCamera
             * @function State
             * @type Cinemachine.CameraState
             */
            State: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#State#get", this ); }

                    return this.m_State.$clone();
                }
            },
            /**
             * Get the cached list of child cameras.
                 These are just the immediate children in the hierarchy.
                 Note: only the first entries of this list participate in the
                 final blend, up to MaxCameras
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineMixingCamera
             * @function ChildCameras
             * @type Array.<Cinemachine.CinemachineVirtualCameraBase>
             */
            ChildCameras: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#ChildCameras#get", this ); }

                    this.ValidateListOfChildren();
                    return this.m_ChildCameras;
                }
            }
        },
        alias: [
            "State", "Cinemachine$ICinemachineCamera$State",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped",
            "IsLiveChild", "Cinemachine$ICinemachineCamera$IsLiveChild",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#init", this ); }

                this.m_State = new Cinemachine.CameraState();
                this.m_Weight0 = 0.5;
                this.m_Weight1 = 0.5;
                this.m_Weight2 = 0.5;
                this.m_Weight3 = 0.5;
                this.m_Weight4 = 0.5;
                this.m_Weight5 = 0.5;
                this.m_Weight6 = 0.5;
                this.m_Weight7 = 0.5;
                this.m_State = Cinemachine.CameraState.Default.$clone();
            }
        },
        methods: {
            /*Cinemachine.CinemachineMixingCamera.GetWeight$1 start.*/
            /**
             * Get the weight of the child at an index.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @param   {number}    index    The child index. Only immediate CinemachineVirtualCameraBase
                 children are counted.
             * @return  {number}             The weight of the camera.  Valid only if camera is active and enabled.
             */
            GetWeight$1: function (index) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#GetWeight$1", this ); }

                switch (index) {
                    case 0: 
                        return this.m_Weight0;
                    case 1: 
                        return this.m_Weight1;
                    case 2: 
                        return this.m_Weight2;
                    case 3: 
                        return this.m_Weight3;
                    case 4: 
                        return this.m_Weight4;
                    case 5: 
                        return this.m_Weight5;
                    case 6: 
                        return this.m_Weight6;
                    case 7: 
                        return this.m_Weight7;
                }

                UnityEngine.Debug.LogError$2("CinemachineMixingCamera: Invalid index: " + index);
                return 0;
            },
            /*Cinemachine.CinemachineMixingCamera.GetWeight$1 end.*/

            /*Cinemachine.CinemachineMixingCamera.GetWeight start.*/
            /**
             * Get the weight of the child CinemachineVirtualCameraBase.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam    The child camera.
             * @return  {number}                                              The weight of the camera.  Valid only if camera is active and enabled.
             */
            GetWeight: function (vcam) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#GetWeight", this ); }

                this.ValidateListOfChildren();
                var index = { };
                if (this.m_indexMap.tryGetValue(vcam, index)) {
                    return this.GetWeight$1(index.v);
                }

                UnityEngine.Debug.LogError$2("CinemachineMixingCamera: Invalid child: " + ((UnityEngine.MonoBehaviour.op_Inequality(vcam, null) ? vcam.Name : "(null)") || ""));
                return 0;
            },
            /*Cinemachine.CinemachineMixingCamera.GetWeight end.*/

            /*Cinemachine.CinemachineMixingCamera.SetWeight$1 start.*/
            /**
             * Set the weight of the child at an index.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @param   {number}    index    The child index. Only immediate CinemachineVirtualCameraBase
                 children are counted.
             * @param   {number}    w        The weight to set.  Can be any non-negative number.
             * @return  {void}
             */
            SetWeight$1: function (index, w) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#SetWeight$1", this ); }

                switch (index) {
                    case 0: 
                        this.m_Weight0 = w;
                        return;
                    case 1: 
                        this.m_Weight1 = w;
                        return;
                    case 2: 
                        this.m_Weight2 = w;
                        return;
                    case 3: 
                        this.m_Weight3 = w;
                        return;
                    case 4: 
                        this.m_Weight4 = w;
                        return;
                    case 5: 
                        this.m_Weight5 = w;
                        return;
                    case 6: 
                        this.m_Weight6 = w;
                        return;
                    case 7: 
                        this.m_Weight7 = w;
                        return;
                }

                UnityEngine.Debug.LogError$2("CinemachineMixingCamera: Invalid index: " + index);
            },
            /*Cinemachine.CinemachineMixingCamera.SetWeight$1 end.*/

            /*Cinemachine.CinemachineMixingCamera.SetWeight start.*/
            /**
             * Set the weight of the child CinemachineVirtualCameraBase.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @param   {Cinemachine.CinemachineVirtualCameraBase}    vcam    The child camera.
             * @param   {number}                                      w       The weight to set.  Can be any non-negative number.
             * @return  {void}
             */
            SetWeight: function (vcam, w) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#SetWeight", this ); }

                this.ValidateListOfChildren();
                var index = { };
                if (this.m_indexMap.tryGetValue(vcam, index)) {
                    this.SetWeight$1(index.v, w);
                } else {
                    UnityEngine.Debug.LogError$2("CinemachineMixingCamera: Invalid child: " + ((UnityEngine.MonoBehaviour.op_Inequality(vcam, null) ? vcam.Name : "(null)") || ""));
                }
            },
            /*Cinemachine.CinemachineMixingCamera.SetWeight end.*/

            /*Cinemachine.CinemachineMixingCamera.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the vcam that a target got warped,
                 so that the vcam can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#OnTargetObjectWarped", this ); }

                var $t;
                this.ValidateListOfChildren();
                $t = Bridge.getEnumerator(this.m_ChildCameras);
                try {
                    while ($t.moveNext()) {
                        var vcam = $t.Current;
                        vcam.OnTargetObjectWarped(target, positionDelta.$clone());
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
            },
            /*Cinemachine.CinemachineMixingCamera.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineMixingCamera.OnEnable start.*/
            /**
             * Makes sure the internal child cache is up to date
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#OnEnable", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnEnable.call(this);
                this.InvalidateListOfChildren();
            },
            /*Cinemachine.CinemachineMixingCamera.OnEnable end.*/

            /*Cinemachine.CinemachineMixingCamera.OnTransformChildrenChanged start.*/
            /**
             * Makes sure the internal child cache is up to date
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @return  {void}
             */
            OnTransformChildrenChanged: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#OnTransformChildrenChanged", this ); }

                this.InvalidateListOfChildren();
            },
            /*Cinemachine.CinemachineMixingCamera.OnTransformChildrenChanged end.*/

            /*Cinemachine.CinemachineMixingCamera.OnValidate start.*/
            /**
             * Makes sure the weights are non-negative
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @return  {void}
             */
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#OnValidate", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnValidate.call(this);
                for (var i = 0; i < Cinemachine.CinemachineMixingCamera.MaxCameras; ++i) {
                    this.SetWeight$1(i, UnityEngine.Mathf.Max(0, this.GetWeight$1(i)));
                }
            },
            /*Cinemachine.CinemachineMixingCamera.OnValidate end.*/

            /*Cinemachine.CinemachineMixingCamera.IsLiveChild start.*/
            /**
             * Check whether the vcam a live child of this camera.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @param   {Cinemachine.ICinemachineCamera}    vcam                 The Virtual Camera to check
             * @param   {boolean}                           dominantChildOnly    If truw, will only return true if this vcam is the dominat live child
             * @return  {boolean}                                                True if the vcam is currently actively influencing the state of this vcam
             */
            IsLiveChild: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#IsLiveChild", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                var children = this.ChildCameras;
                for (var i = 0; i < Cinemachine.CinemachineMixingCamera.MaxCameras && i < children.length; ++i) {
                    if (Bridge.referenceEquals(children[i], vcam)) {
                        return this.GetWeight$1(i) > Cinemachine.Utility.UnityVectorExtensions.Epsilon && children[i].isActiveAndEnabled;
                    }
                }

                return false;
            },
            /*Cinemachine.CinemachineMixingCamera.IsLiveChild end.*/

            /*Cinemachine.CinemachineMixingCamera.InvalidateListOfChildren start.*/
            /**
             * Invalidate the cached list of child cameras.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @return  {void}
             */
            InvalidateListOfChildren: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#InvalidateListOfChildren", this ); }

                this.m_ChildCameras = null;
                this.m_indexMap = null;
                this.LiveChild = null;
            },
            /*Cinemachine.CinemachineMixingCamera.InvalidateListOfChildren end.*/

            /*Cinemachine.CinemachineMixingCamera.ValidateListOfChildren start.*/
            /**
             * Rebuild the cached list of child cameras.
             *
             * @instance
             * @protected
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @return  {void}
             */
            ValidateListOfChildren: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#ValidateListOfChildren", this ); }

                var $t;
                if (this.m_ChildCameras != null) {
                    return;
                }

                this.m_indexMap = new (System.Collections.Generic.Dictionary$2(Cinemachine.CinemachineVirtualCameraBase,System.Int32)).ctor();
                var list = new (System.Collections.Generic.List$1(Cinemachine.CinemachineVirtualCameraBase)).ctor();
                var kids = this.GetComponentsInChildren$1(Cinemachine.CinemachineVirtualCameraBase, true);
                $t = Bridge.getEnumerator(kids);
                try {
                    while ($t.moveNext()) {
                        var k = $t.Current;
                        if (UnityEngine.Component.op_Equality(k.transform.parent, this.transform)) {
                            var index = list.Count;
                            list.add(k);
                            if (index < Cinemachine.CinemachineMixingCamera.MaxCameras) {
                                this.m_indexMap.add(k, index);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.m_ChildCameras = list.ToArray();
            },
            /*Cinemachine.CinemachineMixingCamera.ValidateListOfChildren end.*/

            /*Cinemachine.CinemachineMixingCamera.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}               worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                            deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#OnTransitionFromCamera", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTransitionFromCamera.call(this, fromCam, worldUp.$clone(), deltaTime);
                this.InvokeOnTransitionInExtensions(fromCam, worldUp.$clone(), deltaTime);
                var children = this.ChildCameras;
                for (var i = 0; i < Cinemachine.CinemachineMixingCamera.MaxCameras && i < children.length; ++i) {
                    var vcam = children[i];
                    if (vcam.isActiveAndEnabled && this.GetWeight$1(i) > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                        vcam.OnTransitionFromCamera(fromCam, worldUp.$clone(), deltaTime);
                    }
                }

                this.InternalUpdateCameraState(worldUp.$clone(), deltaTime);
            },
            /*Cinemachine.CinemachineMixingCamera.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineMixingCamera.InternalUpdateCameraState start.*/
            /**
             * Internal use only.  Do not call this methid.
                 Called by CinemachineCore at designated update time
                 so the vcam can position itself and track its targets.  This implementation
                 computes and caches the weighted blend of the tracked cameras.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineMixingCamera
             * @memberof Cinemachine.CinemachineMixingCamera
             * @param   {UnityEngine.Vector3}    worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                 deltaTime    Delta time for time-based effects (ignore if less than 0)
             * @return  {void}
             */
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineMixingCamera#InternalUpdateCameraState", this ); }

                var children = this.ChildCameras;
                this.LiveChild = null;
                var highestWeight = 0;
                var totalWeight = 0;
                for (var i = 0; i < Cinemachine.CinemachineMixingCamera.MaxCameras && i < children.length; ++i) {
                    var vcam = children[i];
                    if (vcam.isActiveAndEnabled) {
                        var weight = UnityEngine.Mathf.Max(0, this.GetWeight$1(i));
                        if (weight > Cinemachine.Utility.UnityVectorExtensions.Epsilon) {
                            totalWeight += weight;
                            if (totalWeight === weight) {
                                this.m_State = vcam.State.$clone();
                            } else {
                                this.m_State = Cinemachine.CameraState.Lerp(this.m_State.$clone(), vcam.State.$clone(), weight / totalWeight);
                            }

                            if (weight > highestWeight) {
                                highestWeight = weight;
                                this.LiveChild = vcam;
                            }
                        }
                    }
                }

                this.InvokePostPipelineStageCallback(this, Cinemachine.CinemachineCore.Stage.Finalize, Bridge.ref(this, "m_State"), deltaTime);
            },
            /*Cinemachine.CinemachineMixingCamera.InternalUpdateCameraState end.*/


        },
        overloads: {
            "GetWeight(int)": "GetWeight$1",
            "SetWeight(int, float)": "SetWeight$1"
        }
    });
    /*Cinemachine.CinemachineMixingCamera end.*/
    /**
     * @memberof Cinemachine
     * @callback Cinemachine.CinemachineOrbitalTransposer.UpdateHeadingDelegate
     * @param   {Cinemachine.CinemachineOrbitalTransposer}    orbital      
     * @param   {number}                                      deltaTime    
     * @param   {UnityEngine.Vector3}                         up
     * @return  {number}
     */


    /*Cinemachine.CinemachineOrbitalTransposer start.*/
    /**
     * This is a CinemachineComponent in the the Body section of the component pipeline.
         Its job is to position the camera in a variable relationship to a the vcam's
         Follow target object, with offsets and damping.
         This component is typically used to implement a camera that follows its target.
         It can accept player input from an input device, which allows the player to
         dynamically control the relationship between the camera and the target,
         for example with a joystick.
         The OrbitalTransposer introduces the concept of __Heading__, which is the direction
         in which the target is moving, and the OrbitalTransposer will attempt to position
         the camera in relationship to the heading, which is by default directly behind the target.
         You can control the default relationship by adjusting the Heading Bias setting.
         If you attach an input controller to the OrbitalTransposer, then the player can also
         control the way the camera positions itself in relation to the target heading.  This allows
         the camera to move to any spot on an orbit around the target.
     *
     * @public
     * @class Cinemachine.CinemachineOrbitalTransposer
     * @augments Cinemachine.CinemachineTransposer
     */
    Bridge.define("Cinemachine.CinemachineOrbitalTransposer", {
        inherits: [Cinemachine.CinemachineTransposer],
        statics: {
            methods: {
                /*Cinemachine.CinemachineOrbitalTransposer.GetFullName:static start.*/
                GetFullName: function (current) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#GetFullName", this ); }

                    if (UnityEngine.GameObject.op_Equality(current, null)) {
                        return "";
                    }

                    if (UnityEngine.Component.op_Equality(current.transform.parent, null)) {
                        return "/" + (current.name || "");
                    }

                    return (Cinemachine.CinemachineOrbitalTransposer.GetFullName(current.transform.parent.gameObject) || "") + "/" + (current.name || "");
                },
                /*Cinemachine.CinemachineOrbitalTransposer.GetFullName:static end.*/


            }
        },
        fields: {
            /**
             * Delegate that allows the the XAxis object to be replaced with another one.
                 To use it, just call orbital.UpdateHeading() with a reference to a
                 private AxisState object, and that AxisState object will be updated and
                 used to calculate the heading.
             *
             * @instance
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @type Cinemachine.CinemachineOrbitalTransposer.UpdateHeadingDelegate
             */
            HeadingUpdater: null,
            /**
             * The definition of Forward.  Camera will follow behind.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @type Cinemachine.CinemachineOrbitalTransposer.Heading
             */
            m_Heading: null,
            /**
             * Drive the x-axis setting programmatically.
                 Automatic heading updating will be disabled.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @default false
             * @type boolean
             */
            m_HeadingIsSlave: false,
            m_LegacyHeadingBias: 0,
            m_LegacyHeightOffset: 0,
            /**
             * Legacy support
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @default 3.40282347E+38
             * @type number
             */
            m_LegacyRadius: 0,
            /**
             * Parameters that control Automating Heading Recentering
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @type Cinemachine.AxisState.Recentering
             */
            m_RecenterToTargetHeading: null,
            /**
             * Axis representing the current heading.  Value is in degrees
                 and represents a rotation about the up vector
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @type Cinemachine.AxisState
             */
            m_XAxis: null,
            mHeadingPrevFrame: null,
            mHeadingTracker: null,
            mLastTargetPosition: null,
            mOffsetPrevFrame: null,
            mTargetRigidBody: null,
            PreviousTarget: null,
            LastHeading: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#init", this ); }

                this.m_Heading = new Cinemachine.CinemachineOrbitalTransposer.Heading();
                this.m_RecenterToTargetHeading = new Cinemachine.AxisState.Recentering();
                this.m_XAxis = new Cinemachine.AxisState();
                this.mHeadingPrevFrame = new UnityEngine.Quaternion();
                this.mLastTargetPosition = new UnityEngine.Vector3();
                this.mOffsetPrevFrame = new UnityEngine.Vector3();
                this.HeadingUpdater = function (orbital, deltaTime, up) {
                    return orbital.UpdateHeading$1(deltaTime, up.$clone(), Bridge.ref(orbital, "m_XAxis"), Bridge.ref(orbital, "m_RecenterToTargetHeading"), Cinemachine.CinemachineCore.Instance.IsLive(orbital.VirtualCamera));
                };
                this.m_Heading = new Cinemachine.CinemachineOrbitalTransposer.Heading.$ctor1(Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.TargetForward, 4, 0);
                this.m_HeadingIsSlave = false;
                this.m_LegacyHeadingBias = 3.40282347E+38;
                this.m_LegacyHeightOffset = 3.40282347E+38;
                this.m_LegacyRadius = 3.40282347E+38;
                this.m_RecenterToTargetHeading = new Cinemachine.AxisState.Recentering.$ctor1(true, 1, 2);
                this.m_XAxis = new Cinemachine.AxisState.$ctor1(-180, 180, true, false, 300.0, 0.1, 0.1, "Mouse X", true);
                this.mHeadingPrevFrame = pc.Quat.IDENTITY.clone();
                this.mLastTargetPosition = pc.Vec3.ZERO.clone();
                this.mOffsetPrevFrame = pc.Vec3.ZERO.clone();
            }
        },
        methods: {
            /*Cinemachine.CinemachineOrbitalTransposer.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#OnValidate", this ); }

                // Upgrade after a legacy deserialize
                if (this.m_LegacyRadius !== 3.40282347E+38 && this.m_LegacyHeightOffset !== 3.40282347E+38 && this.m_LegacyHeadingBias !== 3.40282347E+38) {
                    this.m_FollowOffset = new pc.Vec3( 0, this.m_LegacyHeightOffset, -this.m_LegacyRadius );
                    this.m_LegacyHeightOffset = (this.m_LegacyRadius = 3.40282347E+38);

                    this.m_Heading.m_Bias = this.m_LegacyHeadingBias;
                    this.m_XAxis.m_MaxSpeed /= 10;
                    this.m_XAxis.m_AccelTime /= 10;
                    this.m_XAxis.m_DecelTime /= 10;
                    this.m_LegacyHeadingBias = 3.40282347E+38;
                    var heading = { v : this.m_Heading.m_Definition };
                    if (this.m_RecenterToTargetHeading.LegacyUpgrade(heading, Bridge.ref(this.m_Heading, "m_VelocityFilterStrength"))) {
                        this.m_Heading.m_Definition = heading.v;
                    }
                }

                this.m_XAxis.Validate();
                this.m_RecenterToTargetHeading.Validate();

                Cinemachine.CinemachineTransposer.prototype.OnValidate.call(this);
            },
            /*Cinemachine.CinemachineOrbitalTransposer.OnValidate end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.UpdateHeading start.*/
            /**
             * Update the X axis and calculate the heading.  This can be called by a delegate
                 with a custom axis.  Note that this method is obsolete.
                 <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param><param name="up">World Up, set by the CinemachineBrain</param><param name="axis"></param><returns>Axis value</returns>
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineOrbitalTransposer
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @param   {number}                   deltaTime    Used for damping.  If less than 0, no damping is done.
             * @param   {UnityEngine.Vector3}      up           World Up, set by the CinemachineBrain
             * @param   {Cinemachine.AxisState}    axis
             * @return  {number}                                Axis value
             */
            UpdateHeading: function (deltaTime, up, axis) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#UpdateHeading", this ); }

                return this.UpdateHeading$1(deltaTime, up.$clone(), axis, Bridge.ref(this, "m_RecenterToTargetHeading"), true);
            },
            /*Cinemachine.CinemachineOrbitalTransposer.UpdateHeading end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.UpdateHeading$1 start.*/
            
            UpdateHeading$1: function (deltaTime, up, axis, recentering, isLive) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#UpdateHeading$1", this ); }

                // Only read joystick when game is playing
                if (deltaTime < 0 || !this.VirtualCamera.PreviousStateIsValid || !isLive) {
                    axis.v.Reset();
                    recentering.v.CancelRecentering();
                } else if (axis.v.Update(deltaTime)) {
                    recentering.v.CancelRecentering();
                }

                if (this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                    var finalHeading = axis.v.Value;
                    axis.v.Value = 0;
                    return finalHeading;
                }

                var targetHeading = this.GetTargetHeading(axis.v.Value, this.GetReferenceOrientation(up.$clone()));
                recentering.v.DoRecentering(axis, deltaTime, targetHeading);
                return axis.v.Value;
            },
            /*Cinemachine.CinemachineOrbitalTransposer.UpdateHeading$1 end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#OnEnable", this ); }

                // GML todo: do we really need this?
                this.PreviousTarget = null;
                this.mLastTargetPosition = pc.Vec3.ZERO.clone();
            },
            /*Cinemachine.CinemachineOrbitalTransposer.OnEnable end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the us that a target got warped,
                 so that we can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineOrbitalTransposer
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#OnTargetObjectWarped", this ); }

                Cinemachine.CinemachineTransposer.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
                if (UnityEngine.Component.op_Equality(target, this.FollowTarget)) {
                    this.mLastTargetPosition = this.mLastTargetPosition.$clone().add( positionDelta.$clone() );
                }
            },
            /*Cinemachine.CinemachineOrbitalTransposer.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
                 Base class implementation does nothing.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineOrbitalTransposer
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @param   {Cinemachine.ICinemachineCamera}                               fromCam             The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}                                          worldUp             Default world Up, set by the CinemachineBrain
             * @param   {number}                                                       deltaTime           Delta time for time-based effects (ignore if less than or equal to 0)
             * @param   {Cinemachine.CinemachineVirtualCameraBase.TransitionParams}    transitionParams
             * @return  {boolean}                                                                          True if the vcam should do an internal update as a result of this call
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime, transitionParams) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#OnTransitionFromCamera", this ); }

                this.m_RecenterToTargetHeading.DoRecentering(Bridge.ref(this, "m_XAxis"), -1, 0);
                this.m_RecenterToTargetHeading.CancelRecentering();
                if (fromCam != null && this.m_BindingMode !== Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp && transitionParams.v.m_InheritPosition) {
                    this.m_XAxis.Value = this.GetAxisClosestValue(fromCam.Cinemachine$ICinemachineCamera$State.RawPosition.$clone(), worldUp.$clone());
                    return true;
                }

                return false;
            },
            /*Cinemachine.CinemachineOrbitalTransposer.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.GetAxisClosestValue start.*/
            /**
             * What axis value would we need to get as close as possible to the desired cameraPos?
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineOrbitalTransposer
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @param   {UnityEngine.Vector3}    cameraPos    camera position we would like to approximate
             * @param   {UnityEngine.Vector3}    up           world up
             * @return  {number}                              The best value to put into the X axis, to approximate the desired camera pos
             */
            GetAxisClosestValue: function (cameraPos, up) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#GetAxisClosestValue", this ); }

                var orient = this.GetReferenceOrientation(up.$clone());
                var fwd = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane((orient.transformVector( new pc.Vec3( 0, 0, 1 ) )), up.$clone());
                if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(fwd) && UnityEngine.Component.op_Inequality(this.FollowTarget, null)) {
                    // Get the base camera placement
                    var heading = 0;
                    if (this.m_BindingMode !== Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                        heading += this.m_Heading.m_Bias;
                    }

                    orient = orient.clone().mul( new pc.Quat().setFromAxisAngle( up, heading ) );
                    var targetPos = this.FollowTargetPosition.$clone();
                    var pos = targetPos.$clone().add( orient.transformVector( this.EffectiveOffset ) );

                    var a = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane((pos.$clone().sub( targetPos )), up.$clone());
                    var b = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane((cameraPos.$clone().sub( targetPos )), up.$clone());
                    return pc.Vec3.signedAngle( a, b, up );
                }

                return this.LastHeading; // Can't calculate, stay conservative
            },
            /*Cinemachine.CinemachineOrbitalTransposer.GetAxisClosestValue end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.MutateCameraState start.*/
            /**
             * Positions the virtual camera according to the transposer rules.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineOrbitalTransposer
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @param   {Cinemachine.CameraState}    curState     The current camera state
             * @param   {number}                     deltaTime    Used for damping.  If less than 0, no damping is done.
             * @return  {void}
             */
            MutateCameraState: function (curState, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#MutateCameraState", this ); }

                this.InitPrevFrameStateInfo(curState, deltaTime);

                // Update the heading
                if (UnityEngine.Component.op_Inequality(this.FollowTarget, this.PreviousTarget)) {
                    this.PreviousTarget = this.FollowTarget;
                    this.mTargetRigidBody = UnityEngine.Component.op_Equality(this.PreviousTarget, null) ? null : this.PreviousTarget.GetComponent(UnityEngine.Rigidbody);
                    this.mLastTargetPosition = UnityEngine.Component.op_Equality(this.PreviousTarget, null) ? pc.Vec3.ZERO.clone() : this.PreviousTarget.position.$clone();
                    this.mHeadingTracker = null;
                }

                this.LastHeading = this.HeadingUpdater(this, deltaTime, curState.v.ReferenceUp.$clone());
                var heading = this.LastHeading;

                if (this.IsValid) {
                    this.mLastTargetPosition = this.FollowTargetPosition.$clone();

                    // Calculate the heading
                    if (this.m_BindingMode !== Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                        heading += this.m_Heading.m_Bias;
                    }

                    var headingRot = new pc.Quat().setFromAxisAngle( pc.Vec3.UP.clone(), heading );

                    // Track the target, with damping
                    var offset = this.EffectiveOffset.$clone();
                    var pos = { v : new UnityEngine.Vector3() };
                    var orient = { v : new UnityEngine.Quaternion() };
                    this.TrackTarget(deltaTime, curState.v.ReferenceUp.$clone(), headingRot.transformVector( offset ), pos, orient);

                    // Place the camera
                    curState.v.ReferenceUp = orient.v.transformVector( pc.Vec3.UP.clone() );
                    if (deltaTime >= 0) {
                        var bypass = headingRot.transformVector( offset ).sub( this.mHeadingPrevFrame.transformVector( this.mOffsetPrevFrame ) );
                        bypass = orient.v.transformVector( bypass );
                        curState.v.PositionDampingBypass = bypass.$clone();
                    }

                    orient.v = orient.v.clone().mul( headingRot );
                    curState.v.RawPosition = pos.v.$clone().add( orient.v.transformVector( offset ) );

                    this.mHeadingPrevFrame = this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp ? pc.Quat.IDENTITY.clone() : headingRot.$clone();
                    this.mOffsetPrevFrame = offset.$clone();
                }
            },
            /*Cinemachine.CinemachineOrbitalTransposer.MutateCameraState end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.GetTargetCameraPosition start.*/
            /**
             * Internal API for the Inspector Editor, so it can draw a marker at the target
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineOrbitalTransposer
             * @memberof Cinemachine.CinemachineOrbitalTransposer
             * @param   {UnityEngine.Vector3}    worldUp
             * @return  {UnityEngine.Vector3}
             */
            GetTargetCameraPosition: function (worldUp) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#GetTargetCameraPosition", this ); }

                if (!this.IsValid) {
                    return pc.Vec3.ZERO.clone();
                }

                var heading = this.LastHeading;
                if (this.m_BindingMode !== Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                    heading += this.m_Heading.m_Bias;
                }

                var orient = new pc.Quat().setFromAxisAngle( pc.Vec3.UP.clone(), heading );
                orient = this.GetReferenceOrientation(worldUp.$clone()).clone().mul( orient );
                var pos = orient.transformVector( this.EffectiveOffset );
                pos = pos.$clone().add( this.mLastTargetPosition.$clone() );
                return pos.$clone();
            },
            /*Cinemachine.CinemachineOrbitalTransposer.GetTargetCameraPosition end.*/

            /*Cinemachine.CinemachineOrbitalTransposer.GetTargetHeading start.*/
            GetTargetHeading: function (currentHeading, targetOrientation) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineOrbitalTransposer#GetTargetHeading", this ); }

                if (this.m_BindingMode === Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp) {
                    return 0;
                }

                if (UnityEngine.Component.op_Equality(this.FollowTarget, null)) {
                    return currentHeading;
                }

                var headingDef = this.m_Heading.m_Definition;
                if (headingDef === Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.Velocity && UnityEngine.Component.op_Equality(this.mTargetRigidBody, null)) {
                    headingDef = Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.PositionDelta;
                }

                var velocity = pc.Vec3.ZERO.clone();
                switch (headingDef) {
                    case Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.PositionDelta: 
                        velocity = this.FollowTargetPosition.$clone().sub( this.mLastTargetPosition );
                        break;
                    case Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.Velocity: 
                        velocity = this.mTargetRigidBody.velocity.$clone();
                        break;
                    case Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.TargetForward: 
                        velocity = this.FollowTargetRotation.transformVector( new pc.Vec3( 0, 0, 1 ) );
                        break;
                    default: 
                    case Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.WorldForward: 
                        return 0;
                }

                // Process the velocity and derive the heading from it.
                var up = targetOrientation.transformVector( pc.Vec3.UP.clone() );
                velocity = Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(velocity, up.$clone());
                if (headingDef !== Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.TargetForward) {
                    var filterSize = this.m_Heading.m_VelocityFilterStrength * 5;
                    if (this.mHeadingTracker == null || this.mHeadingTracker.FilterSize !== filterSize) {
                        this.mHeadingTracker = new Cinemachine.Utility.HeadingTracker(filterSize);
                    }

                    this.mHeadingTracker.DecayHistory();
                    if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(velocity)) {
                        this.mHeadingTracker.Add(velocity.$clone());
                    }

                    velocity = this.mHeadingTracker.GetReliableHeading();
                }

                if (!Cinemachine.Utility.UnityVectorExtensions.AlmostZero(velocity)) {
                    return Cinemachine.Utility.UnityVectorExtensions.SignedAngle(targetOrientation.transformVector( new pc.Vec3( 0, 0, 1 ) ), velocity.$clone(), up.$clone());
                }

                // If no reliable heading, then stay where we are.
                return currentHeading;
            },
            /*Cinemachine.CinemachineOrbitalTransposer.GetTargetHeading end.*/


        },
        overloads: {
            "UpdateHeading(float, Vector3, AxisState, AxisState.Recentering, bool)": "UpdateHeading$1"
        }
    });
    /*Cinemachine.CinemachineOrbitalTransposer end.*/

    /*Cinemachine.CinemachineStateDrivenCamera start.*/
    /**
     * This is a virtual camera "manager" that owns and manages a collection
         of child Virtual Cameras.  These child vcams are mapped to individual states in
         an animation state machine, allowing you to associate specific vcams to specific
         animation states.  When that state is active in the state machine, then the
         associated camera will be activated.
         You can define custom blends and transitions between child cameras.
         In order to use this behaviour, you must have an animated target (i.e. an object
         animated with a state machine) to drive the behaviour.
     *
     * @public
     * @class Cinemachine.CinemachineStateDrivenCamera
     * @augments Cinemachine.CinemachineVirtualCameraBase
     */
    Bridge.define("Cinemachine.CinemachineStateDrivenCamera", {
        inherits: [Cinemachine.CinemachineVirtualCameraBase],
        statics: {
            methods: {
                /*Cinemachine.CinemachineStateDrivenCamera.CreateFakeHash:static start.*/
                /**
                 * API for the inspector editor.  Animation module does not have hashes
                     for state parents, so we have to invent them in order to implement nested state
                     handling
                 *
                 * @static
                 * @public
                 * @this Cinemachine.CinemachineStateDrivenCamera
                 * @memberof Cinemachine.CinemachineStateDrivenCamera
                 * @param   {number}                       parentHash    
                 * @param   {UnityEngine.AnimationClip}    clip
                 * @return  {number}
                 */
                CreateFakeHash: function (parentHash, clip) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#CreateFakeHash", this ); }

                    return UnityEngine.Animator.StringToHash(parentHash + "_" + (clip.name || ""));
                },
                /*Cinemachine.CinemachineStateDrivenCamera.CreateFakeHash:static end.*/


            }
        },
        fields: {
            /**
             * Default object for the camera children to look at (the aim target), if not specified in a child rig.  May be
                 empty
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type UnityEngine.Transform
             */
            m_LookAt: null,
            /**
             * Default object for the camera children wants to move with (the body target), if not specified in a child rig.
                 May be empty
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type UnityEngine.Transform
             */
            m_Follow: null,
            /**
             * The state machine whose state changes will drive this camera's choice of active child
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type UnityEngine.Animator
             */
            m_AnimatedTarget: null,
            /**
             * Which layer in the target FSM to observe
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type number
             */
            m_LayerIndex: 0,
            /**
             * When enabled, the current camera and blend will be indicated in the game window, for debugging
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @default false
             * @type boolean
             */
            m_ShowDebugText: false,
            /**
             * Internal API for the editor.  Do not use this field
             *
             * @instance
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type Array.<Cinemachine.CinemachineVirtualCameraBase>
             */
            m_ChildCameras: null,
            /**
             * The set of instructions associating virtual cameras with states.
                 These instructions are used to choose the live child at any given moment
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type Array.<Cinemachine.CinemachineStateDrivenCamera.Instruction>
             */
            m_Instructions: null,
            /**
             * The blend which is used if you don't explicitly define a blend between two Virtual Camera children.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type Cinemachine.CinemachineBlendDefinition
             */
            m_DefaultBlend: null,
            /**
             * This is the asset which contains custom settings for specific child blends.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type Cinemachine.CinemachineBlenderSettings
             */
            m_CustomBlends: null,
            /**
             * Internal API for the Inspector editor
             *
             * @instance
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @type Array.<Cinemachine.CinemachineStateDrivenCamera.ParentHash>
             */
            m_ParentHash: null,
            /**
             * Get the current "best" child virtual camera, that would be chosen
                 if the State Driven Camera were active.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @function LiveChild
             * @type Cinemachine.ICinemachineCamera
             */
            LiveChild: null,
            TransitioningFrom: null,
            m_State: null,
            mHashCache: null,
            mActivationTime: 0,
            mActiveInstruction: null,
            mPendingActivationTime: 0,
            mPendingInstruction: null,
            mActiveBlend: null,
            mInstructionDictionary: null,
            mStateParentLookup: null,
            m_clipInfoList: null
        },
        props: {
            /**
             * Gets a brief debug description of this virtual camera, for use when displayiong debug info
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @function Description
             * @type string
             */
            Description: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#Description#get", this ); }

                    // Show the active camera and blend
                    if (this.mActiveBlend != null) {
                        return this.mActiveBlend.Description;
                    }

                    var vcam = this.LiveChild;
                    if (vcam == null) {
                        return "(none)";
                    }

                    var sb = Cinemachine.Utility.CinemachineDebug.SBFromPool();
                    sb.append("[");
                    sb.append(vcam.Cinemachine$ICinemachineCamera$Name);
                    sb.append("]");
                    var text = sb.toString();
                    Cinemachine.Utility.CinemachineDebug.ReturnToPool(sb);
                    return text;
                }
            },
            /**
             * The State of the current live child
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @function State
             * @type Cinemachine.CameraState
             */
            State: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#State#get", this ); }

                    return this.m_State.$clone();
                }
            },
            /**
             * Get the current LookAt target.  Returns parent's LookAt if parent
                 is non-null and no specific LookAt defined for this camera
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @function LookAt
             * @type UnityEngine.Transform
             */
            LookAt: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#LookAt#get", this ); }

                    return this.ResolveLookAt(this.m_LookAt);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#LookAt#set", this ); }

                    this.m_LookAt = value;
                }
            },
            /**
             * Get the current Follow target.  Returns parent's Follow if parent
                 is non-null and no specific Follow defined for this camera
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @function Follow
             * @type UnityEngine.Transform
             */
            Follow: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#Follow#get", this ); }

                    return this.ResolveFollow(this.m_Follow);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#Follow#set", this ); }

                    this.m_Follow = value;
                }
            },
            /**
             * The list of child cameras.  These are just the immediate children in the hierarchy.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @function ChildCameras
             * @type Array.<Cinemachine.CinemachineVirtualCameraBase>
             */
            ChildCameras: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#ChildCameras#get", this ); }

                    this.UpdateListOfChildren();
                    return this.m_ChildCameras;
                }
            },
            /**
             * Is there a blend in progress?
             *
             * @instance
             * @public
             * @readonly
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @function IsBlending
             * @type boolean
             */
            IsBlending: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#IsBlending#get", this ); }

                    return this.mActiveBlend != null;
                }
            }
        },
        alias: [
            "Description", "Cinemachine$ICinemachineCamera$Description",
            "IsLiveChild", "Cinemachine$ICinemachineCamera$IsLiveChild",
            "State", "Cinemachine$ICinemachineCamera$State",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#init", this ); }

                this.m_DefaultBlend = new Cinemachine.CinemachineBlendDefinition();
                this.m_State = new Cinemachine.CameraState();
                this.mActiveInstruction = new Cinemachine.CinemachineStateDrivenCamera.Instruction();
                this.mPendingInstruction = new Cinemachine.CinemachineStateDrivenCamera.Instruction();
                this.m_ShowDebugText = false;
                this.m_DefaultBlend = new Cinemachine.CinemachineBlendDefinition.$ctor1(Cinemachine.CinemachineBlendDefinition.Style.EaseInOut, 0.5);
                this.m_State = Cinemachine.CameraState.Default.$clone();
                this.m_clipInfoList = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
            }
        },
        methods: {
            /*Cinemachine.CinemachineStateDrivenCamera.IsLiveChild start.*/
            /**
             * Check whether the vcam a live child of this camera.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineStateDrivenCamera
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @param   {Cinemachine.ICinemachineCamera}    vcam                 The Virtual Camera to check
             * @param   {boolean}                           dominantChildOnly    If truw, will only return true if this vcam is the dominat live child
             * @return  {boolean}                                                True if the vcam is currently actively influencing the state of this vcam
             */
            IsLiveChild: function (vcam, dominantChildOnly) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#IsLiveChild", this ); }

                if (dominantChildOnly === void 0) { dominantChildOnly = false; }
                return Bridge.referenceEquals(vcam, this.LiveChild) || this.mActiveBlend != null && this.mActiveBlend.Uses(vcam);
            },
            /*Cinemachine.CinemachineStateDrivenCamera.IsLiveChild end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the vcam that a target got warped,
                 so that the vcam can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineStateDrivenCamera
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#OnTargetObjectWarped", this ); }

                var $t;
                this.UpdateListOfChildren();
                $t = Bridge.getEnumerator(this.m_ChildCameras);
                try {
                    while ($t.moveNext()) {
                        var vcam = $t.Current;
                        vcam.OnTargetObjectWarped(target, positionDelta.$clone());
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
            },
            /*Cinemachine.CinemachineStateDrivenCamera.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.OnTransitionFromCamera start.*/
            /**
             * Notification that this virtual camera is going live.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineStateDrivenCamera
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}               worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                            deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#OnTransitionFromCamera", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTransitionFromCamera.call(this, fromCam, worldUp.$clone(), deltaTime);
                this.InvokeOnTransitionInExtensions(fromCam, worldUp.$clone(), deltaTime);
                this.TransitioningFrom = fromCam;
                this.InternalUpdateCameraState(worldUp.$clone(), deltaTime);
            },
            /*Cinemachine.CinemachineStateDrivenCamera.OnTransitionFromCamera end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.InternalUpdateCameraState start.*/
            /**
             * Internal use only.  Do not call this method.
                 Called by CinemachineCore at designated update time
                 so the vcam can position itself and track its targets.  This implementation
                 updates all the children, chooses the best one, and implements any required blending.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineStateDrivenCamera
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @param   {UnityEngine.Vector3}    worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                 deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#InternalUpdateCameraState", this ); }

                this.UpdateListOfChildren();
                var best = this.ChooseCurrentCamera();
                if (UnityEngine.MonoBehaviour.op_Inequality(best, null) && !best.gameObject.activeInHierarchy) {
                    best.gameObject.SetActive(true);
                    best.UpdateCameraState(worldUp.$clone(), deltaTime);
                }

                var previousCam = this.LiveChild;
                this.LiveChild = best;

                // Are we transitioning cameras?
                if (!Bridge.referenceEquals(previousCam, this.LiveChild) && this.LiveChild != null) {
                    // Notify incoming camera of transition
                    this.LiveChild.Cinemachine$ICinemachineCamera$OnTransitionFromCamera(previousCam, worldUp.$clone(), deltaTime);

                    // Generate Camera Activation event in the brain if live
                    Cinemachine.CinemachineCore.Instance.GenerateCameraActivationEvent(this.LiveChild, previousCam);

                    if (previousCam != null) {
                        // Create a blend (will be null if a cut)
                        this.mActiveBlend = this.CreateBlend(previousCam, this.LiveChild, this.LookupBlend(previousCam, this.LiveChild), this.mActiveBlend);

                        // If cutting, generate a camera cut event if live
                        if (this.mActiveBlend == null || !this.mActiveBlend.Uses(previousCam)) {
                            Cinemachine.CinemachineCore.Instance.GenerateCameraCutEvent(this.LiveChild);
                        }
                    }
                }

                // Advance the current blend (if any)
                if (this.mActiveBlend != null) {
                    this.mActiveBlend.TimeInBlend += deltaTime >= 0 ? deltaTime : this.mActiveBlend.Duration;
                    if (this.mActiveBlend.IsComplete) {
                        this.mActiveBlend = null;
                    }
                }

                if (this.mActiveBlend != null) {
                    this.mActiveBlend.UpdateCameraState(worldUp.$clone(), deltaTime);
                    this.m_State = this.mActiveBlend.State.$clone();
                } else if (this.LiveChild != null) {
                    if (this.TransitioningFrom != null) {
                        this.LiveChild.Cinemachine$ICinemachineCamera$OnTransitionFromCamera(this.TransitioningFrom, worldUp.$clone(), deltaTime);
                    }

                    this.m_State = this.LiveChild.Cinemachine$ICinemachineCamera$State.$clone();
                }

                this.TransitioningFrom = null;
                this.InvokePostPipelineStageCallback(this, Cinemachine.CinemachineCore.Stage.Finalize, Bridge.ref(this, "m_State"), deltaTime);
                this.PreviousStateIsValid = true;
            },
            /*Cinemachine.CinemachineStateDrivenCamera.InternalUpdateCameraState end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.OnEnable start.*/
            /**
             * Makes sure the internal child cache is up to date
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineStateDrivenCamera
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#OnEnable", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnEnable.call(this);
                this.InvalidateListOfChildren();
                this.mActiveBlend = null;
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.remove(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.combine(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
            },
            /*Cinemachine.CinemachineStateDrivenCamera.OnEnable end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#OnDisable", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnDisable.call(this);
                Cinemachine.Utility.CinemachineDebug.OnGUIHandlers = Bridge.fn.remove(Cinemachine.Utility.CinemachineDebug.OnGUIHandlers, Bridge.fn.cacheBind(this, this.OnGuiHandler));
            },
            /*Cinemachine.CinemachineStateDrivenCamera.OnDisable end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.OnTransformChildrenChanged start.*/
            /**
             * Makes sure the internal child cache is up to date
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineStateDrivenCamera
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @return  {void}
             */
            OnTransformChildrenChanged: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#OnTransformChildrenChanged", this ); }

                this.InvalidateListOfChildren();
            },
            /*Cinemachine.CinemachineStateDrivenCamera.OnTransformChildrenChanged end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.OnGuiHandler start.*/
            /**
             * @instance
             * @private
             * @this Cinemachine.CinemachineStateDrivenCamera
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @return  {void}
             */
            OnGuiHandler: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#OnGuiHandler", this ); }

                if (!this.m_ShowDebugText) {
                    Cinemachine.Utility.CinemachineDebug.ReleaseScreenPos(this);
                } else {
                    var sb = Cinemachine.Utility.CinemachineDebug.SBFromPool();
                    sb.append(this.Name);
                    sb.append(": ");
                    sb.append(this.Description);
                    var text = sb.toString();
                    var r = Cinemachine.Utility.CinemachineDebug.GetScreenPos(this, text, UnityEngine.GUI.skin.box);
                    UnityEngine.GUI.Label$1(r.$clone(), text, UnityEngine.GUI.skin.box);
                    Cinemachine.Utility.CinemachineDebug.ReturnToPool(sb);
                }
            },
            /*Cinemachine.CinemachineStateDrivenCamera.OnGuiHandler end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.LookupFakeHash start.*/
            LookupFakeHash: function (parentHash, clip) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#LookupFakeHash", this ); }

                var $t;
                if (this.mHashCache == null) {
                    this.mHashCache = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Collections.Generic.List$1(Cinemachine.CinemachineStateDrivenCamera.HashPair))).ctor();
                }

                var list = { v : null };
                if (!this.mHashCache.tryGetValue(clip, list)) {
                    list.v = new (System.Collections.Generic.List$1(Cinemachine.CinemachineStateDrivenCamera.HashPair)).ctor();
                    this.mHashCache.setItem(clip, list.v);
                }

                for (var i = 0; i < list.v.Count; ++i) {
                    if (list.v.getItem(i).$clone().parentHash === parentHash) {
                        return list.v.getItem(i).$clone().hash;
                    }
                }

                var newHash = Cinemachine.CinemachineStateDrivenCamera.CreateFakeHash(parentHash, clip);
                list.v.add(($t = new Cinemachine.CinemachineStateDrivenCamera.HashPair(), $t.parentHash = parentHash, $t.hash = newHash, $t));
                return newHash;
            },
            /*Cinemachine.CinemachineStateDrivenCamera.LookupFakeHash end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.InvalidateListOfChildren start.*/
            InvalidateListOfChildren: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#InvalidateListOfChildren", this ); }

                this.m_ChildCameras = null;
                this.LiveChild = null;
            },
            /*Cinemachine.CinemachineStateDrivenCamera.InvalidateListOfChildren end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.UpdateListOfChildren start.*/
            UpdateListOfChildren: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#UpdateListOfChildren", this ); }

                var $t;
                if (this.m_ChildCameras != null && this.mInstructionDictionary != null && this.mStateParentLookup != null) {
                    return;
                }

                var list = new (System.Collections.Generic.List$1(Cinemachine.CinemachineVirtualCameraBase)).ctor();
                var kids = this.GetComponentsInChildren$1(Cinemachine.CinemachineVirtualCameraBase, true);
                $t = Bridge.getEnumerator(kids);
                try {
                    while ($t.moveNext()) {
                        var k = $t.Current;
                        if (UnityEngine.Component.op_Equality(k.transform.parent, this.transform)) {
                            list.add(k);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.m_ChildCameras = list.ToArray();
                this.ValidateInstructions();
            },
            /*Cinemachine.CinemachineStateDrivenCamera.UpdateListOfChildren end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.ValidateInstructions start.*/
            /**
             * Internal API for the inspector editor.
             *
             * @instance
             * @this Cinemachine.CinemachineStateDrivenCamera
             * @memberof Cinemachine.CinemachineStateDrivenCamera
             * @return  {void}
             */
            ValidateInstructions: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#ValidateInstructions", this ); }

                var $t;
                if (this.m_Instructions == null) {
                    this.m_Instructions = System.Array.init(0, function (){
                        return new Cinemachine.CinemachineStateDrivenCamera.Instruction();
                    }, Cinemachine.CinemachineStateDrivenCamera.Instruction);
                }

                this.mInstructionDictionary = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32)).ctor();
                for (var i = 0; i < this.m_Instructions.length; ++i) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Instructions[i].m_VirtualCamera, null) && UnityEngine.Component.op_Inequality(this.m_Instructions[i].m_VirtualCamera.transform.parent, this.transform)) {
                        this.m_Instructions[i].m_VirtualCamera = null;
                    }

                    this.mInstructionDictionary.setItem(this.m_Instructions[i].m_FullHash, i);
                }

                // Create the parent lookup
                this.mStateParentLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32)).ctor();
                if (this.m_ParentHash != null) {
                    $t = Bridge.getEnumerator(this.m_ParentHash);
                    try {
                        while ($t.moveNext()) {
                            var i1 = $t.Current.$clone();
                            this.mStateParentLookup.setItem(i1.m_Hash, i1.m_ParentHash);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Zap the cached current instructions
                this.mActivationTime = (this.mPendingActivationTime = 0);
                this.mActiveBlend = null;
            },
            /*Cinemachine.CinemachineStateDrivenCamera.ValidateInstructions end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.ChooseCurrentCamera start.*/
            ChooseCurrentCamera: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#ChooseCurrentCamera", this ); }

                if (this.m_ChildCameras == null || this.m_ChildCameras.length === 0) {
                    this.mActivationTime = 0;
                    return null;
                }

                var defaultCam = this.m_ChildCameras[0];
                if (UnityEngine.Component.op_Equality(this.m_AnimatedTarget, null) || !this.m_AnimatedTarget.gameObject.activeSelf || this.m_AnimatedTarget.runtimeAnimatorController == null || this.m_LayerIndex < 0 || !this.m_AnimatedTarget.hasBoundPlayables || this.m_LayerIndex >= this.m_AnimatedTarget.layerCount) {
                    this.mActivationTime = 0;
                    return defaultCam;
                }

                // Get the current state
                var hash;
                if (this.m_AnimatedTarget.IsInTransition(this.m_LayerIndex)) {
                    // Force "current" state to be the state we're transitionaing to
                    var info = this.m_AnimatedTarget.GetNextAnimatorStateInfo(this.m_LayerIndex);
                    hash = info.fullPathHash;
                    if (this.m_AnimatedTarget.GetNextAnimatorClipInfoCount(this.m_LayerIndex) > 1) {
                        this.m_AnimatedTarget.GetNextAnimatorClipInfo(this.m_LayerIndex, this.m_clipInfoList);
                        hash = this.GetClipHash(info.fullPathHash, this.m_clipInfoList);
                    }
                } else {
                    var info1 = this.m_AnimatedTarget.GetCurrentAnimatorStateInfo(this.m_LayerIndex);
                    hash = info1.fullPathHash;
                    if (this.m_AnimatedTarget.GetCurrentAnimatorClipInfoCount(this.m_LayerIndex) > 1) {
                        this.m_AnimatedTarget.GetCurrentAnimatorClipInfo(this.m_LayerIndex, this.m_clipInfoList);
                        hash = this.GetClipHash(info1.fullPathHash, this.m_clipInfoList);
                    }
                }

                // If we don't have an instruction for this state, find a suitable default
                while (hash !== 0 && !this.mInstructionDictionary.containsKey(hash)) {
                    hash = this.mStateParentLookup.containsKey(hash) ? this.mStateParentLookup.getItem(hash) : 0;
                }

                var now = UnityEngine.Time.time;
                if (this.mActivationTime !== 0) {
                    // Is it active now?
                    if (this.mActiveInstruction.m_FullHash === hash) {
                        // Yes, cancel any pending
                        this.mPendingActivationTime = 0;
                        return this.mActiveInstruction.m_VirtualCamera;
                    }

                    // Is it pending?
                    if (this.PreviousStateIsValid) {
                        if (this.mPendingActivationTime !== 0 && this.mPendingInstruction.m_FullHash === hash) {
                            // Has it been pending long enough, and are we allowed to switch away
                            // from the active action?
                            if (now - this.mPendingActivationTime > this.mPendingInstruction.m_ActivateAfter && (now - this.mActivationTime > this.mActiveInstruction.m_MinDuration || this.mPendingInstruction.m_VirtualCamera.Priority > this.mActiveInstruction.m_VirtualCamera.Priority)) {
                                // Yes, activate it now
                                this.mActiveInstruction = this.mPendingInstruction.$clone();
                                this.mActivationTime = now;
                                this.mPendingActivationTime = 0;
                            }

                            return this.mActiveInstruction.m_VirtualCamera;
                        }
                    }
                }

                // Neither active nor pending.
                this.mPendingActivationTime = 0; // cancel the pending, if any

                if (!this.mInstructionDictionary.containsKey(hash)) {
                    // No defaults set, we just ignore this state
                    if (this.mActivationTime !== 0) {
                        return this.mActiveInstruction.m_VirtualCamera;
                    }

                    return defaultCam;
                }

                // Can we activate it now?
                var newInstr = this.m_Instructions[this.mInstructionDictionary.getItem(hash)].$clone();
                if (UnityEngine.MonoBehaviour.op_Equality(newInstr.m_VirtualCamera, null)) {
                    newInstr.m_VirtualCamera = defaultCam;
                }

                if (this.PreviousStateIsValid && this.mActivationTime > 0) {
                    if (newInstr.m_ActivateAfter > 0 || now - this.mActivationTime < this.mActiveInstruction.m_MinDuration && newInstr.m_VirtualCamera.Priority <= this.mActiveInstruction.m_VirtualCamera.Priority) {
                        // Too early - make it pending
                        this.mPendingInstruction = newInstr.$clone();
                        this.mPendingActivationTime = now;
                        if (this.mActivationTime !== 0) {
                            return this.mActiveInstruction.m_VirtualCamera;
                        }

                        return defaultCam;
                    }
                }

                // Activate now
                this.mActiveInstruction = newInstr.$clone();
                this.mActivationTime = now;
                return this.mActiveInstruction.m_VirtualCamera;
            },
            /*Cinemachine.CinemachineStateDrivenCamera.ChooseCurrentCamera end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.GetClipHash start.*/
            GetClipHash: function (hash, clips) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#GetClipHash", this ); }

                // Is there an animation clip substate?
                if (clips.Count > 1) {
                    // Find the strongest-weighted one
                    var bestClip = -1;
                    for (var i = 0; i < clips.Count; ++i) {
                        if (bestClip < 0 || clips.getItem(i).$clone().weight > clips.getItem(bestClip).$clone().weight) {
                            bestClip = i;
                        }
                    }

                    // Use its hash
                    if (bestClip >= 0 && clips.getItem(bestClip).$clone().weight > 0) {
                        hash = this.LookupFakeHash(hash, clips.getItem(bestClip).$clone().clip);
                    }
                }

                return hash;
            },
            /*Cinemachine.CinemachineStateDrivenCamera.GetClipHash end.*/

            /*Cinemachine.CinemachineStateDrivenCamera.LookupBlend start.*/
            LookupBlend: function (fromKey, toKey) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineStateDrivenCamera#LookupBlend", this ); }

                // Get the blend curve that's most appropriate for these cameras
                var blend = this.m_DefaultBlend.$clone();
                if (this.m_CustomBlends != null) {
                    var fromCameraName = fromKey != null ? fromKey.Cinemachine$ICinemachineCamera$Name : "";
                    var toCameraName = toKey != null ? toKey.Cinemachine$ICinemachineCamera$Name : "";
                    blend = this.m_CustomBlends.GetBlendForVirtualCameras(fromCameraName, toCameraName, blend.$clone());
                }

                if (!Bridge.staticEquals(Cinemachine.CinemachineCore.GetBlendOverride, null)) {
                    blend = Cinemachine.CinemachineCore.GetBlendOverride(fromKey, toKey, blend.$clone(), this);
                }

                return blend.$clone();
            },
            /*Cinemachine.CinemachineStateDrivenCamera.LookupBlend end.*/


        }
    });
    /*Cinemachine.CinemachineStateDrivenCamera end.*/
    /**
     * @memberof Cinemachine
     * @callback Cinemachine.CinemachineVirtualCamera.DestroyPipelineDelegate
     * @param   {UnityEngine.GameObject}    pipeline
     * @return  {void}
     */

    /**
     * @memberof Cinemachine
     * @callback Cinemachine.CinemachineVirtualCamera.CreatePipelineDelegate
     * @param   {Cinemachine.CinemachineVirtualCamera}            vcam        
     * @param   {string}                                          name        
     * @param   {Array.<Cinemachine.CinemachineComponentBase>}    copyFrom
     * @return  {UnityEngine.Transform}
     */


    /*Cinemachine.CinemachineVirtualCamera start.*/
    /**
     * This behaviour is intended to be attached to an empty Transform GameObject,
         and it represents a Virtual Camera within the Unity scene.
         The Virtual Camera will animate its Transform according to the rules contained
         in its CinemachineComponent pipeline (Aim, Body, and Noise).  When the virtual
         camera is Live, the Unity camera will assume the position and orientation
         of the virtual camera.
         A virtual camera is not a camera. Instead, it can be thought of as a camera controller,
         not unlike a cameraman. It can drive the Unity Camera and control its position,
         orientation, lens settings, and PostProcessing effects. Each Virtual Camera owns
         its own Cinemachine Component Pipeline, through which you provide the instructions
         for dynamically tracking specific game objects.
         A virtual camera is very lightweight, and does no rendering of its own. It merely
         tracks interesting GameObjects, and positions itself accordingly. A typical game
         can have dozens of virtual cameras, each set up to follow a particular character
         or capture a particular event.
         A Virtual Camera can be in any of three states:
         * **Live**: The virtual camera is actively controlling the Unity Camera. The
         virtual camera is tracking its targets and being updated every frame.
         * **Standby**: The virtual camera is tracking its targets and being updated
         every frame, but no Unity Camera is actively being controlled by it. This is
         the state of a virtual camera that is enabled in the scene but perhaps at a
         lower priority than the Live virtual camera.
         * **Disabled**: The virtual camera is present but disabled in the scene. It is
         not actively tracking its targets and so consumes no processing power. However,
         the virtual camera can be made live from the Timeline.
         The Unity Camera can be driven by any virtual camera in the scene. The game
         logic can choose the virtual camera to make live by manipulating the virtual
         cameras' enabled flags and their priorities, based on game logic.
         In order to be driven by a virtual camera, the Unity Camera must have a CinemachineBrain
         behaviour, which will select the most eligible virtual camera based on its priority
         or on other criteria, and will manage blending.
     *
     * @public
     * @class Cinemachine.CinemachineVirtualCamera
     * @augments Cinemachine.CinemachineVirtualCameraBase
     * @see {@link CinemachineVirtualCameraBase}
     * @see {@link LensSettings}
     * @see {@link CinemachineComposer}
     * @see {@link CinemachineTransposer}
     * @see {@link CinemachineBasicMultiChannelPerlin}
     */
    Bridge.define("Cinemachine.CinemachineVirtualCamera", {
        inherits: [Cinemachine.CinemachineVirtualCameraBase],
        statics: {
            fields: {
                /**
                 * This is the name of the hidden GameObject that will be created as a child object
                     of the virtual camera.  This hidden game object acts as a container for the polymorphic
                     CinemachineComponent pipeline.  The Inspector UI for the Virtual Camera
                     provides access to this pipleline, as do the CinemachineComponent-family of
                     public methods in this class.
                     The lifecycle of the pipeline GameObject is managed automatically.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineVirtualCamera
                 * @constant
                 * @default "cm"
                 * @type string
                 */
                PipelineName: null,
                /**
                 * Override component pipeline creation.
                     This needs to be done by the editor to support Undo.
                     The override must do exactly the same thing as the CreatePipeline method in this class.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineVirtualCamera
                 * @type Cinemachine.CinemachineVirtualCamera.CreatePipelineDelegate
                 */
                CreatePipelineOverride: null,
                /**
                 * Override component pipeline destruction.
                     This needs to be done by the editor to support Undo.
                 *
                 * @static
                 * @public
                 * @memberof Cinemachine.CinemachineVirtualCamera
                 * @type Cinemachine.CinemachineVirtualCamera.DestroyPipelineDelegate
                 */
                DestroyPipelineOverride: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#init", this ); }

                    this.PipelineName = "cm";
                }
            },
            methods: {
                /*Cinemachine.CinemachineVirtualCamera.SetFlagsForHiddenChild:static start.*/
                SetFlagsForHiddenChild: function (child) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#SetFlagsForHiddenChild", this ); }

                    if (UnityEngine.GameObject.op_Inequality(child, null)) {
                        if (Cinemachine.CinemachineCore.sShowHiddenObjects) {
                            child.hideFlags &= -4;
                        } else {
                            child.hideFlags |= 3;
                        }
                    }
                },
                /*Cinemachine.CinemachineVirtualCamera.SetFlagsForHiddenChild:static end.*/


            }
        },
        fields: {
            /**
             * The object that the camera wants to look at (the Aim target).
                 The Aim component of the CinemachineComponent pipeline
                 will refer to this target and orient the vcam in accordance with rules and
                 settings that are provided to it.
                 If this is null, then the vcam's Transform orientation will be used.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @type UnityEngine.Transform
             */
            m_LookAt: null,
            /**
             * The object that the camera wants to move with (the Body target).
                 The Body component of the CinemachineComponent pipeline
                 will refer to this target and position the vcam in accordance with rules and
                 settings that are provided to it.
                 If this is null, then the vcam's Transform position will be used.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @type UnityEngine.Transform
             */
            m_Follow: null,
            /**
             * Specifies the LensSettings of this Virtual Camera.
                 These settings will be transferred to the Unity camera when the vcam is live.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @type Cinemachine.LensSettings
             */
            m_Lens: null,
            /**
             * Collection of parameters that influence how this virtual camera transitions from
                 other virtual cameras
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @type Cinemachine.CinemachineVirtualCameraBase.TransitionParams
             */
            m_Transitions: null,
            /**
             * Legacy support
             *
             * @instance
             * @private
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @type number
             */
            m_LegacyBlendHint: 0,
            /**
             * API for the editor, to make the dragging of position handles behave better.
             *
             * @instance
             * @public
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @function UserIsDragging
             * @type boolean
             */
            UserIsDragging: false,
            m_State: null,
            m_ComponentPipeline: null,
            m_ComponentOwner: null,
            mCachedLookAtTarget: null,
            mCachedLookAtTargetVcam: null
        },
        props: {
            /**
             * The CameraState object holds all of the information
                 necessary to position the Unity camera.  It is the output of this class.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @function State
             * @type Cinemachine.CameraState
             */
            State: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#State#get", this ); }

                    return this.m_State.$clone();
                }
            },
            /**
             * Get the LookAt target for the Aim component in the Cinemachine pipeline.
                 If this vcam is a part of a meta-camera collection, then the owner's target
                 will be used if the local target is null.
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @function LookAt
             * @type UnityEngine.Transform
             */
            LookAt: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#LookAt#get", this ); }

                    return this.ResolveLookAt(this.m_LookAt);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#LookAt#set", this ); }

                    this.m_LookAt = value;
                }
            },
            /**
             * Get the Follow target for the Body component in the Cinemachine pipeline.
                 If this vcam is a part of a meta-camera collection, then the owner's target
                 will be used if the local target is null.
             *
             * @instance
             * @public
             * @override
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @function Follow
             * @type UnityEngine.Transform
             */
            Follow: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#Follow#get", this ); }

                    return this.ResolveFollow(this.m_Follow);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#Follow#set", this ); }

                    this.m_Follow = value;
                }
            }
        },
        alias: [
            "State", "Cinemachine$ICinemachineCamera$State",
            "LookAt", "Cinemachine$ICinemachineCamera$LookAt",
            "Follow", "Cinemachine$ICinemachineCamera$Follow",
            "InternalUpdateCameraState", "Cinemachine$ICinemachineCamera$InternalUpdateCameraState",
            "OnTargetObjectWarped", "Cinemachine$ICinemachineCamera$OnTargetObjectWarped",
            "OnTransitionFromCamera", "Cinemachine$ICinemachineCamera$OnTransitionFromCamera"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#init", this ); }

                this.m_Lens = new Cinemachine.LensSettings();
                this.m_Transitions = new Cinemachine.CinemachineVirtualCameraBase.TransitionParams();
                this.m_State = new Cinemachine.CameraState();
                this.m_Lens = Cinemachine.LensSettings.Default.$clone();
                this.m_State = Cinemachine.CameraState.Default.$clone();
            }
        },
        methods: {
            /*Cinemachine.CinemachineVirtualCamera.InternalUpdateCameraState start.*/
            /**
             * Internal use only.  Do not call this method.
                 Called by CinemachineCore at the appropriate Update time
                 so the vcam can position itself and track its targets.  This class will
                 invoke its pipeline and generate a CameraState for this frame.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @param   {UnityEngine.Vector3}    worldUp      
             * @param   {number}                 deltaTime
             * @return  {void}
             */
            InternalUpdateCameraState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#InternalUpdateCameraState", this ); }

                // Update the state by invoking the component pipeline
                this.m_State = this.CalculateNewState(worldUp.$clone(), deltaTime);
                this.ApplyPositionBlendMethod(Bridge.ref(this, "m_State"), this.m_Transitions.m_BlendHint);

                // Push the raw position back to the game object's transform, so it
                // moves along with the camera.
                if (!this.UserIsDragging) {
                    if (UnityEngine.Component.op_Inequality(this.Follow, null)) {
                        this.transform.position = this.State.RawPosition.$clone();
                    }

                    if (UnityEngine.Component.op_Inequality(this.LookAt, null)) {
                        this.transform.rotation = this.State.RawOrientation.$clone();
                    }
                }

                this.PreviousStateIsValid = true;
            },
            /*Cinemachine.CinemachineVirtualCamera.InternalUpdateCameraState end.*/

            /*Cinemachine.CinemachineVirtualCamera.OnEnable start.*/
            /**
             * Make sure that the pipeline cache is up-to-date.
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#OnEnable", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnEnable.call(this);
                this.m_State = this.PullStateFromVirtualCamera(pc.Vec3.UP.clone(), Bridge.ref(this, "m_Lens"));
                this.InvalidateComponentPipeline();

                // Can't add components during OnValidate
                if (this.ValidatingStreamVersion < 20170927) {
                    if (UnityEngine.Component.op_Inequality(this.Follow, null) && UnityEngine.MonoBehaviour.op_Equality(this.GetCinemachineComponent$1(Cinemachine.CinemachineCore.Stage.Body), null)) {
                        this.AddCinemachineComponent(Cinemachine.CinemachineHardLockToTarget);
                    }

                    if (UnityEngine.Component.op_Inequality(this.LookAt, null) && UnityEngine.MonoBehaviour.op_Equality(this.GetCinemachineComponent$1(Cinemachine.CinemachineCore.Stage.Aim), null)) {
                        this.AddCinemachineComponent(Cinemachine.CinemachineHardLookAt);
                    }
                }
            },
            /*Cinemachine.CinemachineVirtualCamera.OnEnable end.*/

            /*Cinemachine.CinemachineVirtualCamera.OnDestroy start.*/
            /**
             * Calls the DestroyPipelineDelegate for destroying the hidden
                 child object, to support undo.
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @return  {void}
             */
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#OnDestroy", this ); }

                var $t, $t1;
                // Make the pipeline visible instead of destroying - this is to keep Undo happy
                $t = Bridge.getEnumerator(this.transform);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, UnityEngine.Transform);
                        if (UnityEngine.MonoBehaviour.op_Inequality(child.GetComponent(Cinemachine.CinemachinePipeline), null)) {
                            $t1 = child.gameObject;
                            $t1.hideFlags &= -4;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnDestroy.call(this);
            },
            /*Cinemachine.CinemachineVirtualCamera.OnDestroy end.*/

            /*Cinemachine.CinemachineVirtualCamera.OnValidate start.*/
            /**
             * Enforce bounds for fields, when changed in inspector.
             *
             * @instance
             * @protected
             * @override
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @return  {void}
             */
            OnValidate: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#OnValidate", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnValidate.call(this);
                this.m_Lens.Validate();
                if (this.m_LegacyBlendHint !== Cinemachine.CinemachineVirtualCameraBase.BlendHint.None) {
                    this.m_Transitions.m_BlendHint = this.m_LegacyBlendHint;
                    this.m_LegacyBlendHint = Cinemachine.CinemachineVirtualCameraBase.BlendHint.None;
                }
            },
            /*Cinemachine.CinemachineVirtualCamera.OnValidate end.*/

            /*Cinemachine.CinemachineVirtualCamera.OnTransformChildrenChanged start.*/
            OnTransformChildrenChanged: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#OnTransformChildrenChanged", this ); }

                this.InvalidateComponentPipeline();
            },
            /*Cinemachine.CinemachineVirtualCamera.OnTransformChildrenChanged end.*/

            /*Cinemachine.CinemachineVirtualCamera.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#Reset", this ); }

                this.DestroyPipeline();
            },
            /*Cinemachine.CinemachineVirtualCamera.Reset end.*/

            /*Cinemachine.CinemachineVirtualCamera.DestroyPipeline start.*/
            /**
             * Destroy any existing pipeline container.
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @return  {void}
             */
            DestroyPipeline: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#DestroyPipeline", this ); }

                var $t, $t1;
                var oldPipeline = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                $t = Bridge.getEnumerator(this.transform);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, UnityEngine.Transform);
                        if (UnityEngine.MonoBehaviour.op_Inequality(child.GetComponent(Cinemachine.CinemachinePipeline), null)) {
                            oldPipeline.add(child);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(oldPipeline);
                try {
                    while ($t1.moveNext()) {
                        var child1 = $t1.Current;
                        if (!Bridge.staticEquals(Cinemachine.CinemachineVirtualCamera.DestroyPipelineOverride, null)) {
                            Cinemachine.CinemachineVirtualCamera.DestroyPipelineOverride(child1.gameObject);
                        } else {
                            UnityEngine.MonoBehaviour.Destroy(child1.gameObject);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.m_ComponentOwner = null;
                this.PreviousStateIsValid = false;
            },
            /*Cinemachine.CinemachineVirtualCamera.DestroyPipeline end.*/

            /*Cinemachine.CinemachineVirtualCamera.CreatePipeline start.*/
            /**
             * Create a default pipeline container.
                 Note: copyFrom only supported in Editor, not build
             *
             * @instance
             * @private
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @param   {Cinemachine.CinemachineVirtualCamera}    copyFrom
             * @return  {UnityEngine.Transform}
             */
            CreatePipeline: function (copyFrom) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#CreatePipeline", this ); }

                var components = null;
                if (UnityEngine.MonoBehaviour.op_Inequality(copyFrom, null)) {
                    copyFrom.InvalidateComponentPipeline(); // make sure it's up to date
                    components = copyFrom.GetComponentPipeline();
                }

                var newPipeline = null;
                if (!Bridge.staticEquals(Cinemachine.CinemachineVirtualCamera.CreatePipelineOverride, null)) {
                    newPipeline = Cinemachine.CinemachineVirtualCamera.CreatePipelineOverride(this, Cinemachine.CinemachineVirtualCamera.PipelineName, components);
                } else {
                    var go = new UnityEngine.GameObject.$ctor2(Cinemachine.CinemachineVirtualCamera.PipelineName);
                    go.transform.parent = this.transform;
                    go.AddComponent(Cinemachine.CinemachinePipeline);
                    newPipeline = go.transform;
                }

                this.PreviousStateIsValid = false;
                return newPipeline;
            },
            /*Cinemachine.CinemachineVirtualCamera.CreatePipeline end.*/

            /*Cinemachine.CinemachineVirtualCamera.InvalidateComponentPipeline start.*/
            /**
             * Editor API: Call this when changing the pipeline from the editor.
                 Will force a rebuild of the pipeline cache.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @return  {void}
             */
            InvalidateComponentPipeline: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#InvalidateComponentPipeline", this ); }

                this.m_ComponentPipeline = null;
            },
            /*Cinemachine.CinemachineVirtualCamera.InvalidateComponentPipeline end.*/

            /*Cinemachine.CinemachineVirtualCamera.GetComponentOwner start.*/
            /**
             * Get the hidden CinemachinePipeline child object.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @return  {UnityEngine.Transform}
             */
            GetComponentOwner: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#GetComponentOwner", this ); }

                this.UpdateComponentPipeline();
                return this.m_ComponentOwner;
            },
            /*Cinemachine.CinemachineVirtualCamera.GetComponentOwner end.*/

            /*Cinemachine.CinemachineVirtualCamera.GetComponentPipeline start.*/
            /**
             * Get the component pipeline owned by the hidden child pipline container.
                 For most purposes, it is preferable to use the GetCinemachineComponent method.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @return  {Array.<Cinemachine.CinemachineComponentBase>}
             */
            GetComponentPipeline: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#GetComponentPipeline", this ); }

                this.UpdateComponentPipeline();
                return this.m_ComponentPipeline;
            },
            /*Cinemachine.CinemachineVirtualCamera.GetComponentPipeline end.*/

            /*Cinemachine.CinemachineVirtualCamera.GetCinemachineComponent$1 start.*/
            /**
             * Get the component set for a specific stage.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @param   {number}                                  stage    The stage for which we want the component
             * @return  {Cinemachine.CinemachineComponentBase}             The Cinemachine component for that stage, or null if not defined
             */
            GetCinemachineComponent$1: function (stage) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#GetCinemachineComponent$1", this ); }

                var $t;
                var components = this.GetComponentPipeline();
                if (components != null) {
                    $t = Bridge.getEnumerator(components);
                    try {
                        while ($t.moveNext()) {
                            var c = $t.Current;
                            if (c.Stage === stage) {
                                return c;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                return null;
            },
            /*Cinemachine.CinemachineVirtualCamera.GetCinemachineComponent$1 end.*/

            /*Cinemachine.CinemachineVirtualCamera.GetCinemachineComponent start.*/
            /**
             * Get an existing component of a specific type from the cinemachine pipeline.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @param   {Function}    T
             * @return  {T}
             */
            GetCinemachineComponent: function (T) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#GetCinemachineComponent", this ); }

                var $t;
                var components = this.GetComponentPipeline();
                if (components != null) {
                    $t = Bridge.getEnumerator(components);
                    try {
                        while ($t.moveNext()) {
                            var c = $t.Current;
                            if (Bridge.is(c, T)) {
                                return Bridge.as(c, T);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                return null;
            },
            /*Cinemachine.CinemachineVirtualCamera.GetCinemachineComponent end.*/

            /*Cinemachine.CinemachineVirtualCamera.AddCinemachineComponent start.*/
            /**
             * Add a component to the cinemachine pipeline.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @param   {Function}    T
             * @return  {T}
             */
            AddCinemachineComponent: function (T) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#AddCinemachineComponent", this ); }

                // Get the existing components
                var owner = this.GetComponentOwner();
                var components = owner.GetComponents(Cinemachine.CinemachineComponentBase);

                var component = owner.gameObject.AddComponent(T);
                if (component != null && components != null) {
                    // Remove the existing components at that stage
                    var stage = component.Stage;
                    for (var i = components.length - 1; i >= 0; --i) {
                        if (components[i].Stage === stage) {
                            components[i].enabled = false;
                            Cinemachine.RuntimeUtility.DestroyObject(components[i]);
                        }
                    }
                }

                this.InvalidateComponentPipeline();
                return component;
            },
            /*Cinemachine.CinemachineVirtualCamera.AddCinemachineComponent end.*/

            /*Cinemachine.CinemachineVirtualCamera.DestroyCinemachineComponent start.*/
            /**
             * Remove a component from the cinemachine pipeline.
             *
             * @instance
             * @public
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @param   {Function}    T
             * @return  {void}
             */
            DestroyCinemachineComponent: function (T) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#DestroyCinemachineComponent", this ); }

                var $t;
                var components = this.GetComponentPipeline();
                if (components != null) {
                    $t = Bridge.getEnumerator(components);
                    try {
                        while ($t.moveNext()) {
                            var c = $t.Current;
                            if (Bridge.is(c, T)) {
                                c.enabled = false;
                                Cinemachine.RuntimeUtility.DestroyObject(c);
                                this.InvalidateComponentPipeline();
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Cinemachine.CinemachineVirtualCamera.DestroyCinemachineComponent end.*/

            /*Cinemachine.CinemachineVirtualCamera.UpdateComponentPipeline start.*/
            UpdateComponentPipeline: function () {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#UpdateComponentPipeline", this ); }

                var $t, $t1;
                var isPrefab = false;
                // Early out if we're up-to-date
                if (UnityEngine.Component.op_Inequality(this.m_ComponentOwner, null) && this.m_ComponentPipeline != null) {
                    return;
                }

                this.m_ComponentOwner = null;
                var list = new (System.Collections.Generic.List$1(Cinemachine.CinemachineComponentBase)).ctor();
                $t = Bridge.getEnumerator(this.transform);
                try {
                    while ($t.moveNext()) {
                        var child = Bridge.cast($t.Current, UnityEngine.Transform);
                        if (UnityEngine.MonoBehaviour.op_Inequality(child.GetComponent(Cinemachine.CinemachinePipeline), null)) {
                            this.m_ComponentOwner = child;
                            var components = child.GetComponents(Cinemachine.CinemachineComponentBase);
                            $t1 = Bridge.getEnumerator(components);
                            try {
                                while ($t1.moveNext()) {
                                    var c = $t1.Current;
                                    if (c.enabled) {
                                        list.add(c);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Make sure we have a pipeline owner
                isPrefab = this.gameObject.scene.name == null; // causes a small GC alloc
                if (UnityEngine.Component.op_Equality(this.m_ComponentOwner, null) && !isPrefab) {
                    this.m_ComponentOwner = this.CreatePipeline(null);
                }

                // Make sure the pipeline stays hidden, even through prefab
                if (UnityEngine.Component.op_Inequality(this.m_ComponentOwner, null)) {
                    Cinemachine.CinemachineVirtualCamera.SetFlagsForHiddenChild(this.m_ComponentOwner.gameObject);
                }

                if (UnityEngine.Component.op_Inequality(this.m_ComponentOwner, null) && UnityEngine.GameObject.op_Inequality(this.m_ComponentOwner.gameObject, null)) {
                    // Sort the pipeline
                    list.Sort$2(function (c1, c2) {
                        return c1.Stage - c2.Stage;
                    });
                    this.m_ComponentPipeline = list.ToArray();
                }
            },
            /*Cinemachine.CinemachineVirtualCamera.UpdateComponentPipeline end.*/

            /*Cinemachine.CinemachineVirtualCamera.CalculateNewState start.*/
            CalculateNewState: function (worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#CalculateNewState", this ); }

                // Initialize the camera state, in case the game object got moved in the editor
                var state = { v : this.PullStateFromVirtualCamera(worldUp.$clone(), Bridge.ref(this, "m_Lens")) };

                var lookAtTarget = this.LookAt;
                if (UnityEngine.Component.op_Inequality(lookAtTarget, this.mCachedLookAtTarget)) {
                    this.mCachedLookAtTarget = lookAtTarget;
                    this.mCachedLookAtTargetVcam = null;
                    if (UnityEngine.Component.op_Inequality(lookAtTarget, null)) {
                        this.mCachedLookAtTargetVcam = lookAtTarget.GetComponent(Cinemachine.CinemachineVirtualCameraBase);
                    }
                }

                if (UnityEngine.Component.op_Inequality(lookAtTarget, null)) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.mCachedLookAtTargetVcam, null)) {
                        state.v.ReferenceLookAt = this.mCachedLookAtTargetVcam.State.FinalPosition.$clone();
                    } else {
                        state.v.ReferenceLookAt = lookAtTarget.position.$clone();
                    }
                }

                // Update the state by invoking the component pipeline
                var curStage = Cinemachine.CinemachineCore.Stage.Body;
                this.UpdateComponentPipeline(); // avoid GetComponentPipeline() here because of GC
                var hasAim = false;
                if (this.m_ComponentPipeline != null) {
                    for (var i = 0; i < this.m_ComponentPipeline.length; ++i) {
                        this.m_ComponentPipeline[i].PrePipelineMutateCameraState(state, deltaTime);
                        if (this.m_ComponentPipeline[i].Stage === Cinemachine.CinemachineCore.Stage.Aim) {
                            hasAim = true;
                        }
                    }

                    for (var i1 = 0; i1 < this.m_ComponentPipeline.length; ++i1) {
                        curStage = this.AdvancePipelineStage(state, deltaTime, curStage, this.m_ComponentPipeline[i1].Stage, hasAim);
                        this.m_ComponentPipeline[i1].MutateCameraState(state, deltaTime);
                    }
                }

                this.AdvancePipelineStage(state, deltaTime, curStage, 4, hasAim);
                return state.v.$clone();
            },
            /*Cinemachine.CinemachineVirtualCamera.CalculateNewState end.*/

            /*Cinemachine.CinemachineVirtualCamera.AdvancePipelineStage start.*/
            AdvancePipelineStage: function (state, deltaTime, curStage, maxStage, hasAim) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#AdvancePipelineStage", this ); }

                while (curStage < maxStage) {
                    if (!hasAim && curStage === Cinemachine.CinemachineCore.Stage.Aim) {
                        state.v.BlendHint |= Cinemachine.CameraState.BlendHintValue.IgnoreLookAtTarget;
                    }

                    this.InvokePostPipelineStageCallback(this, curStage, state, deltaTime);
                    ++curStage;
                }

                return curStage;
            },
            /*Cinemachine.CinemachineVirtualCamera.AdvancePipelineStage end.*/

            /*Cinemachine.CinemachineVirtualCamera.SetStateRawPosition start.*/
            SetStateRawPosition: function (pos) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#SetStateRawPosition", this ); }

                this.m_State.RawPosition = pos.$clone();
            },
            /*Cinemachine.CinemachineVirtualCamera.SetStateRawPosition end.*/

            /*Cinemachine.CinemachineVirtualCamera.OnTargetObjectWarped start.*/
            /**
             * This is called to notify the vcam that a target got warped,
                 so that the vcam can update its internal state to make the camera
                 also warp seamlessy.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @param   {UnityEngine.Transform}    target           The object that was warped
             * @param   {UnityEngine.Vector3}      positionDelta    The amount the target's position changed
             * @return  {void}
             */
            OnTargetObjectWarped: function (target, positionDelta) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#OnTargetObjectWarped", this ); }

                if (UnityEngine.Component.op_Equality(target, this.Follow)) {
                    this.transform.position = this.transform.position.$clone().add( positionDelta.$clone() );
                    this.m_State.RawPosition = this.m_State.RawPosition.$clone().add( positionDelta.$clone() );
                }

                this.UpdateComponentPipeline(); // avoid GetComponentPipeline() here because of GC
                if (this.m_ComponentPipeline != null) {
                    for (var i = 0; i < this.m_ComponentPipeline.length; ++i) {
                        this.m_ComponentPipeline[i].OnTargetObjectWarped(target, positionDelta.$clone());
                    }
                }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTargetObjectWarped.call(this, target, positionDelta.$clone());
            },
            /*Cinemachine.CinemachineVirtualCamera.OnTargetObjectWarped end.*/

            /*Cinemachine.CinemachineVirtualCamera.OnTransitionFromCamera start.*/
            /**
             * If we are transitioning from another vcam, grab the position from it.
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.CinemachineVirtualCamera
             * @memberof Cinemachine.CinemachineVirtualCamera
             * @param   {Cinemachine.ICinemachineCamera}    fromCam      The camera being deactivated.  May be null.
             * @param   {UnityEngine.Vector3}               worldUp      Default world Up, set by the CinemachineBrain
             * @param   {number}                            deltaTime    Delta time for time-based effects (ignore if less than or equal to 0)
             * @return  {void}
             */
            OnTransitionFromCamera: function (fromCam, worldUp, deltaTime) {
if ( TRACE ) { TRACE( "Cinemachine.CinemachineVirtualCamera#OnTransitionFromCamera", this ); }

                Cinemachine.CinemachineVirtualCameraBase.prototype.OnTransitionFromCamera.call(this, fromCam, worldUp.$clone(), deltaTime);
                this.InvokeOnTransitionInExtensions(fromCam, worldUp.$clone(), deltaTime);
                var forceUpdate = false;

                if (this.m_Transitions.m_InheritPosition && fromCam != null) {
                    this.transform.position = fromCam.Cinemachine$ICinemachineCamera$State.FinalPosition.$clone();
                    //transform.rotation = fromCam.State.RawOrientation;
                    this.PreviousStateIsValid = false;
                    forceUpdate = true;
                }

                this.UpdateComponentPipeline(); // avoid GetComponentPipeline() here because of GC
                if (this.m_ComponentPipeline != null) {
                    for (var i = 0; i < this.m_ComponentPipeline.length; ++i) {
                        if (this.m_ComponentPipeline[i].OnTransitionFromCamera(fromCam, worldUp.$clone(), deltaTime, Bridge.ref(this, "m_Transitions"))) {
                            forceUpdate = true;
                        }
                    }
                }

                if (forceUpdate) {
                    this.InternalUpdateCameraState(worldUp.$clone(), deltaTime);
                    this.InternalUpdateCameraState(worldUp.$clone(), deltaTime);
                } else {
                    this.UpdateCameraState(worldUp.$clone(), deltaTime);
                }

                if (this.m_Transitions.m_OnCameraLive != null) {
                    this.m_Transitions.m_OnCameraLive.Invoke(this, fromCam);
                }
            },
            /*Cinemachine.CinemachineVirtualCamera.OnTransitionFromCamera end.*/


        },
        overloads: {
            "GetCinemachineComponent(CinemachineCore.Stage)": "GetCinemachineComponent$1"
        }
    });
    /*Cinemachine.CinemachineVirtualCamera end.*/

    /*Cinemachine.NoiseSettings start.*/
    /**
     * This is an asset that defines a noise profile.  A noise profile is the
         shape of the noise signal as a function of time.  You can build arbitrarily complex shapes by
         combining different base perlin noise frequencies at different amplitudes.
         The frequencies and amplitudes should be chosen with care, to ensure an interesting
         noise quality that is not obviously repetitive.
         As a mathematical side-note, any arbitrary periodic curve can be broken down into a
         series of fixed-amplitude sine-waves added together.  This is called fourier decomposition,
         and is the basis of much signal processing.  It doesn't really have much to do with this
         asset, but it's super interesting!
     *
     * @public
     * @class Cinemachine.NoiseSettings
     * @augments Cinemachine.SignalSourceAsset
     */
    Bridge.define("Cinemachine.NoiseSettings", {
        inherits: [Cinemachine.SignalSourceAsset],
        statics: {
            methods: {
                /*Cinemachine.NoiseSettings.GetCombinedFilterResults:static start.*/
                /**
                 * Get the noise signal value at a specific time
                 *
                 * @static
                 * @public
                 * @this Cinemachine.NoiseSettings
                 * @memberof Cinemachine.NoiseSettings
                 * @param   {Array.<Cinemachine.NoiseSettings.TransformNoiseParams>}    noiseParams    The parameters that define the noise function
                 * @param   {number}                                                    time           The time at which to sample the noise function
                 * @param   {UnityEngine.Vector3}                                       timeOffsets    Start time offset for each channel
                 * @return  {UnityEngine.Vector3}                                                      The 3-channel noise signal value at the specified time
                 */
                GetCombinedFilterResults: function (noiseParams, time, timeOffsets) {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings#GetCombinedFilterResults", this ); }

                    var pos = pc.Vec3.ZERO.clone();
                    if (noiseParams != null) {
                        for (var i = 0; i < noiseParams.length; ++i) {
                            pos = pos.$clone().add( noiseParams[i].GetValueAt(time, timeOffsets.$clone()) );
                        }
                    }

                    return pos.$clone();
                },
                /*Cinemachine.NoiseSettings.GetCombinedFilterResults:static end.*/


            }
        },
        fields: {
            /**
             * The array of orientation noise channels for this <pre><code>NoiseSettings</code></pre>
             *
             * @instance
             * @public
             * @memberof Cinemachine.NoiseSettings
             * @type Array.<Cinemachine.NoiseSettings.TransformNoiseParams>
             */
            OrientationNoise: null,
            /**
             * The array of positional noise channels for this <pre><code>NoiseSettings</code></pre>
             *
             * @instance
             * @public
             * @memberof Cinemachine.NoiseSettings
             * @type Array.<Cinemachine.NoiseSettings.TransformNoiseParams>
             */
            PositionNoise: null
        },
        props: {
            /**
             * Returns the total length in seconds of the signal.
                 Returns 0 for signals of indeterminate length.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof Cinemachine.NoiseSettings
             * @function SignalDuration
             * @type number
             */
            SignalDuration: {
                get: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings#SignalDuration#get", this ); }

                    return 0;
                }
            }
        },
        alias: [
            "SignalDuration", "Cinemachine$ISignalSource6D$SignalDuration",
            "GetSignal", "Cinemachine$ISignalSource6D$GetSignal"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings#init", this ); }

                this.OrientationNoise = System.Array.init(0, function (){
                    return new Cinemachine.NoiseSettings.TransformNoiseParams();
                }, Cinemachine.NoiseSettings.TransformNoiseParams);
                this.PositionNoise = System.Array.init(0, function (){
                    return new Cinemachine.NoiseSettings.TransformNoiseParams();
                }, Cinemachine.NoiseSettings.TransformNoiseParams);
            }
        },
        methods: {
            /*Cinemachine.NoiseSettings.GetSignal start.*/
            /**
             * Interface for raw signal provider
             *
             * @instance
             * @public
             * @override
             * @this Cinemachine.NoiseSettings
             * @memberof Cinemachine.NoiseSettings
             * @param   {number}                    timeSinceSignalStart    
             * @param   {UnityEngine.Vector3}       pos                     The position impulse signal
             * @param   {UnityEngine.Quaternion}    rot                     The rotation impulse signal
             * @return  {void}
             */
            GetSignal: function (timeSinceSignalStart, pos, rot) {
if ( TRACE ) { TRACE( "Cinemachine.NoiseSettings#GetSignal", this ); }

                var $t;
                pos.v = Cinemachine.NoiseSettings.GetCombinedFilterResults(this.PositionNoise, timeSinceSignalStart, pc.Vec3.ZERO.clone());
                rot.v = ($t = Cinemachine.NoiseSettings.GetCombinedFilterResults(this.OrientationNoise, timeSinceSignalStart, pc.Vec3.ZERO.clone()), new pc.Quat().setFromEulerAngles_Unity( $t.x, $t.y, $t.z ));
            },
            /*Cinemachine.NoiseSettings.GetSignal end.*/


        }
    });
    /*Cinemachine.NoiseSettings end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","Cinemachine","UnityEngine"];

    /*Cinemachine.AxisBase start.*/
    $m("Cinemachine.AxisBase", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The maximum value for the axis")],"a":2,"n":"m_MaxValue","t":4,"rt":$n[0].Single,"sn":"m_MaxValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The minimum value for the axis")],"a":2,"n":"m_MinValue","t":4,"rt":$n[0].Single,"sn":"m_MinValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Cinemachine.NoSaveDuringPlayAttribute(),new UnityEngine.TooltipAttribute("The current value of the axis.")],"a":2,"n":"m_Value","t":4,"rt":$n[0].Single,"sn":"m_Value","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If checked, then the axis will wrap around at the min/max values, forming a loop")],"a":2,"n":"m_Wrap","t":4,"rt":$n[0].Boolean,"sn":"m_Wrap","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.AxisBase end.*/

    /*Cinemachine.AxisState start.*/
    $m("Cinemachine.AxisState", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new Cinemachine.NoSaveDuringPlayAttribute(),new UnityEngine.TooltipAttribute("The current value of the axis.")],"a":2,"n":"Value","t":4,"rt":$n[0].Single,"sn":"Value","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The amount of time in seconds it takes to accelerate to MaxSpeed with the supplied Axis at its maximum value")],"a":2,"n":"m_AccelTime","t":4,"rt":$n[0].Single,"sn":"m_AccelTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The amount of time in seconds it takes to decelerate the axis to zero if the supplied axis is in a neutral position")],"a":2,"n":"m_DecelTime","t":4,"rt":$n[0].Single,"sn":"m_DecelTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_AxisName"),new UnityEngine.TooltipAttribute("The name of this axis as specified in Unity Input manager. Setting to an empty string will disable the automatic updating of this axis")],"a":2,"n":"m_InputAxisName","t":4,"rt":$n[0].String,"sn":"m_InputAxisName"},{"at":[new Cinemachine.NoSaveDuringPlayAttribute(),new UnityEngine.TooltipAttribute("The value of the input axis.  A value of 0 means no input.  You can drive this directly from a custom input system, or you can set the Axis Name and have the value driven by the internal Input Manager")],"a":2,"n":"m_InputAxisValue","t":4,"rt":$n[0].Single,"sn":"m_InputAxisValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_InvertAxis"),new UnityEngine.TooltipAttribute("If checked, then the raw value of the input axis will be inverted before it is used")],"a":2,"n":"m_InvertInput","t":4,"rt":$n[0].Boolean,"sn":"m_InvertInput","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The maximum speed of this axis in units/second, or the input value multiplier, depending on the Speed Mode")],"a":2,"n":"m_MaxSpeed","t":4,"rt":$n[0].Single,"sn":"m_MaxSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The maximum value for the axis")],"a":2,"n":"m_MaxValue","t":4,"rt":$n[0].Single,"sn":"m_MaxValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The minimum value for the axis")],"a":2,"n":"m_MinValue","t":4,"rt":$n[0].Single,"sn":"m_MinValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Automatic recentering to at-rest position")],"a":2,"n":"m_Recentering","t":4,"rt":$n[1].AxisState.Recentering,"sn":"m_Recentering"},{"at":[new UnityEngine.TooltipAttribute("How to interpret the Max Speed setting: in units/second, or as a direct input value multiplier")],"a":2,"n":"m_SpeedMode","t":4,"rt":$n[1].AxisState.SpeedMode,"sn":"m_SpeedMode","box":function ($v) { return Bridge.box($v, Cinemachine.AxisState.SpeedMode, System.Enum.toStringFn(Cinemachine.AxisState.SpeedMode));}},{"at":[new UnityEngine.TooltipAttribute("If checked, then the axis will wrap around at the min/max values, forming a loop")],"a":2,"n":"m_Wrap","t":4,"rt":$n[0].Boolean,"sn":"m_Wrap","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.AxisState end.*/

    /*Cinemachine.AxisState+Recentering start.*/
    $m("Cinemachine.AxisState.Recentering", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HeadingDefinition")],"a":1,"n":"m_LegacyHeadingDefinition","t":4,"rt":$n[0].Int32,"sn":"m_LegacyHeadingDefinition","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_VelocityFilterStrength")],"a":1,"n":"m_LegacyVelocityFilterStrength","t":4,"rt":$n[0].Int32,"sn":"m_LegacyVelocityFilterStrength","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("How long it takes to reach destination once recentering has started.")],"a":2,"n":"m_RecenteringTime","t":4,"rt":$n[0].Single,"sn":"m_RecenteringTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If no user input has been detected on the axis, the axis will wait this long in seconds before recentering.")],"a":2,"n":"m_WaitTime","t":4,"rt":$n[0].Single,"sn":"m_WaitTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If checked, will enable automatic recentering of the axis. If unchecked, recenting is disabled.")],"a":2,"n":"m_enabled","t":4,"rt":$n[0].Boolean,"sn":"m_enabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.AxisState+Recentering end.*/

    /*Cinemachine.CinemachineComponentBase start.*/
    $m("Cinemachine.CinemachineComponentBase", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(1)]}; }, $n);
    /*Cinemachine.CinemachineComponentBase end.*/

    /*Cinemachine.CinemachineBlendDefinition start.*/
    $m("Cinemachine.CinemachineBlendDefinition", function () { return {"at":[new System.SerializableAttribute(),new Cinemachine.DocumentationSortingAttribute(2)],"m":[{"at":[new UnityEngine.TooltipAttribute("Shape of the blend curve")],"a":2,"n":"m_Style","t":4,"rt":$n[1].CinemachineBlendDefinition.Style,"sn":"m_Style","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineBlendDefinition.Style, System.Enum.toStringFn(Cinemachine.CinemachineBlendDefinition.Style));}},{"at":[new UnityEngine.TooltipAttribute("Duration of the blend, in seconds")],"a":2,"n":"m_Time","t":4,"rt":$n[0].Single,"sn":"m_Time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineBlendDefinition end.*/

    /*Cinemachine.CinemachineBlendDefinition+Style start.*/
    $m("Cinemachine.CinemachineBlendDefinition.Style", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineBlendDefinition+Style end.*/

    /*Cinemachine.CinemachineBlenderSettings start.*/
    $m("Cinemachine.CinemachineBlenderSettings", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The array containing explicitly defined blends between two Virtual Cameras")],"a":2,"n":"m_CustomBlends","t":4,"rt":System.Array.type(Cinemachine.CinemachineBlenderSettings.CustomBlend),"sn":"m_CustomBlends"}]}; }, $n);
    /*Cinemachine.CinemachineBlenderSettings end.*/

    /*Cinemachine.CinemachineBlenderSettings+CustomBlend start.*/
    $m("Cinemachine.CinemachineBlenderSettings.CustomBlend", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new Cinemachine.CinemachineBlendDefinitionPropertyAttribute(),new UnityEngine.TooltipAttribute("Blend curve definition")],"a":2,"n":"m_Blend","t":4,"rt":$n[1].CinemachineBlendDefinition,"sn":"m_Blend"},{"at":[new UnityEngine.TooltipAttribute("When blending from this camera")],"a":2,"n":"m_From","t":4,"rt":$n[0].String,"sn":"m_From"},{"at":[new UnityEngine.TooltipAttribute("When blending to this camera")],"a":2,"n":"m_To","t":4,"rt":$n[0].String,"sn":"m_To"}]}; }, $n);
    /*Cinemachine.CinemachineBlenderSettings+CustomBlend end.*/

    /*Cinemachine.CinemachineBlendListCamera+Instruction start.*/
    $m("Cinemachine.CinemachineBlendListCamera.Instruction", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new Cinemachine.CinemachineBlendDefinitionPropertyAttribute(),new UnityEngine.TooltipAttribute("How to blend to the next virtual camera in the list (if any)")],"a":2,"n":"m_Blend","t":4,"rt":$n[1].CinemachineBlendDefinition,"sn":"m_Blend"},{"at":[new UnityEngine.TooltipAttribute("How long to wait (in seconds) before activating the next virtual camera in the list (if any)")],"a":2,"n":"m_Hold","t":4,"rt":$n[0].Single,"sn":"m_Hold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The virtual camera to activate when this instruction becomes active")],"a":2,"n":"m_VirtualCamera","t":4,"rt":$n[1].CinemachineVirtualCameraBase,"sn":"m_VirtualCamera"}]}; }, $n);
    /*Cinemachine.CinemachineBlendListCamera+Instruction end.*/

    /*Cinemachine.CinemachineBrain start.*/
    $m("Cinemachine.CinemachineBrain", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineBrain"),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The update time for the Brain, i.e. when the blends are evaluated and the brain's transform is updated")],"a":2,"n":"m_BlendUpdateMethod","t":4,"rt":$n[1].CinemachineBrain.BrainUpdateMethod,"sn":"m_BlendUpdateMethod","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineBrain.BrainUpdateMethod, System.Enum.toStringFn(Cinemachine.CinemachineBrain.BrainUpdateMethod));}},{"at":[new UnityEngine.TooltipAttribute("This event will fire whenever a virtual camera goes live.  If a blend is involved, then the event will fire on the first frame of the blend.")],"a":2,"n":"m_CameraActivatedEvent","t":4,"rt":$n[1].CinemachineBrain.VcamActivatedEvent,"sn":"m_CameraActivatedEvent"},{"at":[new UnityEngine.TooltipAttribute("This event will fire whenever a virtual camera goes live and there is no blend")],"a":2,"n":"m_CameraCutEvent","t":4,"rt":$n[1].CinemachineBrain.BrainEvent,"sn":"m_CameraCutEvent"},{"at":[new UnityEngine.TooltipAttribute("This is the asset that contains custom settings for blends between specific virtual cameras in your scene")],"a":2,"n":"m_CustomBlends","t":4,"rt":$n[1].CinemachineBlenderSettings,"sn":"m_CustomBlends"},{"at":[new Cinemachine.CinemachineBlendDefinitionPropertyAttribute(),new UnityEngine.TooltipAttribute("The blend that is used in cases where you haven't explicitly defined a blend between two Virtual Cameras")],"a":2,"n":"m_DefaultBlend","t":4,"rt":$n[1].CinemachineBlendDefinition,"sn":"m_DefaultBlend"},{"at":[new UnityEngine.TooltipAttribute("When enabled, the cameras will always respond in real-time to user input and damping, even if the game is running in slow motion")],"a":2,"n":"m_IgnoreTimeScale","t":4,"rt":$n[0].Boolean,"sn":"m_IgnoreTimeScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("When enabled, the camera's frustum will be shown at all times in the scene view")],"a":2,"n":"m_ShowCameraFrustum","t":4,"rt":$n[0].Boolean,"sn":"m_ShowCameraFrustum","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("When enabled, the current camera and blend will be indicated in the game window, for debugging")],"a":2,"n":"m_ShowDebugText","t":4,"rt":$n[0].Boolean,"sn":"m_ShowDebugText","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The update time for the vcams.  Use FixedUpdate if all your targets are animated during FixedUpdate (e.g. RigidBodies), LateUpdate if all your targets are animated during the normal Update loop, and SmartUpdate if you want Cinemachine to do the appropriate thing on a per-target basis.  SmartUpdate is the recommended setting")],"a":2,"n":"m_UpdateMethod","t":4,"rt":$n[1].CinemachineBrain.UpdateMethod,"sn":"m_UpdateMethod","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineBrain.UpdateMethod, System.Enum.toStringFn(Cinemachine.CinemachineBrain.UpdateMethod));}},{"at":[new UnityEngine.TooltipAttribute("If set, this object's Y axis will define the worldspace Up vector for all the virtual cameras.  This is useful for instance in top-down game environments.  If not set, Up is worldspace Y.  Setting this appropriately is important, because Virtual Cameras don't like looking straight up or straight down.")],"a":2,"n":"m_WorldUpOverride","t":4,"rt":$n[2].Transform,"sn":"m_WorldUpOverride"}]}; }, $n);
    /*Cinemachine.CinemachineBrain end.*/

    /*Cinemachine.CinemachineBrain+BrainUpdateMethod start.*/
    $m("Cinemachine.CinemachineBrain.BrainUpdateMethod", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineBrain+BrainUpdateMethod end.*/

    /*Cinemachine.CinemachineBrain+UpdateMethod start.*/
    $m("Cinemachine.CinemachineBrain.UpdateMethod", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineBrain+UpdateMethod end.*/

    /*Cinemachine.CinemachineExtension start.*/
    $m("Cinemachine.CinemachineExtension", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(1)]}; }, $n);
    /*Cinemachine.CinemachineExtension end.*/

    /*Cinemachine.CinemachineImpulseSource start.*/
    $m("Cinemachine.CinemachineImpulseSource", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new Cinemachine.CinemachineImpulseDefinitionPropertyAttribute()],"a":2,"n":"m_ImpulseDefinition","t":4,"rt":$n[1].CinemachineImpulseDefinition,"sn":"m_ImpulseDefinition"}]}; }, $n);
    /*Cinemachine.CinemachineImpulseSource end.*/

    /*Cinemachine.CinemachineCore start.*/
    $m("Cinemachine.CinemachineCore", function () { return {"m":[{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.ctor()],"a":1,"n":"InitializeModule","is":true,"t":8,"sn":"InitializeModule","rt":$n[0].Void}]}; }, $n);
    /*Cinemachine.CinemachineCore end.*/

    /*Cinemachine.CinemachineDollyCart start.*/
    $m("Cinemachine.CinemachineDollyCart", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The path to follow")],"a":2,"n":"m_Path","t":4,"rt":$n[1].CinemachinePathBase,"sn":"m_Path"},{"at":[new UnityEngine.TooltipAttribute("The position along the path at which the cart will be placed.  This can be animated directly or, if the velocity is non-zero, will be updated automatically.  The value is interpreted according to the Position Units setting."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_CurrentDistance")],"a":2,"n":"m_Position","t":4,"rt":$n[0].Single,"sn":"m_Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("How to interpret the Path Position.  If set to Path Units, values are as follows: 0 represents the first waypoint on the path, 1 is the second, and so on.  Values in-between are points on the path in between the waypoints.  If set to Distance, then Path Position represents distance along the path.")],"a":2,"n":"m_PositionUnits","t":4,"rt":$n[1].CinemachinePathBase.PositionUnits,"sn":"m_PositionUnits","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachinePathBase.PositionUnits, System.Enum.toStringFn(Cinemachine.CinemachinePathBase.PositionUnits));}},{"at":[new UnityEngine.TooltipAttribute("Move the cart with this speed along the path.  The value is interpreted according to the Position Units setting."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_Velocity")],"a":2,"n":"m_Speed","t":4,"rt":$n[0].Single,"sn":"m_Speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("When to move the cart, if Velocity is non-zero")],"a":2,"n":"m_UpdateMethod","t":4,"rt":$n[1].CinemachineDollyCart.UpdateMethod,"sn":"m_UpdateMethod","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineDollyCart.UpdateMethod, System.Enum.toStringFn(Cinemachine.CinemachineDollyCart.UpdateMethod));}}]}; }, $n);
    /*Cinemachine.CinemachineDollyCart end.*/

    /*Cinemachine.CinemachineFramingTransposer+FramingMode start.*/
    $m("Cinemachine.CinemachineFramingTransposer.FramingMode", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineFramingTransposer+FramingMode end.*/

    /*Cinemachine.CinemachineFreeLook+Orbit start.*/
    $m("Cinemachine.CinemachineFreeLook.Orbit", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*Cinemachine.CinemachineFreeLook+Orbit end.*/

    /*Cinemachine.CinemachineGroupComposer+FramingMode start.*/
    $m("Cinemachine.CinemachineGroupComposer.FramingMode", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineGroupComposer+FramingMode end.*/

    /*Cinemachine.CinemachineImpulseDefinition start.*/
    $m("Cinemachine.CinemachineImpulseDefinition", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(1),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Gain to apply to the amplitudes defined in the signal source.  1 is normal.  Setting this to 0 completely mutes the signal.")],"a":2,"n":"m_AmplitudeGain","t":4,"rt":$n[0].Single,"sn":"m_AmplitudeGain","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("How the signal direction behaves as the listener moves away from the origin.")],"a":2,"n":"m_DirectionMode","t":4,"rt":$n[1].CinemachineImpulseManager.ImpulseEvent.DirectionMode,"sn":"m_DirectionMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineImpulseManager.ImpulseEvent.DirectionMode, System.Enum.toStringFn(Cinemachine.CinemachineImpulseManager.ImpulseEvent.DirectionMode));}},{"at":[new UnityEngine.TooltipAttribute("At this distance beyond the impact radius, the signal will have dissipated to zero.")],"a":2,"n":"m_DissipationDistance","t":4,"rt":$n[0].Single,"sn":"m_DissipationDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("This defines how the signal will dissipate with distance beyond the impact radius.")],"a":2,"n":"m_DissipationMode","t":4,"rt":$n[1].CinemachineImpulseManager.ImpulseEvent.DissipationMode,"sn":"m_DissipationMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode, System.Enum.toStringFn(Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode));}},{"at":[new UnityEngine.TooltipAttribute("Scale factor to apply to the time axis.  1 is normal.  Larger magnitudes will make the signal progress more rapidly.")],"a":2,"n":"m_FrequencyGain","t":4,"rt":$n[0].Single,"sn":"m_FrequencyGain","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Spatial Range"),new UnityEngine.TooltipAttribute("The signal will have full amplitude in this radius surrounding the impact point.  Beyond that it will dissipate with distance.")],"a":2,"n":"m_ImpactRadius","t":4,"rt":$n[0].Single,"sn":"m_ImpactRadius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Cinemachine.CinemachineImpulseChannelPropertyAttribute(),new UnityEngine.TooltipAttribute("Impulse events generated here will appear on the channels included in the mask.")],"a":2,"n":"m_ImpulseChannel","t":4,"rt":$n[0].Int32,"sn":"m_ImpulseChannel","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Randomize the signal start time")],"a":2,"n":"m_Randomize","t":4,"rt":$n[0].Boolean,"sn":"m_Randomize","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Signal Shape"),new UnityEngine.TooltipAttribute("Defines the signal that will be generated."),new Cinemachine.CinemachineEmbeddedAssetPropertyAttribute(true)],"a":2,"n":"m_RawSignal","t":4,"rt":$n[1].SignalSourceAsset,"sn":"m_RawSignal"},{"at":[new UnityEngine.TooltipAttribute("How to fit the signal into the envelope time")],"a":2,"n":"m_RepeatMode","t":4,"rt":$n[1].CinemachineImpulseDefinition.RepeatMode,"sn":"m_RepeatMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineImpulseDefinition.RepeatMode, System.Enum.toStringFn(Cinemachine.CinemachineImpulseDefinition.RepeatMode));}},{"at":[new UnityEngine.TooltipAttribute("This defines the time-envelope of the signal.  The raw signal will be time-scaled to fit in the envelope."),new Cinemachine.CinemachineImpulseEnvelopePropertyAttribute()],"a":2,"n":"m_TimeEnvelope","t":4,"rt":$n[1].CinemachineImpulseManager.EnvelopeDefinition,"sn":"m_TimeEnvelope"}]}; }, $n);
    /*Cinemachine.CinemachineImpulseDefinition end.*/

    /*Cinemachine.CinemachineImpulseManager start.*/
    $m("Cinemachine.CinemachineImpulseManager", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(1)]}; }, $n);
    /*Cinemachine.CinemachineImpulseManager end.*/

    /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition start.*/
    $m("Cinemachine.CinemachineImpulseManager.EnvelopeDefinition", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Normalized curve defining the shape of the start of the envelope.  If blank a default curve will be used")],"a":2,"n":"m_AttackShape","t":4,"rt":pc.AnimationCurve,"sn":"m_AttackShape"},{"at":[new UnityEngine.TooltipAttribute("Duration in seconds of the attack.  Attack curve will be scaled to fit.  Must be >= 0.")],"a":2,"n":"m_AttackTime","t":4,"rt":$n[0].Single,"sn":"m_AttackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Normalized curve defining the shape of the end of the envelope.  If blank a default curve will be used")],"a":2,"n":"m_DecayShape","t":4,"rt":pc.AnimationCurve,"sn":"m_DecayShape"},{"at":[new UnityEngine.TooltipAttribute("Duration in seconds of the decay.  Decay curve will be scaled to fit.  Must be >= 0.")],"a":2,"n":"m_DecayTime","t":4,"rt":$n[0].Single,"sn":"m_DecayTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If true, then duration is infinite.")],"a":2,"n":"m_HoldForever","t":4,"rt":$n[0].Boolean,"sn":"m_HoldForever","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("If checked, signal amplitude scaling will also be applied to the time envelope of the signal.  Stronger signals will last longer.")],"a":2,"n":"m_ScaleWithImpact","t":4,"rt":$n[0].Boolean,"sn":"m_ScaleWithImpact","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Duration in seconds of the central fully-scaled part of the envelope.  Must be >= 0.")],"a":2,"n":"m_SustainTime","t":4,"rt":$n[0].Single,"sn":"m_SustainTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineImpulseManager+EnvelopeDefinition end.*/

    /*Cinemachine.CinemachineImpulseManager+ImpulseEvent start.*/
    $m("Cinemachine.CinemachineImpulseManager.ImpulseEvent", function () { return {"m":[{"at":[new UnityEngine.TooltipAttribute("Channels on which this event will broadcast its signal.")],"a":2,"n":"m_Channel","t":4,"rt":$n[0].Int32,"sn":"m_Channel","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("How the signal direction behaves as the listener moves away from the source.")],"a":2,"n":"m_DirectionMode","t":4,"rt":$n[1].CinemachineImpulseManager.ImpulseEvent.DirectionMode,"sn":"m_DirectionMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineImpulseManager.ImpulseEvent.DirectionMode, System.Enum.toStringFn(Cinemachine.CinemachineImpulseManager.ImpulseEvent.DirectionMode));}},{"at":[new UnityEngine.TooltipAttribute("Distance over which the dissipation occurs.  Must be >= 0.")],"a":2,"n":"m_DissipationDistance","t":4,"rt":$n[0].Single,"sn":"m_DissipationDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("How the signal dissipates with distance.")],"a":2,"n":"m_DissipationMode","t":4,"rt":$n[1].CinemachineImpulseManager.ImpulseEvent.DissipationMode,"sn":"m_DissipationMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode, System.Enum.toStringFn(Cinemachine.CinemachineImpulseManager.ImpulseEvent.DissipationMode));}},{"at":[new UnityEngine.TooltipAttribute("Time-envelope of the signal.")],"a":2,"n":"m_Envelope","t":4,"rt":$n[1].CinemachineImpulseManager.EnvelopeDefinition,"sn":"m_Envelope"},{"at":[new UnityEngine.TooltipAttribute("Worldspace origin of the signal.")],"a":2,"n":"m_Position","t":4,"rt":$n[2].Vector3,"sn":"m_Position"},{"at":[new UnityEngine.TooltipAttribute("Radius around the signal origin that has full signal value.  Distance dissipation begins after this distance.")],"a":2,"n":"m_Radius","t":4,"rt":$n[0].Single,"sn":"m_Radius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Raw signal source.  The ouput of this will be scaled to fit in the envelope.")],"a":2,"n":"m_SignalSource","t":4,"rt":$n[1].ISignalSource6D,"sn":"m_SignalSource"},{"at":[new UnityEngine.TooltipAttribute("Start time of the event.")],"a":2,"n":"m_StartTime","t":4,"rt":$n[0].Single,"sn":"m_StartTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineImpulseManager+ImpulseEvent end.*/

    /*Cinemachine.CinemachineInputAxisDriver start.*/
    $m("Cinemachine.CinemachineInputAxisDriver", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The amount of time in seconds it takes to accelerate to a higher speed")],"a":2,"n":"accelTime","t":4,"rt":$n[0].Single,"sn":"accelTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The amount of time in seconds it takes to decelerate to a lower speed")],"a":2,"n":"decelTime","t":4,"rt":$n[0].Single,"sn":"decelTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Cinemachine.NoSaveDuringPlayAttribute(),new UnityEngine.TooltipAttribute("The value of the input axis.  A value of 0 means no input.  You can drive this directly from a custom input system, or you can set the Axis Name and have the value driven by the internal Input Manager")],"a":2,"n":"inputValue","t":4,"rt":$n[0].Single,"sn":"inputValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Multiply the input by this amount prior to processing.  Controls the input power.")],"a":2,"n":"multiplier","t":4,"rt":$n[0].Single,"sn":"multiplier","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The name of this axis as specified in Unity Input manager. Setting to an empty string will disable the automatic updating of this axis")],"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"}]}; }, $n);
    /*Cinemachine.CinemachineInputAxisDriver end.*/

    /*Cinemachine.CinemachineOrbitalTransposer+Heading start.*/
    $m("Cinemachine.CinemachineOrbitalTransposer.Heading", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.RangeAttribute(-180.0, 180.0),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HeadingBias"),new UnityEngine.TooltipAttribute("Where the camera is placed when the X-axis value is zero.  This is a rotation in degrees around the Y axis.  When this value is 0, the camera will be placed behind the target.  Nonzero offsets will rotate the zero position around the target.")],"a":2,"n":"m_Bias","t":4,"rt":$n[0].Single,"sn":"m_Bias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HeadingDefinition"),new UnityEngine.TooltipAttribute("How 'forward' is defined.  The camera will be placed by default behind the target.  PositionDelta will consider 'forward' to be the direction in which the target is moving.")],"a":2,"n":"m_Definition","t":4,"rt":$n[1].CinemachineOrbitalTransposer.Heading.HeadingDefinition,"sn":"m_Definition","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition, System.Enum.toStringFn(Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition));}},{"at":[new UnityEngine.RangeAttribute(0.0, 10.0),new UnityEngine.TooltipAttribute("Size of the velocity sampling window for target heading filter.  This filters out irregularities in the target's movement.  Used only if deriving heading from target's movement (PositionDelta or Velocity)")],"a":2,"n":"m_VelocityFilterStrength","t":4,"rt":$n[0].Int32,"sn":"m_VelocityFilterStrength","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Cinemachine.CinemachineOrbitalTransposer+Heading end.*/

    /*Cinemachine.CinemachineOrbitalTransposer+Heading+HeadingDefinition start.*/
    $m("Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineOrbitalTransposer+Heading+HeadingDefinition end.*/

    /*Cinemachine.CinemachinePathBase start.*/
    $m("Cinemachine.CinemachinePathBase", function () { return {"m":[{"at":[new UnityEngine.TooltipAttribute("The settings that control how the path will appear in the editor scene view.")],"a":2,"n":"m_Appearance","t":4,"rt":$n[1].CinemachinePathBase.Appearance,"sn":"m_Appearance"},{"at":[new UnityEngine.TooltipAttribute("Path samples per waypoint.  This is used for calculating path distances."),new UnityEngine.RangeAttribute(1.0, 100.0)],"a":2,"n":"m_Resolution","t":4,"rt":$n[0].Int32,"sn":"m_Resolution","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Cinemachine.CinemachinePathBase end.*/

    /*Cinemachine.CinemachinePath+Waypoint start.*/
    $m("Cinemachine.CinemachinePath.Waypoint", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Position in path-local space")],"a":2,"n":"position","t":4,"rt":$n[2].Vector3,"sn":"position"},{"at":[new UnityEngine.TooltipAttribute("Defines the roll of the path at this waypoint.  The other orientation axes are inferred from the tangent and world up.")],"a":2,"n":"roll","t":4,"rt":$n[0].Single,"sn":"roll","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Offset from the position, which defines the tangent of the curve at the waypoint.  The length of the tangent encodes the strength of the bezier handle.  The same handle is used symmetrically on both sides of the waypoint, to ensure smoothness.")],"a":2,"n":"tangent","t":4,"rt":$n[2].Vector3,"sn":"tangent"}]}; }, $n);
    /*Cinemachine.CinemachinePath+Waypoint end.*/

    /*Cinemachine.CinemachinePathBase+Appearance start.*/
    $m("Cinemachine.CinemachinePathBase.Appearance", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The color of the path itself when it is inactive in the editor")],"a":2,"n":"inactivePathColor","t":4,"rt":$n[2].Color,"sn":"inactivePathColor"},{"at":[new UnityEngine.TooltipAttribute("The color of the path itself when it is active in the editor")],"a":2,"n":"pathColor","t":4,"rt":$n[2].Color,"sn":"pathColor"},{"at":[new UnityEngine.TooltipAttribute("The width of the railroad-tracks that are drawn to represent the path"),new UnityEngine.RangeAttribute(0.0, 10.0)],"a":2,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachinePathBase+Appearance end.*/

    /*Cinemachine.CinemachinePipeline start.*/
    $m("Cinemachine.CinemachinePipeline", function () { return {"at":[new UnityEngine.AddComponentMenu.ctor("")]}; }, $n);
    /*Cinemachine.CinemachinePipeline end.*/

    /*Cinemachine.CinemachinePixelPerfect start.*/
    $m("Cinemachine.CinemachinePixelPerfect", function () { return {"at":[new UnityEngine.AddComponentMenu.ctor("")]}; }, $n);
    /*Cinemachine.CinemachinePixelPerfect end.*/

    /*Cinemachine.CinemachineSmoothPath+Waypoint start.*/
    $m("Cinemachine.CinemachineSmoothPath.Waypoint", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Position in path-local space")],"a":2,"n":"position","t":4,"rt":$n[2].Vector3,"sn":"position"},{"at":[new UnityEngine.TooltipAttribute("Defines the roll of the path at this waypoint.  The other orientation axes are inferred from the tangent and world up.")],"a":2,"n":"roll","t":4,"rt":$n[0].Single,"sn":"roll","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineSmoothPath+Waypoint end.*/

    /*Cinemachine.CinemachineStateDrivenCamera+Instruction start.*/
    $m("Cinemachine.CinemachineStateDrivenCamera.Instruction", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("How long to wait (in seconds) before activating the virtual camera. This filters out very short state durations")],"a":2,"n":"m_ActivateAfter","t":4,"rt":$n[0].Single,"sn":"m_ActivateAfter","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The full hash of the animation state")],"a":2,"n":"m_FullHash","t":4,"rt":$n[0].Int32,"sn":"m_FullHash","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("The minimum length of time (in seconds) to keep a virtual camera active")],"a":2,"n":"m_MinDuration","t":4,"rt":$n[0].Single,"sn":"m_MinDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The virtual camera to activate whrn the animation state becomes active")],"a":2,"n":"m_VirtualCamera","t":4,"rt":$n[1].CinemachineVirtualCameraBase,"sn":"m_VirtualCamera"}]}; }, $n);
    /*Cinemachine.CinemachineStateDrivenCamera+Instruction end.*/

    /*Cinemachine.CinemachineStateDrivenCamera+ParentHash start.*/
    $m("Cinemachine.CinemachineStateDrivenCamera.ParentHash", function () { return {"at":[new System.SerializableAttribute(),new Cinemachine.DocumentationSortingAttribute(0)]}; }, $n);
    /*Cinemachine.CinemachineStateDrivenCamera+ParentHash end.*/

    /*Cinemachine.CinemachineTargetGroup+PositionMode start.*/
    $m("Cinemachine.CinemachineTargetGroup.PositionMode", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineTargetGroup+PositionMode end.*/

    /*Cinemachine.CinemachineTargetGroup+RotationMode start.*/
    $m("Cinemachine.CinemachineTargetGroup.RotationMode", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineTargetGroup+RotationMode end.*/

    /*Cinemachine.CinemachineTargetGroup+Target start.*/
    $m("Cinemachine.CinemachineTargetGroup.Target", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The radius of the target, used for calculating the bounding box.  Cannot be negative")],"a":2,"n":"radius","t":4,"rt":$n[0].Single,"sn":"radius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The target objects.  This object's position and orientation will contribute to the group's average position and orientation, in accordance with its weight")],"a":2,"n":"target","t":4,"rt":$n[2].Transform,"sn":"target"},{"at":[new UnityEngine.TooltipAttribute("How much weight to give the target when averaging.  Cannot be negative")],"a":2,"n":"weight","t":4,"rt":$n[0].Single,"sn":"weight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineTargetGroup+Target end.*/

    /*Cinemachine.CinemachineTrackedDolly+AutoDolly start.*/
    $m("Cinemachine.CinemachineTrackedDolly.AutoDolly", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("If checked, will enable automatic dolly, which chooses a path position that is as close as possible to the Follow target.  Note: this can have significant performance impact")],"a":2,"n":"m_Enabled","t":4,"rt":$n[0].Boolean,"sn":"m_Enabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Offset, in current position units, from the closest point on the path to the follow target")],"a":2,"n":"m_PositionOffset","t":4,"rt":$n[0].Single,"sn":"m_PositionOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Search up to how many waypoints on either side of the current position.  Use 0 for Entire path.")],"a":2,"n":"m_SearchRadius","t":4,"rt":$n[0].Int32,"sn":"m_SearchRadius","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_StepsPerSegment"),new UnityEngine.TooltipAttribute("We search between waypoints by dividing the segment into this many straight pieces.  The higher the number, the more accurate the result, but performance is proportionally slower for higher numbers")],"a":2,"n":"m_SearchResolution","t":4,"rt":$n[0].Int32,"sn":"m_SearchResolution","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Cinemachine.CinemachineTrackedDolly+AutoDolly end.*/

    /*Cinemachine.CinemachineTrackedDolly+CameraUpMode start.*/
    $m("Cinemachine.CinemachineTrackedDolly.CameraUpMode", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineTrackedDolly+CameraUpMode end.*/

    /*Cinemachine.CinemachineTransposer+BindingMode start.*/
    $m("Cinemachine.CinemachineTransposer.BindingMode", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)]}; }, $n);
    /*Cinemachine.CinemachineTransposer+BindingMode end.*/

    /*Cinemachine.CinemachineTriggerAction start.*/
    $m("Cinemachine.CinemachineTriggerAction", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.HeaderAttribute("Trigger Object Filter"),new UnityEngine.TooltipAttribute("Only triggers generated by objects on these layers will be considered")],"a":2,"n":"m_LayerMask","t":4,"rt":$n[2].LayerMask,"sn":"m_LayerMask"},{"at":[new UnityEngine.TooltipAttribute("Repeat the action for all subsequent trigger entries")],"a":2,"n":"m_Repeating","t":4,"rt":$n[0].Boolean,"sn":"m_Repeating","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Cinemachine.NoSaveDuringPlayAttribute(),new UnityEngine.TooltipAttribute("Skip this many trigger entries before taking action")],"a":2,"n":"m_SkipFirst","t":4,"rt":$n[0].Int32,"sn":"m_SkipFirst","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Cinemachine.TagFieldAttribute(),new UnityEngine.TooltipAttribute("If set, only triggers generated by objects with this tag will be considered")],"a":2,"n":"m_WithTag","t":4,"rt":$n[0].String,"sn":"m_WithTag"},{"at":[new Cinemachine.TagFieldAttribute(),new UnityEngine.TooltipAttribute("Triggers generated by objects with this tag will be ignored")],"a":2,"n":"m_WithoutTag","t":4,"rt":$n[0].String,"sn":"m_WithoutTag"}]}; }, $n);
    /*Cinemachine.CinemachineTriggerAction end.*/

    /*Cinemachine.CinemachineTriggerAction+ActionSettings start.*/
    $m("Cinemachine.CinemachineTriggerAction.ActionSettings", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("What action to take")],"a":2,"n":"m_Action","t":4,"rt":$n[1].CinemachineTriggerAction.ActionSettings.Mode,"sn":"m_Action","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineTriggerAction.ActionSettings.Mode, System.Enum.toStringFn(Cinemachine.CinemachineTriggerAction.ActionSettings.Mode));}},{"at":[new UnityEngine.TooltipAttribute("If PriorityBoost, this amount will be added to the virtual camera's priority")],"a":2,"n":"m_BoostAmount","t":4,"rt":$n[0].Int32,"sn":"m_BoostAmount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("This event will be invoked")],"a":2,"n":"m_Event","t":4,"rt":$n[1].CinemachineTriggerAction.ActionSettings.TriggerEvent,"sn":"m_Event"},{"at":[new UnityEngine.TooltipAttribute("How to interpret the start time")],"a":2,"n":"m_Mode","t":4,"rt":$n[1].CinemachineTriggerAction.ActionSettings.TimeMode,"sn":"m_Mode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineTriggerAction.ActionSettings.TimeMode, System.Enum.toStringFn(Cinemachine.CinemachineTriggerAction.ActionSettings.TimeMode));}},{"at":[new UnityEngine.TooltipAttribute("If playing a timeline, start at this time")],"a":2,"n":"m_StartTime","t":4,"rt":$n[0].Single,"sn":"m_StartTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The target object on which to operate.  If null, then the current behaviour/GameObject will be used")],"a":2,"n":"m_Target","t":4,"rt":$n[2].Object,"sn":"m_Target"}]}; }, $n);
    /*Cinemachine.CinemachineTriggerAction+ActionSettings end.*/

    /*Cinemachine.CinemachineTriggerAction+ActionSettings+TriggerEvent start.*/
    $m("Cinemachine.CinemachineTriggerAction.ActionSettings.TriggerEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*Cinemachine.CinemachineTriggerAction+ActionSettings+TriggerEvent end.*/

    /*Cinemachine.CinemachineVirtualCameraBase+TransitionParams start.*/
    $m("Cinemachine.CinemachineVirtualCameraBase.TransitionParams", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Hint for blending positions to and from this virtual camera"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_PositionBlending")],"a":2,"n":"m_BlendHint","t":4,"rt":$n[1].CinemachineVirtualCameraBase.BlendHint,"sn":"m_BlendHint","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineVirtualCameraBase.BlendHint, System.Enum.toStringFn(Cinemachine.CinemachineVirtualCameraBase.BlendHint));}},{"at":[new UnityEngine.TooltipAttribute("When this virtual camera goes Live, attempt to force the position to be the same as the current position of the Unity Camera")],"a":2,"n":"m_InheritPosition","t":4,"rt":$n[0].Boolean,"sn":"m_InheritPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("This event fires when the virtual camera goes Live")],"a":2,"n":"m_OnCameraLive","t":4,"rt":$n[1].CinemachineBrain.VcamActivatedEvent,"sn":"m_OnCameraLive"}]}; }, $n);
    /*Cinemachine.CinemachineVirtualCameraBase+TransitionParams end.*/

    /*Cinemachine.DocumentationSortingAttribute start.*/
    $m("Cinemachine.DocumentationSortingAttribute", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(0)]}; }, $n);
    /*Cinemachine.DocumentationSortingAttribute end.*/

    /*Cinemachine.LensSettings start.*/
    $m("Cinemachine.LensSettings", function () { return {"at":[new System.SerializableAttribute(),new Cinemachine.DocumentationSortingAttribute(2)],"m":[{"at":[new UnityEngine.RangeAttribute(-180.0, 180.0),new UnityEngine.TooltipAttribute("Camera Z roll, or tilt, in degrees.")],"a":2,"n":"Dutch","t":4,"rt":$n[0].Single,"sn":"Dutch","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("This defines the far region of the renderable range of the camera frustum. Typically you want to set this value as low as possible without cutting off desired distant objects")],"a":2,"n":"FarClipPlane","t":4,"rt":$n[0].Single,"sn":"FarClipPlane","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(1.0, 179.0),new UnityEngine.TooltipAttribute("This is the camera view in vertical degrees. For cinematic people, a 50mm lens on a super-35mm sensor would equal a 19.6 degree FOV")],"a":2,"n":"FieldOfView","t":4,"rt":$n[0].Single,"sn":"FieldOfView","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("This defines the near region in the renderable range of the camera frustum. Raising this value will stop the game from drawing things near the camera, which can sometimes come in handy.  Larger values will also increase your shadow resolution.")],"a":2,"n":"NearClipPlane","t":4,"rt":$n[0].Single,"sn":"NearClipPlane","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("When using an orthographic camera, this defines the half-height, in world coordinates, of the camera view.")],"a":2,"n":"OrthographicSize","t":4,"rt":$n[0].Single,"sn":"OrthographicSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.LensSettings end.*/

    /*Cinemachine.NoiseSettings+NoiseParams start.*/
    $m("Cinemachine.NoiseSettings.NoiseParams", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The amplitude of the noise for this channel.  Larger numbers vibrate higher.")],"a":2,"n":"Amplitude","t":4,"rt":$n[0].Single,"sn":"Amplitude","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If checked, then the amplitude and frequency will not be randomized.")],"a":2,"n":"Constant","t":4,"rt":$n[0].Boolean,"sn":"Constant","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The frequency of noise for this channel.  Higher magnitudes vibrate faster.")],"a":2,"n":"Frequency","t":4,"rt":$n[0].Single,"sn":"Frequency","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.NoiseSettings+NoiseParams end.*/

    /*Cinemachine.NoiseSettings+TransformNoiseParams start.*/
    $m("Cinemachine.NoiseSettings.TransformNoiseParams", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Noise definition for X-axis")],"a":2,"n":"X","t":4,"rt":$n[1].NoiseSettings.NoiseParams,"sn":"X"},{"at":[new UnityEngine.TooltipAttribute("Noise definition for Y-axis")],"a":2,"n":"Y","t":4,"rt":$n[1].NoiseSettings.NoiseParams,"sn":"Y"},{"at":[new UnityEngine.TooltipAttribute("Noise definition for Z-axis")],"a":2,"n":"Z","t":4,"rt":$n[1].NoiseSettings.NoiseParams,"sn":"Z"}]}; }, $n);
    /*Cinemachine.NoiseSettings+TransformNoiseParams end.*/

    /*Cinemachine.PostFX.CinemachinePostProcessing start.*/
    $m("Cinemachine.PostFX.CinemachinePostProcessing", function () { return {"at":[new UnityEngine.AddComponentMenu.ctor("")]}; }, $n);
    /*Cinemachine.PostFX.CinemachinePostProcessing end.*/

    /*Cinemachine.PostFX.CinemachineVolumeSettings start.*/
    $m("Cinemachine.PostFX.CinemachineVolumeSettings", function () { return {"at":[new UnityEngine.AddComponentMenu.ctor("")]}; }, $n);
    /*Cinemachine.PostFX.CinemachineVolumeSettings end.*/

    /*Cinemachine.RuntimeUtility start.*/
    $m("Cinemachine.RuntimeUtility", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(0)]}; }, $n);
    /*Cinemachine.RuntimeUtility end.*/

    /*Cinemachine.UpdateTracker start.*/
    $m("Cinemachine.UpdateTracker", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(0)],"m":[{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.ctor()],"a":1,"n":"InitializeModule","is":true,"t":8,"sn":"InitializeModule","rt":$n[0].Void}]}; }, $n);
    /*Cinemachine.UpdateTracker end.*/

    /*CinemachineTrack start.*/
    $m("CinemachineTrack", function () { return {"at":[new System.SerializableAttribute(),new UnityEngine.Timeline.TrackClipTypeAttribute.ctor(CinemachineShot),new UnityEngine.Timeline.TrackBindingTypeAttribute.ctor(Cinemachine.CinemachineBrain),new UnityEngine.Timeline.TrackColorAttribute(0.53, 0.0, 0.08)]}; }, $n);
    /*CinemachineTrack end.*/

    /*Cinemachine.CinemachineBasicMultiChannelPerlin start.*/
    $m("Cinemachine.CinemachineBasicMultiChannelPerlin", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":1,"n":"mNoiseOffsets","t":4,"rt":$n[2].Vector3,"sn":"mNoiseOffsets"},{"at":[new UnityEngine.TooltipAttribute("Gain to apply to the amplitudes defined in the NoiseSettings asset.  1 is normal.  Setting this to 0 completely mutes the noise.")],"a":2,"n":"m_AmplitudeGain","t":4,"rt":$n[0].Single,"sn":"m_AmplitudeGain","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Scale factor to apply to the frequencies defined in the NoiseSettings asset.  1 is normal.  Larger magnitudes will make the noise shake more rapidly.")],"a":2,"n":"m_FrequencyGain","t":4,"rt":$n[0].Single,"sn":"m_FrequencyGain","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The asset containing the Noise Profile.  Define the frequencies and amplitudes there to make a characteristic noise profile.  Make your own or just use one of the many presets."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_Definition"),new Cinemachine.NoiseSettingsPropertyAttribute()],"a":2,"n":"m_NoiseProfile","t":4,"rt":$n[1].NoiseSettings,"sn":"m_NoiseProfile"},{"at":[new UnityEngine.TooltipAttribute("When rotating the camera, offset the camera's pivot position by this much (camera space)")],"a":2,"n":"m_PivotOffset","t":4,"rt":$n[2].Vector3,"sn":"m_PivotOffset"}]}; }, $n);
    /*Cinemachine.CinemachineBasicMultiChannelPerlin end.*/

    /*Cinemachine.CinemachineVirtualCameraBase start.*/
    $m("Cinemachine.CinemachineVirtualCameraBase", function () { return {"at":[new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute(),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_ExcludedPropertiesInInspector","t":4,"rt":$n[0].Array.type(System.String),"sn":"m_ExcludedPropertiesInInspector"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute(),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_LockStageInInspector","t":4,"rt":System.Array.type(Cinemachine.CinemachineCore.Stage),"sn":"m_LockStageInInspector"},{"at":[new Cinemachine.NoSaveDuringPlayAttribute(),new UnityEngine.TooltipAttribute("The priority will determine which camera becomes active based on the state of other cameras and this camera.  Higher numbers have greater priority.")],"a":2,"n":"m_Priority","t":4,"rt":$n[0].Int32,"sn":"m_Priority","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("When the virtual camera is not live, this is how often the virtual camera will be updated.  Set this to tune for performance. Most of the time Never is fine, unless the virtual camera is doing shot evaluation.")],"a":2,"n":"m_StandbyUpdate","t":4,"rt":$n[1].CinemachineVirtualCameraBase.StandbyUpdateMode,"sn":"m_StandbyUpdate","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineVirtualCameraBase.StandbyUpdateMode, System.Enum.toStringFn(Cinemachine.CinemachineVirtualCameraBase.StandbyUpdateMode));}},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute(),new Cinemachine.NoSaveDuringPlayAttribute()],"a":1,"n":"m_StreamingVersion","t":4,"rt":$n[0].Int32,"sn":"m_StreamingVersion","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Cinemachine.CinemachineVirtualCameraBase end.*/

    /*Cinemachine.CinemachineBrain+BrainEvent start.*/
    $m("Cinemachine.CinemachineBrain.BrainEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*Cinemachine.CinemachineBrain+BrainEvent end.*/

    /*Cinemachine.CinemachineBrain+VcamActivatedEvent start.*/
    $m("Cinemachine.CinemachineBrain.VcamActivatedEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*Cinemachine.CinemachineBrain+VcamActivatedEvent end.*/

    /*Cinemachine.CinemachineCollider start.*/
    $m("Cinemachine.CinemachineCollider", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute(),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.TooltipAttribute("When enabled, will attempt to resolve situations where the line of sight to the target is blocked by an obstacle"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_PreserveLineOfSight")],"a":2,"n":"m_AvoidObstacles","t":4,"rt":$n[0].Boolean,"sn":"m_AvoidObstacles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Camera will try to maintain this distance from any obstacle.  Try to keep this value small.  Increase it if you are seeing inside obstacles due to a large FOV on the camera.")],"a":2,"n":"m_CameraRadius","t":4,"rt":$n[0].Single,"sn":"m_CameraRadius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Obstacle Detection"),new UnityEngine.TooltipAttribute("Objects on these layers will be detected")],"a":2,"n":"m_CollideAgainst","t":4,"rt":$n[2].LayerMask,"sn":"m_CollideAgainst"},{"at":[new UnityEngine.RangeAttribute(0.0, 10.0),new UnityEngine.TooltipAttribute("How gradually the camera returns to its normal position after having been corrected.  Higher numbers will move the camera more gradually back to normal."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_Smoothing")],"a":2,"n":"m_Damping","t":4,"rt":$n[0].Single,"sn":"m_Damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 10.0),new UnityEngine.TooltipAttribute("How gradually the camera moves to resolve an occlusion.  Higher numbers will move the camera more gradually.")],"a":2,"n":"m_DampingWhenOccluded","t":4,"rt":$n[0].Single,"sn":"m_DampingWhenOccluded","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The maximum raycast distance when checking if the line of sight to this camera's target is clear.  If the setting is 0 or less, the current actual distance to target will be used."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_LineOfSightFeelerDistance")],"a":2,"n":"m_DistanceLimit","t":4,"rt":$n[0].Single,"sn":"m_DistanceLimit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Cinemachine.TagFieldAttribute(),new UnityEngine.TooltipAttribute("Obstacles with this tag will be ignored.  It is a good idea to set this field to the target's tag")],"a":2,"n":"m_IgnoreTag","t":4,"rt":$n[0].String,"sn":"m_IgnoreTag"},{"at":[new UnityEngine.RangeAttribute(1.0, 10.0),new UnityEngine.TooltipAttribute("Upper limit on how many obstacle hits to process.  Higher numbers may impact performance.  In most environments, 4 is enough.")],"a":2,"n":"m_MaximumEffort","t":4,"rt":$n[0].Int32,"sn":"m_MaximumEffort","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Obstacles closer to the target than this will be ignored")],"a":2,"n":"m_MinimumDistanceFromTarget","t":4,"rt":$n[0].Single,"sn":"m_MinimumDistanceFromTarget","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Don't take action unless occlusion has lasted at least this long.")],"a":2,"n":"m_MinimumOcclusionTime","t":4,"rt":$n[0].Single,"sn":"m_MinimumOcclusionTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Shot Evaluation"),new UnityEngine.TooltipAttribute("If greater than zero, a higher score will be given to shots when the target is closer to this distance.  Set this to zero to disable this feature.")],"a":2,"n":"m_OptimalTargetDistance","t":4,"rt":$n[0].Single,"sn":"m_OptimalTargetDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("Smoothing to apply to obstruction resolution.  Nearest camera point is held for at least this long")],"a":2,"n":"m_SmoothingTime","t":4,"rt":$n[0].Single,"sn":"m_SmoothingTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The way in which the Collider will attempt to preserve sight of the target.")],"a":2,"n":"m_Strategy","t":4,"rt":$n[1].CinemachineCollider.ResolutionStrategy,"sn":"m_Strategy","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineCollider.ResolutionStrategy, System.Enum.toStringFn(Cinemachine.CinemachineCollider.ResolutionStrategy));}},{"at":[new UnityEngine.TooltipAttribute("Objects on these layers will never obstruct view of the target")],"a":2,"n":"m_TransparentLayers","t":4,"rt":$n[2].LayerMask,"sn":"m_TransparentLayers"}]}; }, $n);
    /*Cinemachine.CinemachineCollider end.*/

    /*Cinemachine.CinemachineCollisionImpulseSource start.*/
    $m("Cinemachine.CinemachineCollisionImpulseSource", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new Cinemachine.TagFieldAttribute(),new UnityEngine.TooltipAttribute("No Impulse evemts will be generated for collisions with objects having these tags")],"a":2,"n":"m_IgnoreTag","t":4,"rt":$n[0].String,"sn":"m_IgnoreTag"},{"at":[new UnityEngine.HeaderAttribute("Trigger Object Filter"),new UnityEngine.TooltipAttribute("Only collisions with objects on these layers will generate Impulse events")],"a":2,"n":"m_LayerMask","t":4,"rt":$n[2].LayerMask,"sn":"m_LayerMask"},{"at":[new UnityEngine.TooltipAttribute("If checked, signal amplitude will be multiplied by the mass of the impacting object")],"a":2,"n":"m_ScaleImpactWithMass","t":4,"rt":$n[0].Boolean,"sn":"m_ScaleImpactWithMass","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("If checked, signal amplitude will be multiplied by the speed of the impacting object")],"a":2,"n":"m_ScaleImpactWithSpeed","t":4,"rt":$n[0].Boolean,"sn":"m_ScaleImpactWithSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("How To Generate The Impulse"),new UnityEngine.TooltipAttribute("If checked, signal direction will be affected by the direction of impact")],"a":2,"n":"m_UseImpactDirection","t":4,"rt":$n[0].Boolean,"sn":"m_UseImpactDirection","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.CinemachineCollisionImpulseSource end.*/

    /*Cinemachine.CinemachineComposer start.*/
    $m("Cinemachine.CinemachineComposer", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.RangeAttribute(-0.5, 0.5),new UnityEngine.TooltipAttribute("A non-zero bias will move the target position horizontally away from the center of the soft zone.")],"a":2,"n":"m_BiasX","t":4,"rt":$n[0].Single,"sn":"m_BiasX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(-0.5, 0.5),new UnityEngine.TooltipAttribute("A non-zero bias will move the target position vertically away from the center of the soft zone.")],"a":2,"n":"m_BiasY","t":4,"rt":$n[0].Single,"sn":"m_BiasY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Force target to center of screen when this camera activates.  If false, will clamp target to the edges of the dead zone")],"a":2,"n":"m_CenterOnActivate","t":4,"rt":$n[0].Boolean,"sn":"m_CenterOnActivate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("Camera will not rotate vertically if the target is within this range of the position.")],"a":2,"n":"m_DeadZoneHeight","t":4,"rt":$n[0].Single,"sn":"m_DeadZoneHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("Camera will not rotate horizontally if the target is within this range of the position.")],"a":2,"n":"m_DeadZoneWidth","t":4,"rt":$n[0].Single,"sn":"m_DeadZoneWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to follow the target in the screen-horizontal direction. Small numbers are more responsive, rapidly orienting the camera to keep the target in the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical and horizontal settings can yield a wide range of camera behaviors.")],"a":2,"n":"m_HorizontalDamping","t":4,"rt":$n[0].Single,"sn":"m_HorizontalDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If checked, movement along the Y axis will be ignored for lookahead calculations")],"a":2,"n":"m_LookaheadIgnoreY","t":4,"rt":$n[0].Boolean,"sn":"m_LookaheadIgnoreY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Controls the smoothness of the lookahead algorithm.  Larger values smooth out jittery predictions and also increase prediction lag"),new UnityEngine.RangeAttribute(3.0, 30.0)],"a":2,"n":"m_LookaheadSmoothing","t":4,"rt":$n[0].Single,"sn":"m_LookaheadSmoothing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.TooltipAttribute("This setting will instruct the composer to adjust its target offset based on the motion of the target.  The composer will look at a point where it estimates the target will be this many seconds into the future.  Note that this setting is sensitive to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.  If the camera jitters unacceptably when the target is in motion, turn down this setting, or animate the target more smoothly."),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"m_LookaheadTime","t":4,"rt":$n[0].Single,"sn":"m_LookaheadTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.5, 1.5),new UnityEngine.TooltipAttribute("Horizontal screen position for target. The camera will rotate to position the tracked object here.")],"a":2,"n":"m_ScreenX","t":4,"rt":$n[0].Single,"sn":"m_ScreenX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(-0.5, 1.5),new UnityEngine.TooltipAttribute("Vertical screen position for target, The camera will rotate to position the tracked object here.")],"a":2,"n":"m_ScreenY","t":4,"rt":$n[0].Single,"sn":"m_ScreenY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("When target is within this region, camera will gradually rotate vertically to re-align towards the desired position, depending on the damping speed.")],"a":2,"n":"m_SoftZoneHeight","t":4,"rt":$n[0].Single,"sn":"m_SoftZoneHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("When target is within this region, camera will gradually rotate horizontally to re-align towards the desired position, depending on the damping speed.")],"a":2,"n":"m_SoftZoneWidth","t":4,"rt":$n[0].Single,"sn":"m_SoftZoneWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Target offset from the target object's center in target-local space. Use this to fine-tune the tracking target position when the desired area is not the tracked object's center.")],"a":2,"n":"m_TrackedObjectOffset","t":4,"rt":$n[2].Vector3,"sn":"m_TrackedObjectOffset"},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to follow the target in the screen-vertical direction. Small numbers are more responsive, rapidly orienting the camera to keep the target in the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical and horizontal settings can yield a wide range of camera behaviors.")],"a":2,"n":"m_VerticalDamping","t":4,"rt":$n[0].Single,"sn":"m_VerticalDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineComposer end.*/

    /*Cinemachine.CinemachineConfiner start.*/
    $m("Cinemachine.CinemachineConfiner", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute(),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("The 2D shape within which the camera is to be contained")],"a":2,"n":"m_BoundingShape2D","t":4,"rt":$n[2].Collider2D,"sn":"m_BoundingShape2D"},{"at":[new UnityEngine.TooltipAttribute("The volume within which the camera is to be contained")],"a":2,"n":"m_BoundingVolume","t":4,"rt":$n[2].Collider,"sn":"m_BoundingVolume"},{"at":[new UnityEngine.TooltipAttribute("The confiner can operate using a 2D bounding shape or a 3D bounding volume")],"a":2,"n":"m_ConfineMode","t":4,"rt":$n[1].CinemachineConfiner.Mode,"sn":"m_ConfineMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineConfiner.Mode, System.Enum.toStringFn(Cinemachine.CinemachineConfiner.Mode));}},{"at":[new UnityEngine.TooltipAttribute("If camera is orthographic, screen edges will be confined to the volume.  If not checked, then only the camera center will be confined")],"a":2,"n":"m_ConfineScreenEdges","t":4,"rt":$n[0].Boolean,"sn":"m_ConfineScreenEdges","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("How gradually to return the camera to the bounding volume if it goes beyond the borders.  Higher numbers are more gradual."),new UnityEngine.RangeAttribute(0.0, 10.0)],"a":2,"n":"m_Damping","t":4,"rt":$n[0].Single,"sn":"m_Damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineConfiner end.*/

    /*Cinemachine.SignalSourceAsset start.*/
    $m("Cinemachine.SignalSourceAsset", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(1)]}; }, $n);
    /*Cinemachine.SignalSourceAsset end.*/

    /*Cinemachine.CinemachineFollowZoom start.*/
    $m("Cinemachine.CinemachineFollowZoom", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute(),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("Increase this value to soften the aggressiveness of the follow-zoom.  Small numbers are more responsive, larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_Damping","t":4,"rt":$n[0].Single,"sn":"m_Damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(1.0, 179.0),new UnityEngine.TooltipAttribute("Upper limit for the FOV that this behaviour will generate.")],"a":2,"n":"m_MaxFOV","t":4,"rt":$n[0].Single,"sn":"m_MaxFOV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(1.0, 179.0),new UnityEngine.TooltipAttribute("Lower limit for the FOV that this behaviour will generate.")],"a":2,"n":"m_MinFOV","t":4,"rt":$n[0].Single,"sn":"m_MinFOV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The shot width to maintain, in world units, at target distance.")],"a":2,"n":"m_Width","t":4,"rt":$n[0].Single,"sn":"m_Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineFollowZoom end.*/

    /*Cinemachine.CinemachineFramingTransposer start.*/
    $m("Cinemachine.CinemachineFramingTransposer", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("How to adjust the camera to get the desired framing.  You can zoom, dolly in/out, or do both.")],"a":2,"n":"m_AdjustmentMode","t":4,"rt":$n[1].CinemachineFramingTransposer.AdjustmentMode,"sn":"m_AdjustmentMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineFramingTransposer.AdjustmentMode, System.Enum.toStringFn(Cinemachine.CinemachineFramingTransposer.AdjustmentMode));}},{"at":[new UnityEngine.RangeAttribute(-0.5, 0.5),new UnityEngine.TooltipAttribute("A non-zero bias will move the target position horizontally away from the center of the soft zone.")],"a":2,"n":"m_BiasX","t":4,"rt":$n[0].Single,"sn":"m_BiasX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(-0.5, 0.5),new UnityEngine.TooltipAttribute("A non-zero bias will move the target position vertically away from the center of the soft zone.")],"a":2,"n":"m_BiasY","t":4,"rt":$n[0].Single,"sn":"m_BiasY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The distance along the camera axis that will be maintained from the Follow target")],"a":2,"n":"m_CameraDistance","t":4,"rt":$n[0].Single,"sn":"m_CameraDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Force target to center of screen when this camera activates.  If false, will clamp target to the edges of the dead zone")],"a":2,"n":"m_CenterOnActivate","t":4,"rt":$n[0].Boolean,"sn":"m_CenterOnActivate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The camera will not move along its z-axis if the Follow target is within this distance of the specified camera distance"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_DistanceDeadZoneSize")],"a":2,"n":"m_DeadZoneDepth","t":4,"rt":$n[0].Single,"sn":"m_DeadZoneDepth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("Camera will not move vertically if the target is within this range of the position.")],"a":2,"n":"m_DeadZoneHeight","t":4,"rt":$n[0].Single,"sn":"m_DeadZoneHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("Camera will not move horizontally if the target is within this range of the position.")],"a":2,"n":"m_DeadZoneWidth","t":4,"rt":$n[0].Single,"sn":"m_DeadZoneWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.TooltipAttribute("What screen dimensions to consider when framing.  Can be Horizontal, Vertical, or both"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_FramingMode")],"a":2,"n":"m_GroupFramingMode","t":4,"rt":$n[1].CinemachineFramingTransposer.FramingMode,"sn":"m_GroupFramingMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineFramingTransposer.FramingMode, System.Enum.toStringFn(Cinemachine.CinemachineFramingTransposer.FramingMode));}},{"at":[new UnityEngine.TooltipAttribute("The bounding box of the targets should occupy this amount of the screen space.  1 means fill the whole screen.  0.5 means fill half the screen, etc.")],"a":2,"n":"m_GroupFramingSize","t":4,"rt":$n[0].Single,"sn":"m_GroupFramingSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If checked, movement along the Y axis will be ignored for lookahead calculations")],"a":2,"n":"m_LookaheadIgnoreY","t":4,"rt":$n[0].Boolean,"sn":"m_LookaheadIgnoreY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Controls the smoothness of the lookahead algorithm.  Larger values smooth out jittery predictions and also increase prediction lag"),new UnityEngine.RangeAttribute(3.0, 30.0)],"a":2,"n":"m_LookaheadSmoothing","t":4,"rt":$n[0].Single,"sn":"m_LookaheadSmoothing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("This setting will instruct the composer to adjust its target offset based on the motion of the target.  The composer will look at a point where it estimates the target will be this many seconds into the future.  Note that this setting is sensitive to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.  If the camera jitters unacceptably when the target is in motion, turn down this setting, or animate the target more smoothly."),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"m_LookaheadTime","t":4,"rt":$n[0].Single,"sn":"m_LookaheadTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The maximum distance toward the target that this behaviour is allowed to move the camera.")],"a":2,"n":"m_MaxDollyIn","t":4,"rt":$n[0].Single,"sn":"m_MaxDollyIn","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The maximum distance away the target that this behaviour is allowed to move the camera.")],"a":2,"n":"m_MaxDollyOut","t":4,"rt":$n[0].Single,"sn":"m_MaxDollyOut","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Set this to limit how far from the target the camera can get.")],"a":2,"n":"m_MaximumDistance","t":4,"rt":$n[0].Single,"sn":"m_MaximumDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(1.0, 179.0),new UnityEngine.TooltipAttribute("If adjusting FOV, will not set the FOV higher than this.")],"a":2,"n":"m_MaximumFOV","t":4,"rt":$n[0].Single,"sn":"m_MaximumFOV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If adjusting Orthographic Size, will not set it higher than this.")],"a":2,"n":"m_MaximumOrthoSize","t":4,"rt":$n[0].Single,"sn":"m_MaximumOrthoSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Set this to limit how close to the target the camera can get.")],"a":2,"n":"m_MinimumDistance","t":4,"rt":$n[0].Single,"sn":"m_MinimumDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(1.0, 179.0),new UnityEngine.TooltipAttribute("If adjusting FOV, will not set the FOV lower than this.")],"a":2,"n":"m_MinimumFOV","t":4,"rt":$n[0].Single,"sn":"m_MinimumFOV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If adjusting Orthographic Size, will not set it lower than this.")],"a":2,"n":"m_MinimumOrthoSize","t":4,"rt":$n[0].Single,"sn":"m_MinimumOrthoSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.5, 1.5),new UnityEngine.TooltipAttribute("Horizontal screen position for target. The camera will move to position the tracked object here.")],"a":2,"n":"m_ScreenX","t":4,"rt":$n[0].Single,"sn":"m_ScreenX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(-0.5, 1.5),new UnityEngine.TooltipAttribute("Vertical screen position for target, The camera will move to position the tracked object here.")],"a":2,"n":"m_ScreenY","t":4,"rt":$n[0].Single,"sn":"m_ScreenY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("When target is within this region, camera will gradually move vertically to re-align towards the desired position, depending on the damping speed.")],"a":2,"n":"m_SoftZoneHeight","t":4,"rt":$n[0].Single,"sn":"m_SoftZoneHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 2.0),new UnityEngine.TooltipAttribute("When target is within this region, camera will gradually move horizontally to re-align towards the desired position, depending on the damping speed.")],"a":2,"n":"m_SoftZoneWidth","t":4,"rt":$n[0].Single,"sn":"m_SoftZoneWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Offset from the Follow Target object (in target-local co-ordinates).  The camera will attempt to frame the point which is the target's position plus this offset.  Use it to correct for cases when the target's origin is not the point of interest for the camera.")],"a":2,"n":"m_TrackedObjectOffset","t":4,"rt":$n[2].Vector3,"sn":"m_TrackedObjectOffset"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.TooltipAttribute("If checked, then then soft zone will be unlimited in size.")],"a":2,"n":"m_UnlimitedSoftZone","t":4,"rt":$n[0].Boolean,"sn":"m_UnlimitedSoftZone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain the offset in the X-axis.   Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_XDamping","t":4,"rt":$n[0].Single,"sn":"m_XDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain the offset in the Y-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_YDamping","t":4,"rt":$n[0].Single,"sn":"m_YDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain the offset in the Z-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_ZDamping","t":4,"rt":$n[0].Single,"sn":"m_ZDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineFramingTransposer end.*/

    /*Cinemachine.CinemachineHardLockToTarget start.*/
    $m("Cinemachine.CinemachineHardLockToTarget", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("How much time it takes for the position to catch up to the target's position")],"a":2,"n":"m_Damping","t":4,"rt":$n[0].Single,"sn":"m_Damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineHardLockToTarget end.*/

    /*Cinemachine.CinemachineHardLookAt start.*/
    $m("Cinemachine.CinemachineHardLookAt", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()]}; }, $n);
    /*Cinemachine.CinemachineHardLookAt end.*/

    /*Cinemachine.CinemachineImpulseListener start.*/
    $m("Cinemachine.CinemachineImpulseListener", function () { return {"at":[new Cinemachine.SaveDuringPlayAttribute(),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Impulse events on channels not included in the mask will be ignored."),new Cinemachine.CinemachineImpulseChannelPropertyAttribute()],"a":2,"n":"m_ChannelMask","t":4,"rt":$n[0].Int32,"sn":"m_ChannelMask","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Gain to apply to the Impulse signal.  1 is normal strength.  Setting this to 0 completely mutes the signal.")],"a":2,"n":"m_Gain","t":4,"rt":$n[0].Single,"sn":"m_Gain","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Enable this to perform distance calculation in 2D (ignore Z)")],"a":2,"n":"m_Use2DDistance","t":4,"rt":$n[0].Boolean,"sn":"m_Use2DDistance","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.CinemachineImpulseListener end.*/

    /*Cinemachine.CinemachineTransposer start.*/
    $m("Cinemachine.CinemachineTransposer", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to track the target's orientation.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_AngularDamping","t":4,"rt":$n[0].Single,"sn":"m_AngularDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The coordinate space to use when interpreting the offset from the target.  This is also used to set the camera's Up vector, which will be maintained when aiming the camera.")],"a":2,"n":"m_BindingMode","t":4,"rt":$n[1].CinemachineTransposer.BindingMode,"sn":"m_BindingMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineTransposer.BindingMode, System.Enum.toStringFn(Cinemachine.CinemachineTransposer.BindingMode));}},{"at":[new UnityEngine.TooltipAttribute("The distance vector that the transposer will attempt to maintain from the Follow target")],"a":2,"n":"m_FollowOffset","t":4,"rt":$n[2].Vector3,"sn":"m_FollowOffset"},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to track the target rotation's X angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_PitchDamping","t":4,"rt":$n[0].Single,"sn":"m_PitchDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to track the target rotation's Z angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_RollDamping","t":4,"rt":$n[0].Single,"sn":"m_RollDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain the offset in the X-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_XDamping","t":4,"rt":$n[0].Single,"sn":"m_XDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain the offset in the Y-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_YDamping","t":4,"rt":$n[0].Single,"sn":"m_YDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to track the target rotation's Y angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_YawDamping","t":4,"rt":$n[0].Single,"sn":"m_YawDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain the offset in the Z-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_ZDamping","t":4,"rt":$n[0].Single,"sn":"m_ZDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineTransposer end.*/

    /*Cinemachine.CinemachinePath start.*/
    $m("Cinemachine.CinemachinePath", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachinePath"),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("If checked, then the path ends are joined to form a continuous loop.")],"a":2,"n":"m_Looped","t":4,"rt":$n[0].Boolean,"sn":"m_Looped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The waypoints that define the path.  They will be interpolated using a bezier curve.")],"a":2,"n":"m_Waypoints","t":4,"rt":System.Array.type(Cinemachine.CinemachinePath.Waypoint),"sn":"m_Waypoints"}]}; }, $n);
    /*Cinemachine.CinemachinePath end.*/

    /*Cinemachine.CinemachinePOV start.*/
    $m("Cinemachine.CinemachinePOV", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Set this if the POV should be applied to the camera state before the body position is calculated.  This is useful for body algorithms that use the rotation as input, for example Framing Transposer.")],"a":2,"n":"m_ApplyBeforeBody","t":4,"rt":$n[0].Boolean,"sn":"m_ApplyBeforeBody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The Horizontal axis.  Value is -180..180.  Controls the horizontal orientation"),new Cinemachine.AxisStatePropertyAttribute()],"a":2,"n":"m_HorizontalAxis","t":4,"rt":$n[1].AxisState,"sn":"m_HorizontalAxis"},{"at":[new UnityEngine.TooltipAttribute("Controls how automatic recentering of the Horizontal axis is accomplished")],"a":2,"n":"m_HorizontalRecentering","t":4,"rt":$n[1].AxisState.Recentering,"sn":"m_HorizontalRecentering"},{"at":[new UnityEngine.TooltipAttribute("The Vertical axis.  Value is -90..90. Controls the vertical orientation"),new Cinemachine.AxisStatePropertyAttribute()],"a":2,"n":"m_VerticalAxis","t":4,"rt":$n[1].AxisState,"sn":"m_VerticalAxis"},{"at":[new UnityEngine.TooltipAttribute("Controls how automatic recentering of the Vertical axis is accomplished")],"a":2,"n":"m_VerticalRecentering","t":4,"rt":$n[1].AxisState.Recentering,"sn":"m_VerticalRecentering"}]}; }, $n);
    /*Cinemachine.CinemachinePOV end.*/

    /*Cinemachine.CinemachineSameAsFollowTarget start.*/
    $m("Cinemachine.CinemachineSameAsFollowTarget", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("How much time it takes for the aim to catch up to the target's rotation"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_AngularDamping")],"a":2,"n":"m_Damping","t":4,"rt":$n[0].Single,"sn":"m_Damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineSameAsFollowTarget end.*/

    /*Cinemachine.CinemachineSmoothPath start.*/
    $m("Cinemachine.CinemachineSmoothPath", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineSmoothPath"),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("If checked, then the path ends are joined to form a continuous loop.")],"a":2,"n":"m_Looped","t":4,"rt":$n[0].Boolean,"sn":"m_Looped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The waypoints that define the path.  They will be interpolated using a bezier curve.")],"a":2,"n":"m_Waypoints","t":4,"rt":System.Array.type(Cinemachine.CinemachineSmoothPath.Waypoint),"sn":"m_Waypoints"}]}; }, $n);
    /*Cinemachine.CinemachineSmoothPath end.*/

    /*Cinemachine.CinemachineStoryboard start.*/
    $m("Cinemachine.CinemachineStoryboard", function () { return {"at":[new Cinemachine.SaveDuringPlayAttribute(),new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.ctor()],"a":1,"n":"InitializeModule","is":true,"t":8,"sn":"InitializeModule","rt":$n[0].Void},{"at":[new UnityEngine.TooltipAttribute("The opacity of the image.  0 is transparent, 1 is opaque"),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"m_Alpha","t":4,"rt":$n[0].Single,"sn":"m_Alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("How to handle differences between image aspect and screen aspect")],"a":2,"n":"m_Aspect","t":4,"rt":$n[1].CinemachineStoryboard.FillStrategy,"sn":"m_Aspect","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineStoryboard.FillStrategy, System.Enum.toStringFn(Cinemachine.CinemachineStoryboard.FillStrategy));}},{"at":[new UnityEngine.TooltipAttribute("The screen-space position at which to display the image.  Zero is center")],"a":2,"n":"m_Center","t":4,"rt":$n[2].Vector2,"sn":"m_Center"},{"at":[new UnityEngine.TooltipAttribute("The image to display")],"a":2,"n":"m_Image","t":4,"rt":$n[2].Texture,"sn":"m_Image"},{"at":[new UnityEngine.TooltipAttribute("If checked, Camera transform will not be controlled by this virtual camera")],"a":2,"n":"m_MuteCamera","t":4,"rt":$n[0].Boolean,"sn":"m_MuteCamera","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The screen-space rotation to apply to the image")],"a":2,"n":"m_Rotation","t":4,"rt":$n[2].Vector3,"sn":"m_Rotation"},{"at":[new UnityEngine.TooltipAttribute("The screen-space scaling to apply to the image")],"a":2,"n":"m_Scale","t":4,"rt":$n[2].Vector2,"sn":"m_Scale"},{"at":[new UnityEngine.TooltipAttribute("If checked, the specified image will be displayed as an overlay over the virtual camera's output")],"a":2,"n":"m_ShowImage","t":4,"rt":$n[0].Boolean,"sn":"m_ShowImage","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-1.0, 1.0),new UnityEngine.TooltipAttribute("Wipe the image on and off horizontally")],"a":2,"n":"m_SplitView","t":4,"rt":$n[0].Single,"sn":"m_SplitView","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If checked, X and Y scale are synchronized")],"a":2,"n":"m_SyncScale","t":4,"rt":$n[0].Boolean,"sn":"m_SyncScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("If checked, all storyboards are globally muted")],"a":2,"n":"s_StoryboardGlobalMute","is":true,"t":4,"rt":$n[0].Boolean,"sn":"s_StoryboardGlobalMute","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.CinemachineStoryboard end.*/

    /*Cinemachine.CinemachineTargetGroup start.*/
    $m("Cinemachine.CinemachineTargetGroup", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineTargetGroup"),new Cinemachine.SaveDuringPlayAttribute(),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("How the group's position is calculated.  Select GroupCenter for the center of the bounding box, and GroupAverage for a weighted average of the positions of the members.")],"a":2,"n":"m_PositionMode","t":4,"rt":$n[1].CinemachineTargetGroup.PositionMode,"sn":"m_PositionMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineTargetGroup.PositionMode, System.Enum.toStringFn(Cinemachine.CinemachineTargetGroup.PositionMode));}},{"at":[new UnityEngine.TooltipAttribute("How the group's rotation is calculated.  Select Manual to use the value in the group's transform, and GroupAverage for a weighted average of the orientations of the members.")],"a":2,"n":"m_RotationMode","t":4,"rt":$n[1].CinemachineTargetGroup.RotationMode,"sn":"m_RotationMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineTargetGroup.RotationMode, System.Enum.toStringFn(Cinemachine.CinemachineTargetGroup.RotationMode));}},{"at":[new Cinemachine.NoSaveDuringPlayAttribute(),new UnityEngine.TooltipAttribute("The target objects, together with their weights and radii, that will contribute to the group's average position, orientation, and size.")],"a":2,"n":"m_Targets","t":4,"rt":System.Array.type(Cinemachine.CinemachineTargetGroup.Target),"sn":"m_Targets"},{"at":[new UnityEngine.TooltipAttribute("When to update the group's transform based on the position of the group members")],"a":2,"n":"m_UpdateMethod","t":4,"rt":$n[1].CinemachineTargetGroup.UpdateMethod,"sn":"m_UpdateMethod","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineTargetGroup.UpdateMethod, System.Enum.toStringFn(Cinemachine.CinemachineTargetGroup.UpdateMethod));}}]}; }, $n);
    /*Cinemachine.CinemachineTargetGroup end.*/

    /*Cinemachine.CinemachineTrackedDolly start.*/
    $m("Cinemachine.CinemachineTrackedDolly", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Controls how automatic dollying occurs.  A Follow target is necessary to use this feature.")],"a":2,"n":"m_AutoDolly","t":4,"rt":$n[1].CinemachineTrackedDolly.AutoDolly,"sn":"m_AutoDolly"},{"at":[new UnityEngine.TooltipAttribute("How to set the virtual camera's Up vector.  This will affect the screen composition, because the camera Aim behaviours will always try to respect the Up direction.")],"a":2,"n":"m_CameraUp","t":4,"rt":$n[1].CinemachineTrackedDolly.CameraUpMode,"sn":"m_CameraUp","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineTrackedDolly.CameraUpMode, System.Enum.toStringFn(Cinemachine.CinemachineTrackedDolly.CameraUpMode));}},{"at":[new UnityEngine.TooltipAttribute("The path to which the camera will be constrained.  This must be non-null.")],"a":2,"n":"m_Path","t":4,"rt":$n[1].CinemachinePathBase,"sn":"m_Path"},{"at":[new UnityEngine.TooltipAttribute("Where to put the camera relative to the path position.  X is perpendicular to the path, Y is up, and Z is parallel to the path.  This allows the camera to be offset from the path itself (as if on a tripod, for example).")],"a":2,"n":"m_PathOffset","t":4,"rt":$n[2].Vector3,"sn":"m_PathOffset"},{"at":[new UnityEngine.TooltipAttribute("The position along the path at which the camera will be placed.  This can be animated directly, or set automatically by the Auto-Dolly feature to get as close as possible to the Follow target.  The value is interpreted according to the Position Units setting.")],"a":2,"n":"m_PathPosition","t":4,"rt":$n[0].Single,"sn":"m_PathPosition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to track the target rotation's X angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_PitchDamping","t":4,"rt":$n[0].Single,"sn":"m_PitchDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("How to interpret Path Position.  If set to Path Units, values are as follows: 0 represents the first waypoint on the path, 1 is the second, and so on.  Values in-between are points on the path in between the waypoints.  If set to Distance, then Path Position represents distance along the path.")],"a":2,"n":"m_PositionUnits","t":4,"rt":$n[1].CinemachinePathBase.PositionUnits,"sn":"m_PositionUnits","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachinePathBase.PositionUnits, System.Enum.toStringFn(Cinemachine.CinemachinePathBase.PositionUnits));}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to track the target rotation's Z angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_RollDamping","t":4,"rt":$n[0].Single,"sn":"m_RollDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain its position in a direction perpendicular to the path.  Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_XDamping","t":4,"rt":$n[0].Single,"sn":"m_XDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain its position in the path-local up direction.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_YDamping","t":4,"rt":$n[0].Single,"sn":"m_YDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to track the target rotation's Y angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_YawDamping","t":4,"rt":$n[0].Single,"sn":"m_YawDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to maintain its position in a direction parallel to the path.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")],"a":2,"n":"m_ZDamping","t":4,"rt":$n[0].Single,"sn":"m_ZDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineTrackedDolly end.*/

    /*CinemachineCameraOffset start.*/
    $m("CinemachineCameraOffset", function () { return {"at":[new UnityEngine.AddComponentMenu.ctor(""),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("When to apply the offset")],"a":2,"n":"m_ApplyAfter","t":4,"rt":$n[1].CinemachineCore.Stage,"sn":"m_ApplyAfter","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineCore.Stage, System.Enum.toStringFn(Cinemachine.CinemachineCore.Stage));}},{"at":[new UnityEngine.TooltipAttribute("Offset the camera's position by this much (camera space)")],"a":2,"n":"m_Offset","t":4,"rt":$n[2].Vector3,"sn":"m_Offset"},{"at":[new UnityEngine.TooltipAttribute("If applying offset after aim, re-adjust the aim to preserve the screen position of the LookAt target as much as possible")],"a":2,"n":"m_PreserveComposition","t":4,"rt":$n[0].Boolean,"sn":"m_PreserveComposition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*CinemachineCameraOffset end.*/

    /*Cinemachine.CinemachineBlendListCamera start.*/
    $m("Cinemachine.CinemachineBlendListCamera", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.ExcludeFromPresetAttribute(),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineBlendListCamera")],"m":[{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new Cinemachine.NoSaveDuringPlayAttribute()],"a":4,"n":"m_ChildCameras","t":4,"rt":System.Array.type(Cinemachine.CinemachineVirtualCameraBase),"sn":"m_ChildCameras"},{"at":[new UnityEngine.TooltipAttribute("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all of the children define targets of their own."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_Follow","t":4,"rt":$n[2].Transform,"sn":"m_Follow"},{"at":[new UnityEngine.TooltipAttribute("The set of instructions for enabling child cameras.")],"a":2,"n":"m_Instructions","t":4,"rt":System.Array.type(Cinemachine.CinemachineBlendListCamera.Instruction),"sn":"m_Instructions"},{"at":[new UnityEngine.TooltipAttribute("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all of the children define targets of their own."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_LookAt","t":4,"rt":$n[2].Transform,"sn":"m_LookAt"},{"at":[new UnityEngine.TooltipAttribute("When enabled, the child vcams will cycle indefinitely instead of just stopping at the last one")],"a":2,"n":"m_Loop","t":4,"rt":$n[0].Boolean,"sn":"m_Loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("When enabled, the current child camera and blend will be indicated in the game window, for debugging")],"a":2,"n":"m_ShowDebugText","t":4,"rt":$n[0].Boolean,"sn":"m_ShowDebugText","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.CinemachineBlendListCamera end.*/

    /*Cinemachine.CinemachineClearShot start.*/
    $m("Cinemachine.CinemachineClearShot", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.ExcludeFromPresetAttribute(),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineClearShot")],"m":[{"at":[new UnityEngine.TooltipAttribute("Wait this many seconds before activating a new child camera")],"a":2,"n":"m_ActivateAfter","t":4,"rt":$n[0].Single,"sn":"m_ActivateAfter","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new Cinemachine.NoSaveDuringPlayAttribute()],"a":4,"n":"m_ChildCameras","t":4,"rt":System.Array.type(Cinemachine.CinemachineVirtualCameraBase),"sn":"m_ChildCameras"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"m_CustomBlends","t":4,"rt":$n[1].CinemachineBlenderSettings,"sn":"m_CustomBlends"},{"at":[new Cinemachine.CinemachineBlendDefinitionPropertyAttribute(),new UnityEngine.TooltipAttribute("The blend which is used if you don't explicitly define a blend between two Virtual Cameras")],"a":2,"n":"m_DefaultBlend","t":4,"rt":$n[1].CinemachineBlendDefinition,"sn":"m_DefaultBlend"},{"at":[new UnityEngine.TooltipAttribute("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all children specify targets of their own."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_Follow","t":4,"rt":$n[2].Transform,"sn":"m_Follow"},{"at":[new UnityEngine.TooltipAttribute("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all children specify targets of their own."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_LookAt","t":4,"rt":$n[2].Transform,"sn":"m_LookAt"},{"at":[new UnityEngine.TooltipAttribute("An active camera must be active for at least this many seconds")],"a":2,"n":"m_MinDuration","t":4,"rt":$n[0].Single,"sn":"m_MinDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If checked, camera choice will be randomized if multiple cameras are equally desirable.  Otherwise, child list order and child camera priority will be used.")],"a":2,"n":"m_RandomizeChoice","t":4,"rt":$n[0].Boolean,"sn":"m_RandomizeChoice","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("When enabled, the current child camera and blend will be indicated in the game window, for debugging"),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_ShowDebugText","t":4,"rt":$n[0].Boolean,"sn":"m_ShowDebugText","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.CinemachineClearShot end.*/

    /*Cinemachine.CinemachineExternalCamera start.*/
    $m("Cinemachine.CinemachineExternalCamera", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.RequireComponent.ctor(UnityEngine.Camera),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineExternalCamera"),new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("Hint for blending positions to and from this virtual camera"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_PositionBlending")],"a":2,"n":"m_BlendHint","t":4,"rt":$n[1].CinemachineVirtualCameraBase.BlendHint,"sn":"m_BlendHint","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineVirtualCameraBase.BlendHint, System.Enum.toStringFn(Cinemachine.CinemachineVirtualCameraBase.BlendHint));}},{"at":[new UnityEngine.TooltipAttribute("The object that the camera is looking at.  Setting this will improve the quality of the blends to and from this camera"),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_LookAt","t":4,"rt":$n[2].Transform,"sn":"m_LookAt"}]}; }, $n);
    /*Cinemachine.CinemachineExternalCamera end.*/

    /*Cinemachine.CinemachineFixedSignal start.*/
    $m("Cinemachine.CinemachineFixedSignal", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)],"m":[{"at":[new UnityEngine.TooltipAttribute("The raw signal shape along the X axis")],"a":2,"n":"m_XCurve","t":4,"rt":pc.AnimationCurve,"sn":"m_XCurve"},{"at":[new UnityEngine.TooltipAttribute("The raw signal shape along the Y axis")],"a":2,"n":"m_YCurve","t":4,"rt":pc.AnimationCurve,"sn":"m_YCurve"},{"at":[new UnityEngine.TooltipAttribute("The raw signal shape along the Z axis")],"a":2,"n":"m_ZCurve","t":4,"rt":pc.AnimationCurve,"sn":"m_ZCurve"}]}; }, $n);
    /*Cinemachine.CinemachineFixedSignal end.*/

    /*Cinemachine.CinemachineFreeLook start.*/
    $m("Cinemachine.CinemachineFreeLook", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.ExcludeFromPresetAttribute(),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineFreeLook")],"m":[{"at":[new UnityEngine.HeaderAttribute("Orbits"),new UnityEngine.TooltipAttribute("The coordinate space to use when interpreting the offset from the target.  This is also used to set the camera's Up vector, which will be maintained when aiming the camera.")],"a":2,"n":"m_BindingMode","t":4,"rt":$n[1].CinemachineTransposer.BindingMode,"sn":"m_BindingMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineTransposer.BindingMode, System.Enum.toStringFn(Cinemachine.CinemachineTransposer.BindingMode));}},{"at":[new UnityEngine.TooltipAttribute("If enabled, this lens setting will apply to all three child rigs, otherwise the child rig lens settings will be used"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_UseCommonLensSetting")],"a":2,"n":"m_CommonLens","t":4,"rt":$n[0].Boolean,"sn":"m_CommonLens","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Object for the camera children wants to move with (the body target)."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_Follow","t":4,"rt":$n[2].Transform,"sn":"m_Follow"},{"at":[new Cinemachine.OrbitalTransposerHeadingPropertyAttribute(),new UnityEngine.TooltipAttribute("The definition of Forward.  Camera will follow behind.")],"a":2,"n":"m_Heading","t":4,"rt":$n[1].CinemachineOrbitalTransposer.Heading,"sn":"m_Heading"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_BlendHint"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_PositionBlending")],"a":1,"n":"m_LegacyBlendHint","t":4,"rt":$n[1].CinemachineVirtualCameraBase.BlendHint,"sn":"m_LegacyBlendHint","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineVirtualCameraBase.BlendHint, System.Enum.toStringFn(Cinemachine.CinemachineVirtualCameraBase.BlendHint));}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HeadingBias")],"a":1,"n":"m_LegacyHeadingBias","t":4,"rt":$n[0].Single,"sn":"m_LegacyHeadingBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_LensAttributes"),new UnityEngine.TooltipAttribute("Specifies the lens properties of this Virtual Camera.  This generally mirrors the Unity Camera's lens settings, and will be used to drive the Unity camera when the vcam is active"),new Cinemachine.LensSettingsPropertyAttribute()],"a":2,"n":"m_Lens","t":4,"rt":$n[1].LensSettings,"sn":"m_Lens"},{"at":[new UnityEngine.TooltipAttribute("Object for the camera children to look at (the aim target)."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_LookAt","t":4,"rt":$n[2].Transform,"sn":"m_LookAt"},{"at":[new UnityEngine.TooltipAttribute("The radius and height of the three orbiting rigs.")],"a":2,"n":"m_Orbits","t":4,"rt":System.Array.type(Cinemachine.CinemachineFreeLook.Orbit),"sn":"m_Orbits"},{"at":[new UnityEngine.TooltipAttribute("Controls how automatic recentering of the X axis is accomplished")],"a":2,"n":"m_RecenterToTargetHeading","t":4,"rt":$n[1].AxisState.Recentering,"sn":"m_RecenterToTargetHeading"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new Cinemachine.NoSaveDuringPlayAttribute()],"a":1,"n":"m_Rigs","t":4,"rt":System.Array.type(Cinemachine.CinemachineVirtualCamera),"sn":"m_Rigs"},{"at":[new UnityEngine.TooltipAttribute("Controls how taut is the line that connects the rigs' orbits, which determines final placement on the Y axis"),new UnityEngine.RangeAttribute(0.0, 1.0),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_SplineTension")],"a":2,"n":"m_SplineCurvature","t":4,"rt":$n[0].Single,"sn":"m_SplineCurvature","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The Horizontal axis.  Value is -180...180.  This is passed on to the rigs' OrbitalTransposer component"),new Cinemachine.AxisStatePropertyAttribute()],"a":2,"n":"m_XAxis","t":4,"rt":$n[1].AxisState,"sn":"m_XAxis"},{"at":[new UnityEngine.HeaderAttribute("Axis Control"),new UnityEngine.TooltipAttribute("The Vertical axis.  Value is 0..1.  Chooses how to blend the child rigs"),new Cinemachine.AxisStatePropertyAttribute()],"a":2,"n":"m_YAxis","t":4,"rt":$n[1].AxisState,"sn":"m_YAxis"},{"at":[new UnityEngine.TooltipAttribute("Controls how automatic recentering of the Y axis is accomplished")],"a":2,"n":"m_YAxisRecentering","t":4,"rt":$n[1].AxisState.Recentering,"sn":"m_YAxisRecentering"}]}; }, $n);
    /*Cinemachine.CinemachineFreeLook end.*/

    /*Cinemachine.CinemachineGroupComposer start.*/
    $m("Cinemachine.CinemachineGroupComposer", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.TooltipAttribute("How to adjust the camera to get the desired framing.  You can zoom, dolly in/out, or do both.")],"a":2,"n":"m_AdjustmentMode","t":4,"rt":$n[1].CinemachineGroupComposer.AdjustmentMode,"sn":"m_AdjustmentMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineGroupComposer.AdjustmentMode, System.Enum.toStringFn(Cinemachine.CinemachineGroupComposer.AdjustmentMode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 20.0),new UnityEngine.TooltipAttribute("How aggressively the camera tries to frame the group. Small numbers are more responsive, rapidly adjusting the camera to keep the group in the frame.  Larger numbers give a more heavy slowly responding camera.")],"a":2,"n":"m_FrameDamping","t":4,"rt":$n[0].Single,"sn":"m_FrameDamping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("What screen dimensions to consider when framing.  Can be Horizontal, Vertical, or both")],"a":2,"n":"m_FramingMode","t":4,"rt":$n[1].CinemachineGroupComposer.FramingMode,"sn":"m_FramingMode","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineGroupComposer.FramingMode, System.Enum.toStringFn(Cinemachine.CinemachineGroupComposer.FramingMode));}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.TooltipAttribute("The bounding box of the targets should occupy this amount of the screen space.  1 means fill the whole screen.  0.5 means fill half the screen, etc.")],"a":2,"n":"m_GroupFramingSize","t":4,"rt":$n[0].Single,"sn":"m_GroupFramingSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The maximum distance toward the target that this behaviour is allowed to move the camera.")],"a":2,"n":"m_MaxDollyIn","t":4,"rt":$n[0].Single,"sn":"m_MaxDollyIn","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The maximum distance away the target that this behaviour is allowed to move the camera.")],"a":2,"n":"m_MaxDollyOut","t":4,"rt":$n[0].Single,"sn":"m_MaxDollyOut","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Set this to limit how far from the target the camera can get.")],"a":2,"n":"m_MaximumDistance","t":4,"rt":$n[0].Single,"sn":"m_MaximumDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(1.0, 179.0),new UnityEngine.TooltipAttribute("If adjusting FOV, will not set the FOV higher than this.")],"a":2,"n":"m_MaximumFOV","t":4,"rt":$n[0].Single,"sn":"m_MaximumFOV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If adjusting Orthographic Size, will not set it higher than this.")],"a":2,"n":"m_MaximumOrthoSize","t":4,"rt":$n[0].Single,"sn":"m_MaximumOrthoSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Set this to limit how close to the target the camera can get.")],"a":2,"n":"m_MinimumDistance","t":4,"rt":$n[0].Single,"sn":"m_MinimumDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(1.0, 179.0),new UnityEngine.TooltipAttribute("If adjusting FOV, will not set the FOV lower than this.")],"a":2,"n":"m_MinimumFOV","t":4,"rt":$n[0].Single,"sn":"m_MinimumFOV","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If adjusting Orthographic Size, will not set it lower than this.")],"a":2,"n":"m_MinimumOrthoSize","t":4,"rt":$n[0].Single,"sn":"m_MinimumOrthoSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineGroupComposer end.*/

    /*Cinemachine.CinemachineMixingCamera start.*/
    $m("Cinemachine.CinemachineMixingCamera", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.ExcludeFromPresetAttribute(),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineMixingCamera")],"m":[{"at":[new UnityEngine.TooltipAttribute("The weight of the first tracked camera")],"a":2,"n":"m_Weight0","t":4,"rt":$n[0].Single,"sn":"m_Weight0","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The weight of the second tracked camera")],"a":2,"n":"m_Weight1","t":4,"rt":$n[0].Single,"sn":"m_Weight1","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The weight of the third tracked camera")],"a":2,"n":"m_Weight2","t":4,"rt":$n[0].Single,"sn":"m_Weight2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The weight of the fourth tracked camera")],"a":2,"n":"m_Weight3","t":4,"rt":$n[0].Single,"sn":"m_Weight3","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The weight of the fifth tracked camera")],"a":2,"n":"m_Weight4","t":4,"rt":$n[0].Single,"sn":"m_Weight4","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The weight of the sixth tracked camera")],"a":2,"n":"m_Weight5","t":4,"rt":$n[0].Single,"sn":"m_Weight5","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The weight of the seventh tracked camera")],"a":2,"n":"m_Weight6","t":4,"rt":$n[0].Single,"sn":"m_Weight6","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The weight of the eighth tracked camera")],"a":2,"n":"m_Weight7","t":4,"rt":$n[0].Single,"sn":"m_Weight7","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Cinemachine.CinemachineMixingCamera end.*/

    /*Cinemachine.CinemachineOrbitalTransposer start.*/
    $m("Cinemachine.CinemachineOrbitalTransposer", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.AddComponentMenu.ctor(""),new Cinemachine.SaveDuringPlayAttribute()],"m":[{"at":[new UnityEngine.SpaceAttribute.ctor(),new Cinemachine.OrbitalTransposerHeadingPropertyAttribute(),new UnityEngine.TooltipAttribute("The definition of Forward.  Camera will follow behind.")],"a":2,"n":"m_Heading","t":4,"rt":$n[1].CinemachineOrbitalTransposer.Heading,"sn":"m_Heading"},{"at":[new UnityEngine.HideInInspector(),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_HeadingIsSlave","t":4,"rt":$n[0].Boolean,"sn":"m_HeadingIsSlave","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HeadingBias")],"a":1,"n":"m_LegacyHeadingBias","t":4,"rt":$n[0].Single,"sn":"m_LegacyHeadingBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HeightOffset")],"a":1,"n":"m_LegacyHeightOffset","t":4,"rt":$n[0].Single,"sn":"m_LegacyHeightOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_Radius")],"a":1,"n":"m_LegacyRadius","t":4,"rt":$n[0].Single,"sn":"m_LegacyRadius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Automatic heading recentering.  The settings here defines how the camera will reposition itself in the absence of player input.")],"a":2,"n":"m_RecenterToTargetHeading","t":4,"rt":$n[1].AxisState.Recentering,"sn":"m_RecenterToTargetHeading"},{"at":[new UnityEngine.TooltipAttribute("Heading Control.  The settings here control the behaviour of the camera in response to the player's input."),new Cinemachine.AxisStatePropertyAttribute()],"a":2,"n":"m_XAxis","t":4,"rt":$n[1].AxisState,"sn":"m_XAxis"}]}; }, $n);
    /*Cinemachine.CinemachineOrbitalTransposer end.*/

    /*Cinemachine.CinemachineStateDrivenCamera start.*/
    $m("Cinemachine.CinemachineStateDrivenCamera", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.ExcludeFromPresetAttribute(),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineStateDrivenCamera")],"m":[{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.TooltipAttribute("The state machine whose state changes will drive this camera's choice of active child"),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_AnimatedTarget","t":4,"rt":$n[2].Animator,"sn":"m_AnimatedTarget"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new Cinemachine.NoSaveDuringPlayAttribute()],"a":4,"n":"m_ChildCameras","t":4,"rt":System.Array.type(Cinemachine.CinemachineVirtualCameraBase),"sn":"m_ChildCameras"},{"at":[new UnityEngine.TooltipAttribute("This is the asset which contains custom settings for specific child blends")],"a":2,"n":"m_CustomBlends","t":4,"rt":$n[1].CinemachineBlenderSettings,"sn":"m_CustomBlends"},{"at":[new Cinemachine.CinemachineBlendDefinitionPropertyAttribute(),new UnityEngine.TooltipAttribute("The blend which is used if you don't explicitly define a blend between two Virtual Camera children")],"a":2,"n":"m_DefaultBlend","t":4,"rt":$n[1].CinemachineBlendDefinition,"sn":"m_DefaultBlend"},{"at":[new UnityEngine.TooltipAttribute("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all of the children define targets of their own."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_Follow","t":4,"rt":$n[2].Transform,"sn":"m_Follow"},{"at":[new UnityEngine.TooltipAttribute("The set of instructions associating virtual cameras with states.  These instructions are used to choose the live child at any given moment")],"a":2,"n":"m_Instructions","t":4,"rt":System.Array.type(Cinemachine.CinemachineStateDrivenCamera.Instruction),"sn":"m_Instructions"},{"at":[new UnityEngine.TooltipAttribute("Which layer in the target state machine to observe"),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_LayerIndex","t":4,"rt":$n[0].Int32,"sn":"m_LayerIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all of the children define targets of their own."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_LookAt","t":4,"rt":$n[2].Transform,"sn":"m_LookAt"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_ParentHash","t":4,"rt":System.Array.type(Cinemachine.CinemachineStateDrivenCamera.ParentHash),"sn":"m_ParentHash"},{"at":[new UnityEngine.TooltipAttribute("When enabled, the current child camera and blend will be indicated in the game window, for debugging")],"a":2,"n":"m_ShowDebugText","t":4,"rt":$n[0].Boolean,"sn":"m_ShowDebugText","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Cinemachine.CinemachineStateDrivenCamera end.*/

    /*Cinemachine.CinemachineVirtualCamera start.*/
    $m("Cinemachine.CinemachineVirtualCamera", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.ExcludeFromPresetAttribute(),new UnityEngine.AddComponentMenu.ctor("Cinemachine/CinemachineVirtualCamera")],"m":[{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":1,"n":"m_ComponentOwner","t":4,"rt":$n[2].Transform,"sn":"m_ComponentOwner"},{"at":[new UnityEngine.TooltipAttribute("The object that the camera wants to move with (the Body target).  If this is null, then the vcam's Transform position will define the camera's position."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_Follow","t":4,"rt":$n[2].Transform,"sn":"m_Follow"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_BlendHint"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_PositionBlending")],"a":1,"n":"m_LegacyBlendHint","t":4,"rt":$n[1].CinemachineVirtualCameraBase.BlendHint,"sn":"m_LegacyBlendHint","box":function ($v) { return Bridge.box($v, Cinemachine.CinemachineVirtualCameraBase.BlendHint, System.Enum.toStringFn(Cinemachine.CinemachineVirtualCameraBase.BlendHint));}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_LensAttributes"),new UnityEngine.TooltipAttribute("Specifies the lens properties of this Virtual Camera.  This generally mirrors the Unity Camera's lens settings, and will be used to drive the Unity camera when the vcam is active."),new Cinemachine.LensSettingsPropertyAttribute()],"a":2,"n":"m_Lens","t":4,"rt":$n[1].LensSettings,"sn":"m_Lens"},{"at":[new UnityEngine.TooltipAttribute("The object that the camera wants to look at (the Aim target).  If this is null, then the vcam's Transform orientation will define the camera's orientation."),new Cinemachine.NoSaveDuringPlayAttribute()],"a":2,"n":"m_LookAt","t":4,"rt":$n[2].Transform,"sn":"m_LookAt"}]}; }, $n);
    /*Cinemachine.CinemachineVirtualCamera end.*/

    /*Cinemachine.NoiseSettings start.*/
    $m("Cinemachine.NoiseSettings", function () { return {"at":[new Cinemachine.DocumentationSortingAttribute(2)],"m":[{"at":[new UnityEngine.TooltipAttribute("These are the noise channels for the virtual camera's orientation. Convincing noise setups typically mix low, medium and high frequencies together, so start with a size of 3"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_Orientation")],"a":2,"n":"OrientationNoise","t":4,"rt":System.Array.type(Cinemachine.NoiseSettings.TransformNoiseParams),"sn":"OrientationNoise"},{"at":[new UnityEngine.TooltipAttribute("These are the noise channels for the virtual camera's position. Convincing noise setups typically mix low, medium and high frequencies together, so start with a size of 3"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_Position")],"a":2,"n":"PositionNoise","t":4,"rt":System.Array.type(Cinemachine.NoiseSettings.TransformNoiseParams),"sn":"PositionNoise"}]}; }, $n);
    /*Cinemachine.NoiseSettings end.*/

    }});
